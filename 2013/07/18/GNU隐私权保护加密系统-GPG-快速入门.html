<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <title>GNU隐私权保护加密系统 GPG 快速入门</title>
  
    <meta name="author" content="Rojazz1999">
    <link type="application/rss+xml" rel="alternate" title="CODE4FUN posts" href="/rss.xml">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="/assets/simple/stylesheets/style.css" type="text/css" rel="stylesheet" media="all">
<link href="/assets/simple/widgets/google_prettify/stylesheets/twitter-bootstrap.css" type="text/css" rel="stylesheet" media="all">


  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>
    <header class="header">
      CODE4FUN
    </header>
    <nav>
      
        


  <a href="/">首页</a>


      
        


  <a href="/archive">文章</a>


      
    </nav>
    <article class="main">
        <header class="title">
GNU隐私权保护加密系统 GPG 快速入门
</header>
<article class="content">
<p>英文原文：<a href="http://futureboy.us/pgp.html">GPG Tutorial</a></p>

<p>由 <a href="http://my.oschina.net/jidianren">几点人</a>, <a href="http://my.oschina.net/yumingzhe">NinjaSquid</a>, <a href="http://my.oschina.net/shichaoyuan">袁不语</a>, <a href="http://my.oschina.net/u/234124">尚御博豪</a>, <a href="http://my.oschina.net/u/1179770">Joynic</a> 翻译.</p>

<p>译文地址: <a href="http://www.oschina.net/translate/pgp-tutorial">http://www.oschina.net/translate/pgp-tutorial</a></p>

<p>本文未包括全文.</p>

<hr />

<p>起初这篇文章只是简单地包含了我的公钥，但随着时间的增长，它已经演变成一篇介绍如何使用以及为何使用GnuPG加密软件来保护隐私的文章，并且本文还在继续完善中。如果您有任何的问题，意见或建议，以及本文所使用的工具和服务器的地址或者与GPG相关的有趣的事物要分享，请告知<a href="eliasen@mindspring.com">Alan Eliasen</a>，谢谢。</p>

<p>###Alan Eliasen的GPG公钥</p>

<p>下面是armored化的OpenPGP格式的公钥( eliasen@mindspring.com)，你可以用它来加密信息但只有我能读取！</p>

<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1.4.12 (GNU/Linux)

mQGiBD0ZXm4RBADS59M4Dy4aOBUA59mKkNg+bWqeKenYs+zTk7O8QKfqgKxLBNya
R9x1ZJ0WARCzjM6wbFvg/2cZyLEvGFqXdVXPuKlB9jR1cgKH+KClOLFWdIJng6B+
lwxw9ho7uE2Gf+faBOktvGaUWk5E8rAwdBkIuvYqDc1YwYcG3iN5zAdNpwCg2JS5
NUqwRMKEVd1q0qUGKuni9ykD/17kSo6XSnirbLE8I4hKt76G09XYaIGioCzyMAv6
kcHJ47yxVRpzTXH5K1Wq09HhHUnW1oZ1tRA0YxwrEESW/fns/U7IU4BgilXKF81m
0fo/NAHVrkgas5MuA0Tb5wR6KrJwvYrVF1JqKFjeswan+SfWsQ440R8xhnyNlUTN
DICgBACcth1uXuUo5rciL7kETZ2ge+aK64SpEJzwhBZFgPsrNjLOGmIP9O3A9eWR
fM/kghpBP0cBxryyojYTh9E+vqEsFFxPhNtqo7hMd7NDdHLqn4y1FbgbugpdZhpE
h/L93EZzj9qRFRL4a8hsouroBw5IeTdg8cDwl49SqP4BilzVqLREQWxhbiBFbGlh
c2VuIChodHRwOi8vZnV0dXJlYm95LmhvbWVpcC5uZXQvKSA8ZWxpYXNlbkBtaW5k
c3ByaW5nLmNvbT6IVwQTEQIAFwUCPRlebgULBwoDBAMVAwIDFgIBAheAAAoJEOSB
hLWwVnaxgnsAn1vhCRNK/4Qfb0OXfqy7JylWxWgbAJ42lrhz8XK5NOS7t29BDwem
0D+CfohFBBARAgAGBQI+I5z4AAoJEBQ6+k4y8bDkbEsAmOhZGZbyblTfYc//JyU/
5GJxYdAAnjU1x/LPJ5o3HPnM63rvFnBS7SW9iEYEEhECAAYFAj7BwZ0ACgkQnN+4
1NpzKvdfGQCeME6xs7y4NR19xsrGuOTC7KDIkwUAn0A8JZR4s/HhbegcqWuQKBP4
uo88iEYEExECAAYFAkR+J1YACgkQ370QvkqtFkw+OQCfdrYDIBU0qD40LTNfOIbz
pVb5jDYAnil88lTfVnriKsYUKHjhQ4uPWRPCuQENBD0ZXnEQBACrfxe432NVrvgV
Yjas8SWLGEfBUeMqrIytcfm7TP6YNRyyzUufL2lnFpaREkO/mLN61bMfQSrmzaR1
wk/KNnwWTIp9UdVVxLhfQWJpG2b1GlwlHVEwEG8Dw2lxinPU7mg1OkceyizPjeRV
hoxB9NCpV0L3aFb3+GQku4ZzMsDJBwAECwP+LVkqEJgPwz+AmhqveFVSbsy5yDBr
oP814XMbNaw3IILQaBPwPKHa3xmOB16pb2MIzy0m3Vxq2qOITs6LAeUvtRS9ERI1
hJSchncL6Kl1D6eplVuoU5lIA1jfYmjGHrVNUkyjoPU+dLb0BJZ2PGLGxH0DwWIY
gKaQz2CDCh/11WaIRgQYEQIABgUCPRlecQAKCRDkgYS1sFZ2sXzTAJ4ks2Z4eVtZ
vDZvz3jlgBYAQFBx0gCgmINosOaFJGJlTwsALWhJGmXls3k=
=MNy0
-----END PGP PUBLIC KEY BLOCK-----
</code></pre>

<p>文本文件可以从<a href="http://futureboy.us/pgp.txt">这里</a>下载。</p>

<p>###什么是公钥加密？</p>

<p>简单地说，公钥加密解决了一个古老的问题“在不与某人预先交换秘钥的条件下，如何与其进行安全的通信”，安全地交换共享秘钥是一个很难解决的问题。如果你的通信处于监听的情况下，你是无法保证交换的安全性。
有了公钥加密体系，通信的双方分别生成由公钥和“机密的”私钥组成的秘钥对，然后双方可以将各自的公钥发布到网上或直接发送给对方即可。
如果你有了用户B的公钥，那么你可以用它完成下面的工作：</p>

<ul>
<li>加密消息并且只能由B解密(B需要他的私钥来解密)</li>
<li>验证一个是否由B的私钥签名的消息，也可以用来验证消息在传输过程中的完整性和机密性。</li>
</ul>

<p>你可以用你的私钥做下面的事情：</p>

<ul>
<li>解密由你的公钥加密的消息</li>
<li>对消息进行签名以便别人来验证此消息是否出自你手(对方需要你的公钥来验证签名)</li>
</ul>

<p>###我的工具箱</p>

<p>我接收和发送的所有消息都使用的是OpenPGP格式(是一种开放的标准，最广泛使用的用于公共加密的标准)，因此通信可以在任何OpenPGPG兼容的程序间工作正常。</p>

<p>要对电子邮件进行加密和签名，可以使用下面的工具：</p>

<ul>
<li>GNU隐私卫士(GPG)</li>
<li>Thunderbird，mozilla的邮件客户端</li>
<li>Mozilla的Enigmail插件</li>
</ul>

<p>如果你使用的是Fedora，你可以直接从源中安装Enigmail插件，而不用到网上下载。以root用户运行下面命令：
yum install thunderbird-enigmail或者一次性安装所有的包：yum install gnupg thunderbird thunderbird-enigmail</p>

<p>在安装完或更新系统后，如果在Thunderbird菜单中找不到OpenPGP选项，先找到Tools | Add-ons，禁用Enigmail，重启Thunderbird，开启Enigmail，重启Thunderbird。</p>

<p>不足的是，Thunderbird版本飙得太快，导致Enigmail有时无法与系统兼容，这就是为什么用类似yum的包管理器来保证包的兼容性，另一个好处就是可以手动运行gpg命令。</p>

<p>首先我们要对Enigmail进行一番设置，打开OpenPGP | Preferences | Display Expert Settings。只进行基本设置是不够的。</p>

<p>在Enigmail中，过去我最喜欢设置默认密钥服务器为pgp.mit.edu，但是现在没太大的必要了，因为现在Enigmail包含一个密钥服务器列表，而且比它之前使用的更加稳定。</p>

<p>Gnu隐私卫士FAQ罗列了一些其它兼容GPG的email程序。注意，配合命令行下的gpg可执行程序，你可以使用任意e-mail程序（只要它不篡改消息）。</p>

<p>对于苹果机，你可以从GPGTools中获取GPG。（我个人没有使用过，但是别人推荐这个。）<br />
做为替换，有时候我在Emacs/XEmacs中使用pgg包，这个包是对个gpg功能的包装。你可以高亮一部分内容，执行: M-x pgg-encrypt-region直接加密文档。<br />
对于加密文件或者其它更有趣的事情，我只是在命令行中使用gpg程序。如果你是个安全偏执狂，那么更少的可执行程序，更好。</p>

<p>本文档的大部分内容就是教你使用gpg程序让你变得更安全，这是一件有趣而且重要的事情。</p>

<p>###gpg还是gpg2</p>

<p>GPG2的可执行文件名叫gpg2,两者都可以演示下面的例子，而且两个版本相互兼容。v1经受过了更多的测试，是庞大功能的集合体。v2使用了libgcryp之类的加密库进行编译的，可以与外部的密码工具良好的协作。从命令行中可以看出，我使用的是版本1。</p>

<p>###从Enigmail导入</p>

<p>从e-mail客户端（比如Enigmail）导入我的密钥最简单的方式是从密钥服务器导入。在Enigmail中，你可以使用OpenPGP | Key Management | Keyserver | Search for Keys搜索密钥，搜索的内容可以是我的名字、我的e-mail地址eliasen@mindspring.com、我的密钥ID E48184B5B05676B1或者是短ID B05676B1。然后从搜索结果中选择对应的复选框，点击“OK”。</p>

<p>从Enigmail中导入我的公钥更懒更危险的方式是直接尝试发给我一封加密的e-mail。（写邮件的时候，选择菜单项OpenPGP，同时勾选Sign Message和Encrypt message。）然后当你尝试发送的时候，Enigmail将会发现它没有我的公钥，接着就会出现密钥管理窗口。从这个窗口中，你可以选择Download Missing Keys。</p>

<p>另外还有一种导入的方式是将我的密钥的明文版本发送到你自己的邮箱，然后选择“Import PGP Key”。</p>

<p>###从GPG导入</p>

<p>如果你的e-mail客户端不允许你从e-mail消息中自动导入密钥，你需要将上述密钥的明文保存到一个文件中，然后手工导入密钥。对于GNU隐私卫士，执行：</p>

<pre><code>gpg --import [filename]
</code></pre>

<p>我的密钥从pgp.mit.edu中是可获得的（虽然所有主要的密钥服务器都会互相做镜像，所有你可能可以从任意的密钥服务器获得，但是这个密钥服务器可能更可靠。）</p>

<p>你可以从<a href="http://pgp.mit.edu">pgp.mit.edu</a>中浏览可获得的密钥，<a href="http://sks-keyservers.net">sks-keyservers.net</a>也可以，只是有时比较慢。你知道谁已经发布公钥了么？</p>

<p>使用GNU隐私卫士，你可以按照下述操作导入我的密钥（看起来更安全）</p>

<pre><code>gpg --keyserver pgp.mit.edu --search-keys eliasen@mindspring.com
</code></pre>

<p>注意在所有的例子中，无论何时你看到一个e-mail地址，你可以替换掉部分名字、部分地址或者部分密钥ID。大部分命令都可以进行子串搜索。</p>

<p>或者更直接一点儿，我的公钥ID是E48184B5B05676B1，（使用最后8个字符更平常，但是不安全，所以B05676B1也是可以的。读读下述关于 短密钥ID的技术说明 ，你会发现使用短ID有一个有趣的攻击）下述gpg命令将会从密钥服务器导入我的密钥。</p>

<pre><code>gpg --keyserver pgp.mit.edu --recv-keys E48184B5B05676B1 
</code></pre>

<p>继续读下去你会明白为什么仅仅从密钥服务器导入密钥并不能确定你正在跟我通信。</p>

<p>你可能不必在上述命令中指定一个密钥服务器。后续版本的GPG具有内建的更可靠的密钥服务器列表。</p>

<p><a href="http://sks-keyservers.net">sks-keyservers.net</a>实时监控密钥服务器的状态。如果你无法从某个密钥服务器导入签名或者想要一个可用密钥服务器的列表，那么就去这个网站看看。</p>

<p>###获得帮助</p>

<p>gpg &ndash;help是你最好的朋友。它会列出GPG最常用的选项，但不是全部。下面是其他的一些完备的文档：</p>

<ul>
<li><a href="http://www.gnupg.org/documentation/manuals.en.html">GPG Manual</a></li>
<li><a href="http://www.gnupg.org/documentation/manuals/gnupg/">Using the GNU Privacy Guard</a></li>
<li><a href="http://www.gnupg.org/gph/en/manual.html">The GNU Privacy Handbook</a></li>
</ul>

<p>###入门</p>

<p>这里的入门不会过于简单，因为这会让你误以为这些技能足以保护你的隐私了。然而最好的入门方式就是访问GNU Privacy Guard主页，阅读&rdquo;Guides&rdquo;小节的&rdquo;GNU Privacy Handbook&rdquo;(已有各种格式和语言的文档)部分。下面将会讲解如何设置GPG，包括如何创建自己的私钥。
运行下面的命令来创建私钥：</p>

<pre><code>gpg --gen-key
</code></pre>

<p>你可以选择使用默认项，因为它不会让key的长度超过允许的最大长度(当前最大长度为4096位)。key的长度越大，生成key的时间越长，加密、解密也会慢一些，但这也会给试图破解密信的恶意用户带来更高的时间开销。</p>

<p>###生成吊销秘钥</p>

<p>在生成完私钥后，首先要做的就是创建一个吊销证书：</p>

<pre><code>gpg --gen-revoke your@email.address
</code></pre>

<p>如果你的私钥丢失或被盗，可以用此证书来吊销公钥。不要忽视它的重要性。不管是打印出来还是存储到硬盘上，总之要好好地保存起来。
如果私钥丢失或被盗，可以将吊销证书上传到公共keyserver上来吊销你的公钥，前提是你已经将你的公钥上传到keyserver上了。
如果让我看到你有多个未吊销的公钥并且说“私钥丢失，使用新的公钥来替换其他的公钥”(这话是从一个所谓具有保密经验的人口中说出的)之类的话，那么我会立马否决你，不会信任你，因为你没有遵循最佳实践，没能管理好你的机密信息。因此保护好吊销证书和保护好私钥一样的重要。请继续往下读，看看为什么当你看到“this key is my new key, ignore the others”这句话时就应立即想到这个人要么对加密不熟悉要么他就是假冒的。</p>

<p>###验证过程</p>

<p>既然你已经得到了我的公钥，那么我们之间的通信就安全了吗？不，一点也不。许多人在刚开始接触密码系统时并没有意识到要去验证这个公钥是否真的属于我。以我，Alan Eliasen,为例，如果某人写了这篇文章，你怎样验证文章中的公钥就是我的呢？毕竟，心怀叵测的人可以将此文转载并修改公钥。</p>

<p>听好了，下面的东西很重要。任何人都可以用任意的邮件地址来生成一个公钥，任何人都可以将公钥上传到任意的keyserver上。 只有验证了某个key确实属于那个人的时候 才能保证通信的安全。如果不进行严格的验证，那么密码学软件所做的只是确保消息在传输过程中的完整性和机密性。但这并不意味着你正与你想要交谈的人进行交谈。你可能正与另外一个人(坏人)交谈或遭受中间人攻击。</p>

<p>然而，如果你仅仅想要给我发一封加密邮件，防止他人窥探其中，那么你只需要用我的公钥加密即可。但你要知道我有理由不信任你所宣称的身份，在验证我的公钥前你也可以不信任我所宣称的身份。因此在我与你进行秘密交流前，我要验明你的身份。</p>

<p>###指纹</p>

<p>一个密钥可以通过多种途径来验证（例如，我可以把我的完整的公钥读给你，这真的很耗费时间，而且很容易出错。除此之外，这样做不好还因为你在前面看到的密钥可能随着其他人签授而变得越来越长。）通常的选择是将你认为的我的公钥的指纹，与我所知道的我的公钥的指纹，进行比较。
一个指纹是一段更短的数字（通常使用十六进制数字表示），它包含一个对于我的公钥进行了高度加密的摘要。它比我的完整密钥短，因此这并不是一个不可利用的尝试，而且找到另一个有同样指纹的密钥的可能性确实很小。无限的小。小到你不需要担心它。如果其他人能够找到一个匹配的指纹，他们就有足够的能力和财力可以让你从地球表面消失。因此，在你导入了我的密钥之后，键入：</p>

<pre><code>gpg --fingerprint eliasen@mindspring.com
</code></pre>

<p>之后，你需要与我认证这个指纹。最好面对面的做这件事，但是如果是你通过声音认识的人，你可以通过电话做这件事。如果你不认识这个人，检查他们的驾驶证。问问其他人（你信任的人）谁知道他们。即使你不认识他们，至少你可以确认密钥属于正在和你交谈的那个人。</p>

<p>###我的密钥验证协议</p>

<p>如果你想验证上述密钥，请联系我，我会在某个公开的约会场所验证它的指纹。我将会穿着一套风衣和海军蓝领带。你必须穿着或戴着黄色郁金香。任何别的花表示联系取消，即使下述交互正确进行。我不能低估充足的黄色郁金香存量对这次联系的重要性。</p>

<p>我将会说“天王盖地虎。”</p>

<p>你必须回答“宝塔镇河妖。”</p>

<p>如果我对你的回答满意，我将回应“好叭哒。”</p>

<p>不要做眼神交流或者显示出认识的样子。如果必要，我将会假装在手机上订购书籍，同时读出指纹的十六进制数字。</p>

<p>好吧，这部分我有点儿开玩笑了。但是你必须同别人验证密钥才能确保真正的安全。</p>

<p>如果你已经验证了我的密钥，那么就相信我（相信你自己的判断）一定签了名。</p>

<p>###签名密钥</p>

<p>既然你已经验证了我的身份和公钥，那么你需要告诉你的加密软件你信任我的密钥。否则你的加密软件应当做正确的事情，并警告你你正在与没有经过确认的某个人通信。这正告诉你没有任何理由相信你正在使用的密钥是它应该属于的哪个人的密钥。 下面是GPG和Enigmail使用签名密钥和信任密钥的建议。</p>

<p>###Enigmail的签名密钥</p>

<p>我有些许谨慎地推荐使用Enigmal来签名密钥，因为Enigmail的某些对话框是欺骗人的并且是错误的。请非常仔细地阅读下一部分。<br />
在Enigmail里，你可以进入菜单项OpenPGP|密钥管理来签名密钥。<br />
搜寻密钥，然后右击密钥，你将看到签名密钥的选项。</p>

<p>签名密钥之后，你应当给签名密钥的这个人赋予信任级别。右击密钥名，选择“设置拥有者信任级别”。警告：这时弹出一个对话框，询问“你信任这个密钥程度？”，不过这不是正确的问题！GPG软件的信任意思是你信任这个人去验证其他人的密钥的程度，而不是你信任这个密钥的程度！在GPG里，问题陈述如下：</p>

<p><code>&quot;请确定你信任这个用户（通过查看护照，检查不同来源的指纹等）正确地验证其他用户的密钥的程度“</code></p>

<p>正如你所看到的，这是完全不同的问题。这就是我鼓励你通过在命令行上使用GPG去学习的原因。它更加严密和正确。另外GPG给你更多有关像“无限制的信任”这样危险选择的告警。阅读下一节会明白更多</p>

<p>###GPG的签名密钥</p>

<p>要从gpg签名我的密钥，你将做以下事情：</p>

<pre><code>gpg --sign-key eliasen@mindspring.com 
</code></pre>

<p>(不过，下面将看到更好的选项。）
这儿将给出你签名密钥的一些选项。更好的选项是编辑你的签名并且使用交互式菜单信任这个用户的设置：
    gpg &ndash;interactive &ndash;edit-key eliasen@mindspring.com</p>

<p>提示：在交互式命令行里键入&rdquo;help&rdquo;。命令“sign&rdquo;和&rdquo;trust&rdquo;是你正在查找的哪个命令。这既允许你可签名密钥也表明你信任我验证其他人密钥的程度。当验证和签名其他人的密钥的时候如果你认为我愚蠢且懒散，那么你将赋予我低的信任级别。
在你签名了某些人的密钥后，你应当把签名的密钥回送给他们，这样他们能向其他人展示你已经对它进行了签名。
你可以使用下面的命令导出他们的密钥：</p>

<pre><code>gpg --export -armor their@email.address 
</code></pre>

<p>然后把输出发送给他们。接着他们可以使用下面命令导入这些变化：</p>

<pre><code>gpg --import 
</code></pre>

<p>你还可以上传这些签名到密钥服务器，这让签名可在全世界使用。要知道如何做到这些，请参阅发布你的公共密钥一节。
如果你不能真正的确认为我的身份，而且不打算公开地替我保证，那么你将本地签名我的密钥，这意味着你只是自己信任这个密钥：</p>

<pre><code>gpg --lsign-key eliasen@mindspring.com 
</code></pre>

<p>提示：如果你在没有同我验证密钥的情况下公开地签名我的密钥，那么我将给你赋予非常低的信任级别。</p>

<p>###发布你的公钥</p>

<p>当然，你可以手动把你的公钥发送给你想要联系的人，但是假如需要安全与你通信，而你并没有把公钥发送给他们该怎么办呢？通常的办法是你把你的公钥发送到一台密钥服务器上，那么任何人都可以导入你的密钥。世界上大多数的密钥服务器相互镜像，所以你在其中一台服务器上发布你的密钥后很短的时间内，密钥就会被传送到其他服务器上。就像我前面说的，在过去的十年里使用pgp.mit.edu 发布公钥一直都很给力。</p>

<p>尽管如此，在你发布你的公钥（或者别人的公钥）到密钥服务器之前你还是需要负起责任。正如在 入门 和 验证过程 章节里提到的一样，你最好为你的密钥生成一份吊销证书然后把它放在一个非常安全的地方保存。否则的话，一旦你弄丢了你的密钥，或者密钥失效，对应的公钥将会永久残留在公钥服务器上，那就好像是在嘲笑并证实你并不清楚该如何有效地保护你的机密。假如你认为可以不用吊销公钥，能从密钥服务器上删除的话，去读一下这篇文章 FAQ at MIT&rsquo;s keyserver.（我认为有意思的是他们网站上有一个冒牌的 “删除密钥” 功能，不管你输入什么样的密钥，都会重定向到FAQ页面。）</p>

<p>假如某些人持有你的公钥，他们主要可以用它来搞定下面几个操作：</p>

<ul>
<li>加密一些只有你可以解密的信息。</li>
<li>验证时有力地保证这些信息是由你的密钥签名的，并且可以确保这些信息在传输过程中没有受到篡改或破坏。</li>
</ul>

<p>###手动导出和上传</p>

<p>既然你已经生成了加密密钥和公钥，那么人们如何找到可发送加密的电子邮件给你得公钥呢？你可以通过把加密密钥放在电子邮件里直接发送给某人。为了生成易于发送电子邮件的公钥的拷贝，你可以这么做：
gpg &ndash;armor &ndash;export your@email.address
这将生成适宜于发送电子邮件的你公钥的非常漂亮格式的&rdquo;ASCII封装“版本。”ASCII封装“是一种把原始的二进制数据（如果你试图通过大多数电子邮件程序发送这样的密钥的话，可能使密钥损坏）转换为仅仅限制使用ASCII字符、换行、正确的文件头并适合于电子邮件的格式。（提示：这似乎看起来像这个页面最顶端的我的公钥。）
注意开始行<br />
&mdash;&ndash;BEGIN PGP PUBLIC KEY BLOCK&mdash;-<br />
和结束行<br />
&mdash;&ndash;END PGP PUBLIC KEY BLOCK&mdash;-<br />
是这样的信息必不可少的一部分。不要忘记把它们包含进来。
一旦你拥有了ASCII封装的公钥的话，你就可以手动的粘贴公钥到像pgp.mit.edu这样的公钥服务器的表格里。
再强调一遍，仅仅因为某些人好像给你已经发送他们的公钥，就没有理由信任公钥是来自于它所属于的哪个人的，除非你已经使用上面验证过程一节里的指令同他们进行了密钥验证。确定在信任他们之前验证了任一个密钥。</p>

<p>这些都很有利。你想要别人获得你的公钥。那么下面就是一些把你的公钥发布到你的密钥服务器的方法。异曲同工。</p>

<p>###使用GPG上传公钥</p>

<p>发布密钥到密钥服务器的一种方式是前一节的手动方式：导出ASCII封装的密钥，然后手工的把它粘贴到像pgp.mit.edu的表格里。
另一种方式是让pgp程序上传密钥。你通过指定电子邮件地址无法完成上传；你需要指定公钥的十六进制ID号码。那么你如何找到你打算上传的密钥的十六进制ID号码呢？</p>

<pre><code>gpg --list-keys your@email.address
pub 1024D/B05676B1 2002-06-26
uid Alan Eliasen (http://futureboy.homeip.net/) &lt;eliasen@mindspring.com&gt;
sub 1024g/70AC29FB 2002-06-26
</code></pre>

<p>在上面的结果里公钥ID显示在pub所在的行并且包含了8个字符的十六进制码（上例子中的B05676B1）。你需要知道要上传到服务器的是这个码。</p>

<pre><code>gpg --send-keys keyID
gpg: sending key B05676B1 to hkp server subkey.pgp.net
</code></pre>

<p>如果及打算指定一个密钥服务器的话，你可能需要指定 &ndash;keyserver pgp.mit.edu作为上面命令的选项。另外，大多数密钥服务器彼此互作镜像，不过要把这些密钥传送到所有服务器是要花时间的。
注意在你给别的某些人的公钥签了名后，就表明你已经验证了他们的密钥和身份，并且保证密钥是属于他们的。你可以使用同样的过程上传他们公钥的以签名版本到密钥服务器上，这样人们就能看到你提他们做了保证。更多有关这方面的习性你请参阅下面的 构建可信任网络一节。</p>

<p>###通过Enigmail上传公钥</p>

<p>在Enigmail中，任何与key相关的操作都是通过菜单项OpenPGP | Key Mangement来完成的。只需找到想要上传的key，然后右键单击就会弹出上传选项。这真是在简单不过了。但你仍需要仔细地负责任地签署他人的key。</p>

<p>###手动解密</p>

<p>当收到一个加密的文件或消息时，如果没有一个好的插件来帮助解密的话，那么我们怎样才能手动解密呢？很简单，只要在命令行中运行gpg，就会提示我们输入密文：</p>

<pre><code>gpg
gpg：Go ahead and type your message ...
</code></pre>

<p>从上可以看出，我们只需把密文复制黏贴进来，就可以解密了或者会导入key以及其他一些与密信相关的信息。黏贴完后，需要向系统发出“end-of-line&rdquo;字符，类Unix系统是Ctrl+D，Windows系统是Ctrl+Z。</p>

<p>如果加密的数据是在一个文件里，那么你只是把文件名传给命令行的gpg就可以自动的处理这个文件了。
gpg myfilename
gpg通常只是对这个文件作正确的事情，在需要的时候提示你输入密码，保存输出文件等等。
警告：当gpg加密或者解密文件的时候，它通常保持原文件原样不变！你自己必须记住要删除原始文件，可能的话请安全删除。在Linux里你可以使用 shred -u（shred默认情形下仅仅是覆盖；要覆盖之后再删除这个文件的话，-u就是必须的）或者wipe命令安全地删除。在Windows里， sdelete可以很好的删除原文件。（虽然由于固态硬盘或者优盘外加了级别算法，安全删除不能确保可它们之上正常运行。不过如果你使用了固态硬盘或者优盘，而且打算安全的删除，那么你必须使用类似于wipe或者sdelete这样的工具改写所有空闲空间）不过不要相信需要做很多次覆盖的大量的宣传。 这非常可能是都市传闻或者市场谎言。一次覆盖就可能足够了。</p>

<p>###手动加密</p>

<p>####加密邮件</p>

<p>如果手头上没有一个好的插件来帮助加密消息时，命令行也可以轻松地完成这个任务。你需要将消息保存到一个文件中并运行下列命令。</p>

<pre><code>gpg --encrypt --sign --armor -r recipient@email -r your@email.com filename
</code></pre>

<p>命令行中有几个比较重要的选项：</p>

<ul>
<li>&ndash;encrypt告诉gpg使用公钥加密消息</li>
<li>&ndash;sign用于添加数字签名，以保证这个消息确实是由你发出的，而且也能保证消息在传输过程中没有损坏或修改。理论上，这个选项是可选的，但是请查看下面的“签名消息”小节以了解此选项的重要性。</li>
<li>&ndash;armor选项会将结果以ASCII字符形式明文输出。ASCII封装(ASCII armor)会将原生二进制数据转换为仅包含ASCII字符、换行符和相应的头信息的适合在邮件中传输的格式。如果想把加密的消息黏贴到邮件body中或发表在论坛的帖子中，这个选项是必须的。</li>
<li>-r recipient 选项用于指定消息的接收者，可以同时指定多个接收者但必须要导入接收人的公钥。若在命令中未指定接收者，那么会进入交互模式提示你输入，接收者可以用公钥ID来指代。</li>
</ul>

<p><strong>注意，下面的东西很重要也很有趣！</strong> 大家可能已经注意到上面的例子中，我们自己的邮件地址被指定为接收人之一。这是因为如果没有显示地将自己的地址添加到接收人列表中的话，自己也无法解密消息！ 即使此消息是由你亲自编写、加密的，你也无法解密。很酷吧。请阅读下面的“为什么公钥加密是很酷的”小节来了解其中的奥妙。</p>

<p>filename选项指定要加密的文件。这个选项不是必须的，但如果没有指定文件名的话，GPG会继续等待输入内容，然后我们就可以直接键入消息了或者也可以将消息复制黏贴进来，但这种方法比较笨拙。当黏贴完消息后，我们需要向系统发出&rdquo;end-of-line&rdquo;字符，类Unix系统上是Ctrl+D，Windows系统是Ctrl+Z。
注意：我再重复一遍，使用gpg加密、解密文件时，会保留原文件！出于安全考虑，必须要记得删除原文件。请看上面的注意部分来了解如何操作。</p>

<p>####加密文件</p>

<p>GPG不只是用来加密邮件哦！还可以用来保护敏感文件。加密文件和加密邮件方法一样，只需执行下面的命令即可：</p>

<pre><code>gpg --encrypt filename
</code></pre>

<p>执行后会提示输入接收人的邮件地址(最好把自己的地址也添加进去以便自己可以解密)。
更完整的命令如下：</p>

<pre><code>gpg --encrypt --sign -r your@email.com filename
</code></pre>

<p>这里需要注意的选项如下：</p>

<ul>
<li>&ndash;encrypt选项让gpg使用公钥来加密消息。(请看下面的&rdquo;对称加密/解密&rdquo;小节来了解使用密码而不是公钥加密文件)</li>
<li>&ndash;sign用于添加数字签名，以保证文件确实是由你创建的且在传输过程中没有被破坏或修改。理论上这个选项是可选的，但也非常重要。你想啊，要是某人用另一个加密文件将你的文件替换掉了怎么办？通过数字签名就可以极大地保证你就是加密文件的创建者并且文件在传输过程中没有被修改或破坏。请看下面的“签名消息”小节以了解更多关于数字签名的知识。</li>
<li>&ndash;armor选项(可选，非必须)将结果以ASCII字符进行明文输出。“ASCII封装(ASCII Armor)”是一种将原生二进制格式(在邮件中发送可能会被破坏)转换为只用ASCII字符、换行符以及相应的头信息表示的适合用邮件传播的格式。如果想把加密的消息黏贴到邮件body中或发表在论坛的帖子中，这个选项是必须的。注意，这个选项也会增加文件的大小。</li>
<li>&ndash;output filename(可选)用于指定输出文件名。</li>
<li>-r recipient用于指定接收人，可以多个，但你必须已经导入了这些人的公钥。通过使用多个-r选项就可以指定多个接收人。若没有指定接收者，gpg会进入交互模式提示你输入。接收人可以用公钥ID来指代。</li>
</ul>

<p><strong>注意!下面的内容很重要！</strong>大家可能已经注意到上面的例子中，我们自己的邮件地址被指定为接收人之一。这是因为如果没有显示地将自己的地址添加到接收人列表中的话，自己也无法解密消息！ 即使此消息是由你亲自编写、加密的，你也无法解密。很酷吧。请阅读下面的“为什么公钥加密是很酷的”小节来了解其中的奥妙。</p>

<ul>
<li>filename选项指定要加密的文件。这个选项不是必须的，但如果没有指定文件名的话，GPG会继续等待输入内容，然后我们就可以直接键入消息了或者也可以将消息复制黏贴进来，但这种方法比较笨拙。当黏贴完消息 后，我们需要向系统发出&rdquo;end-of-line&rdquo;字符，类Unix系统上是Ctrl+D，Windows系统是Ctrl+Z。</li>
<li><strong>注意：</strong> 我再重复一遍，使用gpg加密、解密文件时，会保留原文件！出于安全考虑，必须要记得删除原文件。请看上面的注意部分来了解如何操作。</li>
</ul>

<p>####为消息签名</p>

<p>除了加密外，gpg还能用来对消息进行数字签名，有诸多好处：
* 能确保消息在传输过程中未被破坏或修改
* 允许他人验证消息是由你的私钥签署的</p>

<p>你应该总是为加密的消息进行签名。你想啊，每个人都能获取到你的公钥，都能用这个公钥加密消息发送给你，从而伪装成你认识的某个人(邮件地址很容易伪造，但这是另一个话题了)。因此只有当你(通过数字签名)验证了这个消息确实是由你认识的那个人签名的，你才能确信通信是安全的。</p>

<p>因此，你不应该信任任何未签名的加密通信。因为，任何想要冒充你朋友的人，都会故意“忘记”对消息进行签名。</p>

<p>一个经过签名的消息在数学理论上几乎可以完全确定消息就是由你签署的。<br />
在邮件客户端中，要总是记得选择签署并加密消息。下面是手动签名消息的方法。</p>

<p>####对明文进行签名</p>

<p>有时我们仅仅想给一个不需加密的消息进行签名，只是让他人确信这个消息确实是出自你手，并且在传输过程中完整无损。其他适用的场景如下：</p>

<ul>
<li>进行一个重要的表决</li>
<li>商业间重要的通信</li>
<li>如果发送的邮件中有可疑的URL，那接收人就会验证消息是否来自于你还是来自垃圾邮件</li>
<li>来确认消息在传输过程中的完整性</li>
<li>允许接收人验证消息确实来自于你并且未被修改。例如，学校会对成绩单进行签名以保证数据未经篡改(研究机构应该经常对消息签名！)</li>
</ul>

<p>使用&ndash;clearsign选项可以将消息封装到ASCII格式的签名中，但不会修改消息的主体内容。此举可以让不会使用gpg的用户顺利读出消息的内容，也能让gpg用户验证消息确实是你写的并且没有被修改。命令如下：</p>

<pre><code>gpg --clearsign filename
</code></pre>

<p>输出</p>

<pre><code>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1


I vote YES on this important measure.

Alan Eliasen
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.13 (GNU/Linux)

iEYEARECAAYFAlHZCvgACgkQ5IGEtbBWdrF5HgCfc4xhT29ouAWdo1PMlyDKIfaq
pGoAoKig5sCXukrPPoKC1ZYB5CW7BzNL
=WPPL
-----END PGP SIGNATURE----- 
</code></pre>

<p>验证过你的公钥的人可以通过将上面的输出传入gpg中就可以验明身份了：</p>

<pre><code>gpg --verify vote.txt.asc
</code></pre>

<p>输出</p>

<pre><code>gpg: Signature made Sun 07 Jul 2013 12:30:16 AM MDT using DSA key ID B05676B1
gpg: Good signature from &quot;Alan Eliasen (http://futureboy.homeip.net/) &lt;eliasen@mindspring.com&gt;&quot; 
</code></pre>

<p>如果他们没有验证并签署你的公钥，那么gpg警告公钥是不受信任的。这只能保证消息在传输中未经破坏但无法确定消息是谁写的！</p>

<p>####分离的签名</p>

<p>有时我们想对一个文件进行签名但又不想使用&ndash;clearsign选项来改变文件的内容，这是因为他人可能需要对文件进行再编辑或使用gpg才能读出内容，比较麻烦。</p>

<p>例如，你要将某个可执行文件发送给某人，对其签名的话就会损坏文件，而且人们一看到可执行文件就会感到恐惧与危险。那怎样才能保证文件不被修改还能确保它确实是由你发出的呢？通过分离的签名就可以实现了，分离的签名就是一个单独的文件，只包含了对某个文件的签名，通过使用-detach-sign选项就可以完成这个工作：</p>

<pre><code>gpg --detach-sign filename
</code></pre>

<p>之后就可以将签名与原文件一起发送了。接收人可以通过&ndash;verify选项验证文件没有被修改:</p>

<pre><code>gpg --verify filename.sig
gpg: Signature made Sun 07 Jul 2013 02:31:05 AM MDT using DSA key ID B05676B1
gpg: Good signature from &quot;Alan Eliasen (http://futureboy.homeip.net/) &lt;eliasen@mindspring.com&gt;&quot; 
</code></pre>

<p>####证明是你书写的，不过要临时保持匿名</p>

<p>比如说你发现一个大型公司（我们称它为Mapple）写了一个真正蹩脚的不称职不安全的Web站点，这个站点泄露了大量他们用户的信息，使得任何人在数字后加个1就可以随便访问这些信息。
现在，你不能确定是否是公司了不起而且诚实，并因你指出了他们的安全漏洞并且帮助他们保护客户信息而支付给你非常可观的漏洞奖金，还是他们是精神有病的匪徒，他们事后声明他们试图发布在没有任何权限控制的公共服务器上的你能访问的信息是“未经授权的”，并且控告你违反了编写的非常不称职的而且过时的计算机欺诈和滥用法（ CFAA）。
因此，你如何匿名地报告这个呢？ 好，一种非常强有力的方法是创建一个没有你名字的新的密钥对，发布你的公钥，接着使用对应的私钥对所有这些信息签名。这要求你要做以下几件事：</p>

<ul>
<li>你能够证明所有用同一个密钥签名的后续信息是来自于同一个人，甚至在你使用不同的电子邮件地址或者通信通道的情形下也如此。</li>
<li>如果他们决定诚实并为你为他们的服务提供奖金的话，你可以在将来证明你就是签名这些信息所用的对应私钥的所有人，例如，通过 解密用你的公钥加密的发送给你的东西。没有其他人在没有验证他们拥有对应的私钥的情形下能够错误地宣布他们是提交人。</li>
<li>如果他们对这件事就是作恶的话，那么你可以对他们保持匿名。如果你打算向其他人证明你揭露了这漏洞的话，那么你能通过使用同 一个公钥签名信息或者解密用你的私钥加密的发送给你的信息。</li>
</ul>

<p>（这是撕一张美元钞票为两半，并把一半送给某人的老技巧的数学化超强版本。如果他们打算验证你的身份，那么只要你拿出这张钞票的另一半就行。具有不同的撕裂模式并匹配序列号的一张美元钞票是很难伪造的。）</p>

<p>###更新密钥</p>

<p>人们由于多种原因经常更新密钥：</p>

<ul>
<li>密钥泄露或者丢失了，并且已经废止。</li>
<li>为了构建一个可信的网络，密钥被太多的人用来签名.</li>
</ul>

<p>更新密钥需要发布到公共的密钥服务器上，包括发布新的签名。你可以使用下面命令定期地更新你的密钥</p>

<pre><code>gpg --refresh-keys
</code></pre>

<p>这可以让你确保你正在使用的密钥不会被取消。</p>

<blockquote>
<p>本文中的所有译文仅用于学习和交流目的，转载请务必注明文章译者、出处、和本文链接
我们的翻译工作遵照 <a href="http://zh.wikipedia.org/wiki/Wikipedia:CC">CC协议</a>，如果我们的工作有侵犯到您的权益，请及时联系我们</p>
</blockquote>

</article>
    </article>
    <footer>
      Copyright &copy; 2014 Rojazz1999 &#8226; <a href='https://plus.google.com/u/0/101202661005324839860?rel=author' rel='me'>Google+</a> &#8226; Hosted by <a href='http://github.com/prisoner/prisoner.github.com/' target='_blank'>GitHub</a> &#8226; powered by <a href='https://github.com/wendal/gor'>gor</a>
    </footer>
    
<script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>
<script>
  var pres = document.getElementsByTagName("pre");
  for (var i=0; i < pres.length; ++i) {
    pres[i].className = "prettyprint linenums";
  }
  prettyPrint();
</script>

  </body>
</html>
