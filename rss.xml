<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>CODE4FUN</title>
    <link>http://prisoner.github.io</link>
    <pubDate>19 Sep 14 23:00 CST</pubDate>
    <item>
      <title>云主机价格比较</title>
      <link>http://prisoner.github.io/2014/09/19/%E4%BA%91%E4%B8%BB%E6%9C%BA%E4%BB%B7%E6%A0%BC%E6%AF%94%E8%BE%83.html</link>
      <pubDate>2014-09-19 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;云主机价格&#34; href=&#34;#云主机价格&#34;&gt;&lt;/a&gt;云主机价格&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;计费单位为元每月, 使用各服务商官方提供的计算器计算&lt;/p&gt;&#xA;&#xA;&lt;p&gt;价格基于以下配置&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;&lt;th align=&#34;left&#34;&gt;内存&lt;/th&gt;&lt;th&gt;系统盘&lt;/th&gt;&lt;th&gt;数据盘&lt;/th&gt;&lt;th&gt;线路&lt;/th&gt;&lt;th&gt;带宽&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;1核&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;2G&lt;/td&gt;&lt;td&gt;20G&lt;/td&gt;&lt;td&gt;100G&lt;/td&gt;&lt;td&gt;双线&lt;/td&gt;&lt;td&gt;2Mbps&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;[ucloud](http://www.ucloud.cn/)&#34; href=&#34;#[ucloud](http://www.ucloud.cn/)&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://www.ucloud.cn/&#34;&gt;UCloud&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;&lt;th align=&#34;left&#34;&gt;内存&lt;/th&gt;&lt;th&gt;系统盘&lt;/th&gt;&lt;th&gt;数据盘&lt;/th&gt;&lt;th&gt;线路&lt;/th&gt;&lt;th&gt;带宽&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;1核&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;2G&lt;/td&gt;&lt;td&gt;20G&lt;/td&gt;&lt;td&gt;100G&lt;/td&gt;&lt;td&gt;双线&lt;/td&gt;&lt;td&gt;2Mbps&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;价格: 162元&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;[青云](https://www.qingcloud.com/)&#34; href=&#34;#[青云](https://www.qingcloud.com/)&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://www.qingcloud.com/&#34;&gt;青云&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;&lt;th align=&#34;left&#34;&gt;内存&lt;/th&gt;&lt;th&gt;系统盘&lt;/th&gt;&lt;th&gt;数据盘&lt;/th&gt;&lt;th&gt;线路&lt;/th&gt;&lt;th&gt;带宽&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;1核&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;2G&lt;/td&gt;&lt;td&gt;20G&lt;/td&gt;&lt;td&gt;100G&lt;/td&gt;&lt;td&gt;未知&lt;/td&gt;&lt;td&gt;2Mbps&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;价格: 251.28元&lt;/p&gt;&#xA;&#xA;&lt;p&gt;按小时计费:&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;&lt;th align=&#34;left&#34;&gt;内存&lt;/th&gt;&lt;th&gt;系统盘&lt;/th&gt;&lt;th&gt;数据盘&lt;/th&gt;&lt;th&gt;线路&lt;/th&gt;&lt;th&gt;带宽&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;1核&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;2G&lt;/td&gt;&lt;td&gt;20G&lt;/td&gt;&lt;td&gt;100G&lt;/td&gt;&lt;td&gt;双线&lt;/td&gt;&lt;td&gt;2Mbps&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;0.225元&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;0.064元&lt;/td&gt;&lt;td&gt;未知&lt;/td&gt;&lt;td&gt;0.06元&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;[阿里云](http://www.aliyun.com/)&#34; href=&#34;#[阿里云](http://www.aliyun.com/)&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://www.aliyun.com/&#34;&gt;阿里云&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;&lt;th align=&#34;left&#34;&gt;内存&lt;/th&gt;&lt;th&gt;系统盘&lt;/th&gt;&lt;th&gt;数据盘&lt;/th&gt;&lt;th&gt;线路&lt;/th&gt;&lt;th&gt;带宽&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;1核&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;2G&lt;/td&gt;&lt;td&gt;20G&lt;/td&gt;&lt;td&gt;100G&lt;/td&gt;&lt;td&gt;未知&lt;/td&gt;&lt;td&gt;2Mbps&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;价格: 178元&lt;/p&gt;&#xA;&#xA;&lt;p&gt;按小时计费:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww2.sinaimg.cn/large/8bc73676gw1eki4gmzmelj20j40g2dir.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&#xA;&lt;img src=&#34;http://ww2.sinaimg.cn/mw1024/8bc73676gw1eki4gm9ixyj20gs03jt8z.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;[盛大云](http://www.grandcloud.cn/)&#34; href=&#34;#[盛大云](http://www.grandcloud.cn/)&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://www.grandcloud.cn/&#34;&gt;盛大云&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;&lt;th align=&#34;left&#34;&gt;内存&lt;/th&gt;&lt;th&gt;系统盘&lt;/th&gt;&lt;th&gt;数据盘&lt;/th&gt;&lt;th&gt;线路&lt;/th&gt;&lt;th&gt;带宽&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;1核&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;2G&lt;/td&gt;&lt;td&gt;15G&lt;/td&gt;&lt;td&gt;100G&lt;/td&gt;&lt;td&gt;未知&lt;/td&gt;&lt;td&gt;2Mbps&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;价格: 458元(非优惠价格)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;详细计费:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/mw1024/8bc73676gw1eki4t1p92nj20j20bh40f.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww2.sinaimg.cn/mw1024/8bc73676gw1eki4t0wu07j20j30dajta.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;[天翼云](http://www.ctyun.cn/)&#34; href=&#34;#[天翼云](http://www.ctyun.cn/)&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://www.ctyun.cn/&#34;&gt;天翼云&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;&lt;th align=&#34;left&#34;&gt;内存&lt;/th&gt;&lt;th&gt;系统盘&lt;/th&gt;&lt;th&gt;数据盘&lt;/th&gt;&lt;th&gt;线路&lt;/th&gt;&lt;th&gt;带宽&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;1核&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;2G&lt;/td&gt;&lt;td&gt;50G&lt;/td&gt;&lt;td&gt;0G&lt;/td&gt;&lt;td&gt;未知&lt;/td&gt;&lt;td&gt;2Mbps&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;价格: 143.9元&lt;/p&gt;&#xA;&#xA;&lt;p&gt;没有硬盘服务, 使用&lt;a href=&#34;http://www.ctyun.cn/product/oos&#34;&gt;对象存储&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;价格:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;存储: 0.022元/G/天&lt;/p&gt;&#xA;&#xA;&lt;p&gt;流量: 流出流量0.55元/GB, GET/HEAD请求    0.01元/万次, 其他请求  0.01元/千次&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;[华为云](http://www.hwclouds.com/)&#34; href=&#34;#[华为云](http://www.hwclouds.com/)&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://www.hwclouds.com/&#34;&gt;华为云&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;&lt;th align=&#34;left&#34;&gt;内存&lt;/th&gt;&lt;th&gt;系统盘&lt;/th&gt;&lt;th&gt;数据盘&lt;/th&gt;&lt;th&gt;线路&lt;/th&gt;&lt;th&gt;带宽&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;1核&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;2G&lt;/td&gt;&lt;td&gt;20G&lt;/td&gt;&lt;td&gt;100G&lt;/td&gt;&lt;td&gt;双线&lt;/td&gt;&lt;td&gt;2Mbps&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;价格: 306 元/月 ，3060 元/年 ，0.52 元/小时&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;[verycloud](https://www.verycloud.cn/)&#34; href=&#34;#[verycloud](https://www.verycloud.cn/)&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://www.verycloud.cn/&#34;&gt;verycloud&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;&lt;th align=&#34;left&#34;&gt;内存&lt;/th&gt;&lt;th&gt;系统盘&lt;/th&gt;&lt;th&gt;数据盘&lt;/th&gt;&lt;th&gt;线路&lt;/th&gt;&lt;th&gt;带宽&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;1核&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;2G&lt;/td&gt;&lt;td&gt;20G&lt;/td&gt;&lt;td&gt;100G&lt;/td&gt;&lt;td&gt;双线&lt;/td&gt;&lt;td&gt;2Mbps&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;价格: 248.055元/月 ，2980.152元/年 ，0.348元/小时&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;[美橙](http://www.cndns.com/)&#34; href=&#34;#[美橙](http://www.cndns.com/)&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://www.cndns.com/&#34;&gt;美橙&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;&lt;th align=&#34;left&#34;&gt;内存&lt;/th&gt;&lt;th&gt;系统盘&lt;/th&gt;&lt;th&gt;数据盘&lt;/th&gt;&lt;th&gt;线路&lt;/th&gt;&lt;th&gt;带宽&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;2核&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;2G&lt;/td&gt;&lt;td&gt;40G&lt;/td&gt;&lt;td&gt;100G&lt;/td&gt;&lt;td&gt;双线&lt;/td&gt;&lt;td&gt;2Mbps&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;价格: 600元/月 ，6000元/年&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;[linkcloud](http://www.linkcloud.cn/)&#34; href=&#34;#[linkcloud](http://www.linkcloud.cn/)&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://www.linkcloud.cn/&#34;&gt;LinkCloud&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;&lt;th align=&#34;left&#34;&gt;内存&lt;/th&gt;&lt;th&gt;系统盘&lt;/th&gt;&lt;th&gt;数据盘&lt;/th&gt;&lt;th&gt;线路&lt;/th&gt;&lt;th&gt;带宽&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;2核&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;2G&lt;/td&gt;&lt;td&gt;40G&lt;/td&gt;&lt;td&gt;100G&lt;/td&gt;&lt;td&gt;电信+网通&lt;/td&gt;&lt;td&gt;2Mbps&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;价格:235.6元/月 ，2356元/年&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;[云端互通](http://www.idcloud.com.cn/)&#34; href=&#34;#[云端互通](http://www.idcloud.com.cn/)&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://www.idcloud.com.cn/&#34;&gt;云端互通&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;&lt;th align=&#34;left&#34;&gt;内存&lt;/th&gt;&lt;th&gt;系统盘&lt;/th&gt;&lt;th&gt;数据盘&lt;/th&gt;&lt;th&gt;线路&lt;/th&gt;&lt;th&gt;带宽&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;2核&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;2G&lt;/td&gt;&lt;td&gt;0G&lt;/td&gt;&lt;td&gt;80G&lt;/td&gt;&lt;td&gt;双线&lt;/td&gt;&lt;td&gt;2Mbps&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;价格:468元/月, 4680元/年&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;[美团云](https://mos.meituan.com/)&#34; href=&#34;#[美团云](https://mos.meituan.com/)&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://mos.meituan.com/&#34;&gt;美团云&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;&lt;th align=&#34;left&#34;&gt;内存&lt;/th&gt;&lt;th&gt;系统盘&lt;/th&gt;&lt;th&gt;数据盘&lt;/th&gt;&lt;th&gt;线路&lt;/th&gt;&lt;th&gt;带宽&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&#34;left&#34;&gt;2核&lt;/td&gt;&lt;td align=&#34;left&#34;&gt;2G&lt;/td&gt;&lt;td&gt;0G&lt;/td&gt;&lt;td&gt;80G&lt;/td&gt;&lt;td&gt;未知&lt;/td&gt;&lt;td&gt;2Mbps&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;价格:210元/月, 2100元/年, 0.34元/小时&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>使用Python的10个常见错误</title>
      <link>http://prisoner.github.io/2014/07/23/%E4%BD%BF%E7%94%A8Python%E7%9A%8410%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF.html</link>
      <pubDate>2014-07-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;从&lt;a href=&#34;http://www.toptal.com/python/top-10-mistakes-that-python-programmers-make&#34;&gt;10 Most Common Python Mistakes&lt;/a&gt;抄来的.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;a href=&#34;http://ipython.org/&#34;&gt;iPython&lt;/a&gt; 生成.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;#1:-错误的使用表达式做为函数默认值&#34; href=&#34;##1:-错误的使用表达式做为函数默认值&#34;&gt;&lt;/a&gt;#1: 错误的使用表达式做为函数默认值&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def foo(a = []):&#xA;    a.append(&#39;bar&#39;)&#xA;    return a&#xA;&#xA;foo()&#xA;foo()&#xA;foo()&#xA;foo()&#xA;&#xA;&#xA;&#xA;&#xA;[&#39;bar&#39;, &#39;bar&#39;, &#39;bar&#39;, &#39;bar&#39;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;#2:-不正确的使用类变量&#34; href=&#34;##2:-不正确的使用类变量&#34;&gt;&lt;/a&gt;#2: 不正确的使用类变量&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class A:&#xA;    a = 1&#xA;&#xA;class B(A):&#xA;    pass&#xA;&#xA;class C(A):&#xA;    pass&#xA;&#xA;B.a = 2&#xA;print A.a, B.a, C.a&#xA;A.a = 3&#xA;print A.a, B.a, C.a&#xA;&#xA;1 2 1&#xA;3 2 3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;#3:-错误的异常块参数&#34; href=&#34;##3:-错误的异常块参数&#34;&gt;&lt;/a&gt;#3: 错误的异常块参数&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def f():&#xA;    #a = None&#xA;    try:&#xA;        l = [1, 2, 3]&#xA;        a = l[100]&#xA;    except (ValueError, IndexError) as e:&#xA;        pass&#xA;    return a&#xA;&#xA;print f()&#xA;&#xA;&#xA;---------------------------------------------------------------------------&#xA;UnboundLocalError                         Traceback (most recent call last)&#xA;&#xA;&amp;lt;ipython-input-40-ffa24284290f&amp;gt; in &amp;lt;module&amp;gt;()&#xA;      8     return a&#xA;      9&#xA;---&amp;gt; 10 print f()&#xA;&#xA;&#xA;&amp;lt;ipython-input-40-ffa24284290f&amp;gt; in f()&#xA;      6     except (ValueError, IndexError) as e:&#xA;      7         pass&#xA;----&amp;gt; 8     return a&#xA;      9&#xA;     10 print f()&#xA;&#xA;&#xA;UnboundLocalError: local variable &#39;a&#39; referenced before assignment&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;#4:-错误的理解python变量作用域&#34; href=&#34;##4:-错误的理解python变量作用域&#34;&gt;&lt;/a&gt;#4: 错误的理解Python变量作用域&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;x = 100&#xA;def foo():&#xA;    # global x&#xA;    x += 101&#xA;    print x&#xA;&#xA;foo()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;#5:-遍历list时修改了该list&#34; href=&#34;##5:-遍历list时修改了该list&#34;&gt;&lt;/a&gt;#5: 遍历list时修改了该list&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;numbers = [x for x in xrange(0, 10)]&#xA;for i in numbers:&#xA;    if bool(i % 2):&#xA;        del numbers[i]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;#6:-错误的理解closure的变量绑定&#34; href=&#34;##6:-错误的理解closure的变量绑定&#34;&gt;&lt;/a&gt;#6: 错误的理解closure的变量绑定&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def create_multipliers():&#xA;    return [lambda x : x * i for i in range(0, 5)]&#xA;&#xA;for i in create_multipliers():&#xA;    print i(2)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;#7:-错误的模块依赖&#34; href=&#34;##7:-错误的模块依赖&#34;&gt;&lt;/a&gt;#7: 错误的模块依赖&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#a.py&#xA;import b&#xA;&#xA;def f():&#xA;    return b.x&#xA;&#xA;print f()&#xA;&#xA;#b.py&#xA;import a&#xA;&#xA;x = 1&#xA;&#xA;def g():&#xA;    print a.f()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;#8:-命名容易和标准模块混淆&#34; href=&#34;##8:-命名容易和标准模块混淆&#34;&gt;&lt;/a&gt;#8: 命名容易和标准模块混淆&lt;/h2&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;#9:-未注意python-2-和-python-3-的差异&#34; href=&#34;##9:-未注意python-2-和-python-3-的差异&#34;&gt;&lt;/a&gt;#9: 未注意Python 2 和 Python 3 的差异&lt;/h2&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;#10:-错误的使用__del__方法&#34; href=&#34;##10:-错误的使用__del__方法&#34;&gt;&lt;/a&gt;#10: 错误的使用&lt;strong&gt;del&lt;/strong&gt;方法&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import foo&#xA;&#xA;class Bar(object):&#xA;    def __del__(self):&#xA;        foo.cleanup(self.myhandle)&#xA;&#xA;#当解释器关闭时, 所有的global 变量都会被设置成None. 所以此时调用__del__会触发AttributeError错误.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 1.3 Release Notes</title>
      <link>http://prisoner.github.io/2014/06/24/Go-1.3-Release-Notes.html</link>
      <pubDate>2014-06-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;6月18日，在Go 1.2发布六个月之后，Go官方宣布正式发布Go 1.3。Go 1.3并没有引入新的语言功能，只是进行了功能改进，并修复了一些bug以及用户的反馈。新的版本开始支持DragonFly BSD、Solaris、Plan 9和Google的NaCl（ Native Client），且显著改进了链接器和编译器。低版本的Go语言用户无需更改任何代码即可升级到Go 1.3。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;主要改进包括：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;改进了内存模型。在缓冲的channel发送和接收数据时增加了一条规则，使缓冲的channel可以被用作一个简单的信号灯（Semaphore）。&lt;/li&gt;&#xA;&lt;li&gt;不再支持Windows 2000。微软在2010年时就不再支持Windows 2000，现在Go 1.3也放弃对它的支持。&lt;/li&gt;&#xA;&lt;li&gt;支持BSD和Solaris系统。Go 1.3开始支持DragonFly BSD、FreeBSD、NetBSD、OpenBSD、Plan 9、Solaris，但对这些系统的支持都有一些其他特殊要求，比如对FreeBSD的支持必须要求内核编译时配置COMPAT_FREEBSD32参数。&lt;/li&gt;&#xA;&lt;li&gt;支持 Native Client 虚拟机架构。Go 1.3既可以在32位Inter架构处理器上( GOARCH=386 )运行，也能在64位Intel架构上运行，但是在64位架构上使用的是32位pointer，对于ARM架构暂不支持。关于Native Client的介绍可以阅读其官方介绍。&lt;/li&gt;&#xA;&lt;li&gt;改进了栈的实现方式。将栈实现方式从分段（segmented）模型改为连续（contiguous）模型。当一个goroutine（ Go 语言提供的一种用户态线程）需要更多的栈空间且超过了可用大小时，栈会被转移到一个单独的更大的内存块。&lt;/li&gt;&#xA;&lt;li&gt;改进了垃圾回收机制。Go已经在堆上实现了精准的垃圾回收，Go 1.3增加了栈上的垃圾回收。另外，GC的速度也得到了提升，现在采用的是并发清除算法，可以缩短50-70%的GC中断时间。&lt;/li&gt;&#xA;&lt;li&gt;重构了链接器。对链接器和编译器进行了重构，链接器仍然是使用C语言编写，但是指令选择阶段被移入到编译器中并创建了一个新的包liblink。指令选择只会在程序包被编译时执行一次，所以这这样可以加快大幅度提升大工程的编译速度。&lt;/li&gt;&#xA;&lt;li&gt;其它的一些改进。比如实现了新的正则表达式引擎、更快的race detector、默认栈的大小从8K变为4K 字节、资源竞争的检测快了40%、增加了很多新参数等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;读者可以在&lt;a href=&#34;http://golang.org/dl/&#34;&gt;这里&lt;/a&gt;下载Go 1.3。详细的改进说明可以阅读&lt;a href=&#34;http://tip.golang.org/doc/go1.3&#34;&gt;官方文档&lt;/a&gt;。不能翻墙的用户可以使用社区提供的镜像来&lt;a href=&#34;http://golangtc.com/download&#34;&gt;下载&lt;/a&gt;。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>ElasticSearch索引优化速查</title>
      <link>http://prisoner.github.io/2014/05/12/ElasticSearch%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E9%80%9F%E6%9F%A5.html</link>
      <pubDate>2014-05-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近做ElasticSearch索引的优化, 发现一篇好文. 转载于此, 有空再翻译.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;原文地址: &lt;a href=&#34;https://blog.codecentric.de/en/2014/05/elasticsearch-indexing-performance-cheatsheet/&#34;&gt;Elasticsearch Indexing Performance Cheatsheet&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;You plan to index large amounts of data in Elasticsearch? Or you are already trying to do so but it turns out that throughput is too low? Here is a collection of tips and ideas to increase indexing throughput with Elasticsearch. Some of them I have successfully tried myself, others I have only read about and found them reasonable. In any case, I hope you will find them useful.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In order to fit all this into a single article, I have kept the suggestions rather brief. For some of them, you may feel that you need to learn more before putting them into practice. To ease your task a little, I have included links to the relevant sections of the Elasticsearch documentation which you may use as a starting point for further research.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;General Performance&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Before doing anything more specific, it makes sense to follow the advice given in the Elasticsearch documentation on &lt;a href=&#34;http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/setup-configuration.html&#34;&gt;configuration&lt;/a&gt;. In a nutshell:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Set the maximum number of open file descriptors for the user running Elasticsearch to at least 32k or 64k.&lt;/li&gt;&#xA;&lt;li&gt;If possible, consider disabling swapping for the Elasticsearch process memory. Note, however, that in a virtualized environment this may not behave as expected.&lt;/li&gt;&#xA;&lt;li&gt;Set -Xms to the same value as -Xmx (the same result can be achieved by setting the ES_HEAP_SIZE environment variable).&lt;/li&gt;&#xA;&lt;li&gt;Leave some amount of physical memory unassigned so that the OS file system cache is free to use it for Lucene’s benefit. A rule of thumb is to have the Elasticsearch JVM use no more than half of the available memory.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Mapping&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;If your search requirements allow it, there is some room for optimization in the mapping definition of your index:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;By default, Elasticsearch stores the original data in a special  _source field . If you do not need it, disable it.&lt;/li&gt;&#xA;&lt;li&gt;By default, Elasticsearch analyzes the input data of all fields in a special  _all field . If you do not need it, disable it.&lt;/li&gt;&#xA;&lt;li&gt;If you are using the _source field, there is no additional value in setting any other field to _stored.&lt;/li&gt;&#xA;&lt;li&gt;If you are not using the _source field, only set those fields to _stored that you need to. Note, however, that using _source brings certain advantages, such as the ability to use the update API.&lt;/li&gt;&#xA;&lt;li&gt;For analyzed fields, do you need norms ? If not, disable them by setting norms.enabled to false.&lt;/li&gt;&#xA;&lt;li&gt;Do you need to store term frequencies and positions, as is done by default, or can you do with less – maybe only doc numbers? Set index_options to what you really need, as outlined in the string core type description .&lt;/li&gt;&#xA;&lt;li&gt;For analyzed fields, use the simplest analyzer that satisfies the requirements for the field. Or maybe you can even go with not_analyzed?&lt;/li&gt;&#xA;&lt;li&gt;Do not analyze, store, or even send data to Elasticsearch that you do not need for answering search requests. In particular, double-check the content of mappings that you do not define yourself (e.g., because a tool like Logstash generates them for you).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Requests and Clients&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;You can also gain a lot from optimizing the way in which you transfer indexing requests to Elasticsearch:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Do you have to send a separate request for each document? Or can you buffer documents in order to use the bulk API  for indexing multiple documents with a single request?&lt;/li&gt;&#xA;&lt;li&gt;When using bulk requests, optimize the bulk size, i.e., how many documents you bundle in a single request. Usually an appropriate bulk size has to be discovered empirically by trying out different sizes under realistic load conditions.&lt;/li&gt;&#xA;&lt;li&gt;If your business can afford it, you can even consider trading some reliability for performance using the bulk UDP API  for certain data. This is particularly interesting if the client and server participating in the request reside on the same host.&lt;/li&gt;&#xA;&lt;li&gt;If you are using an HTTP client, consider using long-lived HTTP connections. Also, make sure that HTTP chunking is not hampering throughput.&lt;/li&gt;&#xA;&lt;li&gt;Consider using one of the various existing clients  as they may contain performance advantages over using plain HTTP.&lt;/li&gt;&#xA;&lt;li&gt;If your client speaks Java, consider using the NodeClient . A NodeClient joins the cluster and knows which nodes to address for certain requests, possibly saving one hop when compared to other clients. If you cannot use the NodeClient, e.g., due to security restrictions, see if you can use  TransportClient  before considering something else.&lt;/li&gt;&#xA;&lt;li&gt;Can you parallelize indexing by using multiple clients? It may well be that a single client turns out to be the indexing bottleneck and that the Elasticsearch server is able to handle a much higher load.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Sharding and Replication&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Elasticsearch provides sharding and replication as the recommended way for scaling and increasing availability of an index. There are a few things to consider:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;If a single Elasticsearch server is not enough to provide your desired indexing throughput, you may need to scale out. Multiple cluster nodes enable parallel work on an index by sharding it. Note: The number of shards of an index needs to be set  on index creation  and cannot be changed later. In case you do not know exactly how much data to expect, you may consider overallocating a few shards (but not too many, they are not free!) to have some spare capacity available. Other than that, index aliases may provide a way (albeit with limitations) of scaling out an index at a later point in time.&lt;/li&gt;&#xA;&lt;li&gt;Replication is an important feature for being able to cope with failure, but the more replicas you have the longer indexing will take. Thus, for raw indexing throughput it would be best to have no replicas at all. Luckily, in contrast to the number of shards, you may change the number of replicas  of an index at any time, which gives us some additional options. In certain situations, such as populating a new index initially, or migrating data from one index to another, it may prove beneficial to start without replication and only add replicas later, once the time-critical initial indexing has been completed.&lt;/li&gt;&#xA;&lt;li&gt;Consider separating data nodes (that actually store and index data) from “aggregator nodes” (used only for querying). When aggregator nodes handle search queries and only contact data nodes as needed, they take load off the data nodes which will then have more capacity for handling indexing requests.&lt;/li&gt;&#xA;&lt;li&gt;By default, an indexing request is completed once the data has been safely received (i.e., stored in the transaction log) by all replicas. By setting the query parameter replication to async , the request will already complete when the data has been acknowledged on the primary shard.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Index Settings&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;There are several index level settings that you may tune to improve indexing throughput:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;By default, an index shard uses a refresh interval of one second, i.e., new documents become available for search after one second. Even though refreshing is a more lightweight operation than one may think, it comes at a cost. Thus, depending on your search requirements, you may consider setting the refresh interval to something higher than one second. It can even make sense to temporarily  turn off refreshing completely  for an index (by setting the interval to -1), e.g., during a bulk indexing run, and trigger it manually  at the end.&lt;/li&gt;&#xA;&lt;li&gt;Compared to refreshing an index shard, the really expensive operation is flushing its transaction log (which involves a Lucene commit). Elasticsearch performs flushes based on a number of triggers that may be changed at run time . By delaying flushes, or disabling them completely, you can increase indexing throughput. Just be aware that nothing comes for free, and the delayed flush will of course take longer when it eventually happens.&lt;/li&gt;&#xA;&lt;li&gt;The default segment merge policy, “tiered”, supports a compound format where data is stored in fewer files to reduce the number of open file handles needed. However, the compound format comes along with a performance penalty. There are two settings, index.compound_on_flush and index.compound_format, that specify whether the compound format should be used for new segments and merged segments, respectively. Making sure that both are set to false may improve indexing performance, at the cost of more file handles.&lt;/li&gt;&#xA;&lt;li&gt;Segment merging is done in the background but requires I/O from which indexing performance may suffer. Therefore, it is possible to throttle merging  to a maximum number of bytes per second, on the node or index level. Note that throttling is already done by default, but maybe you want to adjust the predefined limit according to your needs.&lt;/li&gt;&#xA;&lt;li&gt;The setting indices.memory.index_buffer_size defines the percentage of available heap memory that may be used for indexing operations (the remaining heap memory will mainly be used for search operations). The default of 10% may be too low if you have lots of data to index, and it may make sense to set it to a higher value .&lt;/li&gt;&#xA;&lt;li&gt;Index warmup is a useful concept to speed up search queries, but when indexing large amounts of data (in particular, bulk indexing) it may make sense to temporarily disable it .&lt;/li&gt;&#xA;&lt;li&gt;Consider increasing the node level thread pool size for indexing and bulk operations (and measure if it really brings an improvement).&lt;/li&gt;&#xA;&lt;li&gt;The setting index.index_concurrency limits the number of threads that may concurrently perform indexing operations on a single shard. Consider increasing the value, especially when there are no other shards on the node (and measure if it pays off).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Conclusion&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;I hope some of these suggestions will help you resolve any indexing performance problems you might have. Keep in mind, however, that the most important aspect of a search engine is, well, the search. Do not make the mistake of tuning your search engine to maximum indexing throughput only to discover that out of a sudden its query performance suffers or it does not fulfill the functional requirements anymore. Always make sure that your users get a quality search experience and really find what they are looking for.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Docker中遗失的包</title>
      <link>http://prisoner.github.io/2014/04/22/Docker%E4%B8%AD%E9%81%97%E5%A4%B1%E7%9A%84%E5%8C%85.html</link>
      <pubDate>2014-04-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;http://crosbymichael.com/the-lost-packages-of-docker.html&#34;&gt;原文&lt;/a&gt;   &lt;a href=&#34;http://www.oschina.net/translate/the-lost-packages-of-docker&#34;&gt;翻译&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;netlink&#34; href=&#34;#netlink&#34;&gt;&lt;/a&gt;netlink&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;我们有一个Netlink的纯Go实现，你可以用在你的项目中。你可以使用这个包来创建veth 接口，桥，设置IP，mtu，和网络接口的其他设置，移动网络接口到不同的Linux命名空间中，等等一堆事情。创建veth pairs和对你的每个docker容器分配一个IP的代码是相同的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;让我们用这个包创建一个桥并设置一个IP：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;        &amp;quot;github.com/dotcloud/docker/pkg/netlink&amp;quot;&#xA;        &amp;quot;log&amp;quot;&#xA;        &amp;quot;net&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;        // create a new bridge&#xA;        if err := netlink.CreateBridge(&amp;quot;mydocker0&amp;quot;, false); err != nil {&#xA;                log.Fatal(err)&#xA;        }&#xA;        // get the bridge&#xA;        bridge, err := net.InterfaceByName(&amp;quot;mydocker0&amp;quot;)&#xA;        if err != nil {&#xA;                log.Fatal(err)&#xA;        }&#xA;&#xA;        ip, ipNet, err := net.ParseCIDR(&amp;quot;10.0.41.1/16&amp;quot;)&#xA;        if err != nil {&#xA;                log.Fatal(err)&#xA;        }&#xA;&#xA;        // add an ip to the bridge&#xA;        if err := netlink.NetworkLinkAddIp(bridge, ip, ipNet); err != nil {&#xA;                log.Fatal(err)&#xA;        }&#xA;        // bring the interface up&#xA;        if err := netlink.NetworkLinkUp(bridge); err != nil {&#xA;                log.Fatal(err)&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们可以运行上面的应用，然后运行 ip a 来查看我们的新接口：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;2: mydocker0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default&#xA;    link/ether ae:1f:cb:af:f2:54 brd ff:ff:ff:ff:ff:ff&#xA;    inet 10.0.41.1/16 scope global mydocker0&#xA;    valid_lft forever preferred_lft forever&#xA;    inet6 fe80::ac1f:cbff:feaf:f254/64 scope link&#xA;    valid_lft forever preferred_lft forever&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;netlink 包功能还不齐全，但希望正在于未知，我们可以一起工作使其变得更好。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;user&#34; href=&#34;#user&#34;&gt;&lt;/a&gt;user&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Linux的用户和组函数不依赖于外部库。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;graphdb&#34; href=&#34;#graphdb&#34;&gt;&lt;/a&gt;graphdb&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;graphdb是一个构建在SQLite之上的极小图数据库，通过节点命名以及它们是怎样关联的。它实现了大多数图数据库拥有的一个小子集，但是提供一个简单的接口去表示节点间的关系。这用于容器的命名和docker之间的连接。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;        &amp;quot;github.com/dotcloud/docker/pkg/graphdb&amp;quot;&#xA;        &amp;quot;log&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;        db, err := graphdb.NewSqliteConn(&amp;quot;/root/links.db&amp;quot;)&#xA;        if err != nil {&#xA;                log.Fatal(err)&#xA;        }&#xA;        defer db.Close()&#xA;&#xA;        if _, err := db.Set(&amp;quot;/parent&amp;quot;, &amp;quot;momma&amp;quot;); err != nil {&#xA;                log.Fatal(err)&#xA;        }&#xA;&#xA;        child, err := db.Set(&amp;quot;/child&amp;quot;, &amp;quot;matt&amp;quot;)&#xA;        if err != nil {&#xA;                log.Fatal(err)&#xA;        }&#xA;        otherKid, err := db.Set(&amp;quot;/otherKid&amp;quot;, &amp;quot;koye&amp;quot;)&#xA;        if err != nil {&#xA;            log.Fatal(err)&#xA;        }&#xA;&#xA;        // set entity with id of matt to child of the parent&#xA;        if _, err := db.Set(&amp;quot;/parent/child&amp;quot;, child.ID()); err != nil {&#xA;                log.Fatal(err)&#xA;        }&#xA;        if _, err := db.Set(&amp;quot;/parent/kidbyaothername&amp;quot;, otherKid.ID()); err != nil {&#xA;                log.Fatal(err)&#xA;        }&#xA;&#xA;        // get all children for the key /parent&#xA;        for _, e := range db.List(&amp;quot;/parent&amp;quot;, -1) {&#xA;                log.Println(e.ID())&#xA;        }&#xA;}&#xA;&#xA;:::bash&#xA;~|⇒ go run graph.go&#xA;2014/04/14 16:16:19 matt&#xA;2014/04/14 16:16:19 koye&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;listenbuffer&#34; href=&#34;#listenbuffer&#34;&gt;&lt;/a&gt;listenbuffer&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Listenbuffer允许你立即去开启监听tcp、udp套接字，但是 在接受连接之前，需要等待你的应用程序发出信号。&#xA;在docker中使用Listenbuffer，所以你开启一个守护进程和一个客户请求，在守护进程完成加载之前，一个初始化的脚本被发送。这确保了初始化脚本不能接收一个错误，而你的服务器却能开始接收连接，当它准备好时。如果你有很长的引导，那么它使用内核积压去缓冲连接，这是一个提供一些值的超级简单封装。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;mount&#34; href=&#34;#mount&#34;&gt;&lt;/a&gt;mount&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;挂载是一个帮助你在挂载了许多东西的前提下工作的包。它允许它的选项使用fstab风格，同时也提供挂载表分析函数，以便于你的应用程序很容易找到挂载点。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// do a readonly bind mount&#xA;if err := mount.Mount(&amp;quot;/myfile&amp;quot;, &amp;quot;/myotherfile&amp;quot;, &amp;quot;none&amp;quot;, &amp;quot;bind,ro&amp;quot;); err != nil {&#xA;    log.Fatal(err)&#xA;}&#xA;defer mount.Unmount(&amp;quot;/myotherfile&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;term&#34; href=&#34;#term&#34;&gt;&lt;/a&gt;term&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Term处理终端大小，原始模式和其他的设置，比如与 其他linux,darwin或者BSD系统的Unix终端进行交互的。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;cgroups&#34; href=&#34;#cgroups&#34;&gt;&lt;/a&gt;cgroups&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;现在这个包处于沉重发展时期，但是 通过原始的cgroup文件系统API或者 支持的系统API,它 为liccontainer提供了cgroup功能。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;libcontainer&#34; href=&#34;#libcontainer&#34;&gt;&lt;/a&gt;libcontainer&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;libcontainer位于pkg文件中。它是运行docker容器的默认执行驱动：设定命名空间、网络、挂载、管理容器进程。你需要提供一个根文件系统和一个关于libcontainer怎样被支持去运行在容器中配置文件，然后完成剩余的工作。它允许产生新的容器或者附加到现有的容器上。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;最后我想说为什么写这篇文章？我想要让人们知道这些包。然而其他项目能够区分git仓库，对于它们使用和开发的不同依赖， docker不得不把这些包放在它的主库里，从而导致许多人们不知道它们的存在。所以如果它们中的一些包引起你的兴趣，你可自由的在你的项目中使用、贡献、写文档、测试，让它们越来越好。&#xA;如果当前你知道在docker代码库中你所感兴趣的地方是一个不可重用的包，请提交一个“pull request”，使它成为可重用的。我们一直寻求使docker内核更小，我们的工作给他人带来便利。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>工程师心里的痛只有工程师才会懂</title>
      <link>http://prisoner.github.io/2014/04/18/%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%83%E9%87%8C%E7%9A%84%E7%97%9B%E5%8F%AA%E6%9C%89%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%89%8D%E4%BC%9A%E6%87%82.html</link>
      <pubDate>2014-04-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;工程师心里的痛只有工程师才会懂&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;embed src=&#34;http://player.youku.com/player.php/sid/XNjk3NTQ5ODE2/v.swf&#34; allowFullScreen=&#34;true&#34; quality=&#34;high&#34; width=&#34;480&#34; height=&#34;400&#34; align=&#34;middle&#34; allowScriptAccess=&#34;always&#34; type=&#34;application/x-shockwave-flash&#34;&gt;&lt;/embed&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>ElasticSearch名词解释</title>
      <link>http://prisoner.github.io/2014/04/04/ElasticSearch%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A.html</link>
      <pubDate>2014-04-04 12:00:00 +0800</pubDate>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;cluster&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;每个cluster由一个或多个节点组成,它们共享同一个集群名.每个cluster有一个被自动选出的master节点,当该master节点挂掉的时候会被自动替换.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;node&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;node是elasticsearch的运行实例.为了测试,多个node可以在同一台服务器上启动,但是通常一个服务器只放一个node.&#xA;系统启动时,node会使用广播(或指定的多播)来发现一个现有的cluster,并且试图加入该cluster.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;index&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;index有点像关系型数据库中的“database”,包含不同的type的schema映射.&#xA;一个index是一个逻辑上的命名空间,具有一个或多个primary shards,可以拥有零个或多个replia shards.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;shard&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;一个shard是一个单独的lucene实例,是被elasticsearch自动管理的底层工作单元.一个索引是包含primary或replia切片的逻辑命名空间.&#xA;除了需要定义primary shards和replia shards的数量以外,你不需要直接指定使用的shards,你的代码中只关心index就好.&#xA;Elasticsearch在集群中分布所有的shards,并且在添加删除节点时,自动重新分配.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;primary shard&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;每个document都存储在一个单独的primary shard中.当为一个document建索引时,首先在primary shard上建立,然后在该primary shard的所有replica shards上面建.&#xA;默认的,每个索引有5个primary shards.你可以通过减少或增加primary shards的数量来伸缩你的索引能够接受的文档数量.&#xA;当索引创建以后,你不能够改变索引中primary shards的数量.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;replica shard&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;每个primary shard有零或多个repica shard,replica是primary的拷贝,有两个目的,&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   1. 提高恢复能力：当primary挂掉时,replica可以变成primary&#xA;&#xA;   2. 提高性能：get和search请求既可以由primary又可以由replica处理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;默认的,每个primary有一个replica,但一个索引的replica的数量可以动态地调整.replica从不与它的primary在同一个node上启动.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;routing&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;当为某个document建立索引的时候,索引存储在某个primary shard上.该shard是通过哈希routing value选出来的.默认的,routing value通过document ID得到,或者当该文档有特定的父文档,从父文档的ID得到(这是为了保证子文档和父文档存储在相同的shard).&#xA;       该value可以在建索引时指定,或者在mapping中通过routing field给定.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;recovery&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;代表数据恢复或叫数据重新分布, elasticsearch在有节点加入或退出时会根据机器的负载对索引分片进行重新分配, 挂掉的节点重新启动时也会进行数据恢复.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;river&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;代表elasticsearch的一个数据源, 也是其它存储方式(如：数据库)同步数据到elasticsearch的一个方法.它是以插件方式存在的一个elasticsearch服务, 通过读取river中的数据并把它索引到elasticsearch中, 官方的river有couchDB的, RabbitMQ的, Twitter的, Wikipedia的, river这个功能将会在后面的文件中重点说到.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;gateway&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;代表elasticsearch索引的持久化存储方式. elasticsearch默认是先把索引存放到内存中, 当内存满了时再持久化到硬盘. 当这个elasticsearch集群关闭再重新启动时就会从gateway中读取索引数据. elasticsearch支持多种类型的gateway, 有本地文件系统(默认), 分布式文件系统, Hadoop的HDFS和amazon的s3云存储服务.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;discovery.zen&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;代表elasticsearch的自动发现节点机制, elasticsearch是一个基于p2p的系统, 它先通过广播寻找存在的节点, 再通过多播协议来进行节点之间的通信, 同时也支持点对点的交互.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Transport&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;代表elasticsearch内部节点或集群与客户端的交互方式, 默认内部是使用tcp协议进行交互, 同时它支持http协议(json格式)、thrift、servlet、memcached、zeroMQ等的传输协议(通过插件方式集成).&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang调用C</title>
      <link>http://prisoner.github.io/2014/03/31/Golang%E8%B0%83%E7%94%A8C.html</link>
      <pubDate>2014-03-31 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有时候我们需要在go中调用一些使用C或者C++编写的代码. 而这些代码大多数会被编译成动态链接库的形式存在.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;本文就以Mac OS下的Go开发为例, 来测试在GO中调用C.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先做一个简单的动态链接库.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;hello.h&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;#ifndef HELLO_H&#xA;#define HELLO_H&#xA;&#xA;void hello(const char *name);&#xA;&#xA;#endif&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;hello.c&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;&#xA;void hello(const char *name) {&#xA;  printf(&amp;quot;Hello %s!\n&amp;quot;, name);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后编译并生成动态库:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;gcc -c hello.c&#xA;cc -dynamiclib -o libhello.dylib hello.o&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编写GO代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;golang&#34;&gt;package hello&#xA;&#xA;/*&#xA;#cgo CFLAGS: -I../c/hello&#xA;#cgo LDFLAGS: -L../c/hello -lhello&#xA;#include &amp;lt;hello.h&amp;gt;&#xA;*/&#xA;import &amp;quot;C&amp;quot;&#xA;&#xA;func Hello(str string) {&#xA;    C.hello(C.CString(str))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;CFLAGS: -I../c/hello&lt;/code&gt;指定头文件的位置(hello.h)&#xA;&lt;code&gt;LDFLAGS: -L../c/hello -lhello&lt;/code&gt; 指定动态库的位置(libhello.dylib).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;编译并安装:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;go build hello&#xA;go install hello&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在写一个测试程序来调用:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;golang&#34;&gt;package main&#xA;&#xA;import &amp;quot;hello&amp;quot;&#xA;&#xA;func main(){&#xA;    hello.Hello(&amp;quot;world&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;运行命令, 将动态库安装到系统能识别的位置.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;mv libhello.dylib /usr/local/lib/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;运行输出:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Hello world!&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go并发模式：管道和取消</title>
      <link>http://prisoner.github.io/2014/03/30/Go%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%96%E6%B6%88.html</link>
      <pubDate>2014-03-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;由&lt;a href=&#34;http://air.googol.im/2014/03/15/go-concurrency-patterns-pipelines-and-cancellation.html&#34;&gt;Air on G&lt;/a&gt;翻译.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;译自[](http://blog.golang.org/pipelines)&lt;a href=&#34;http://blog.golang.org/pipelines&#34;&gt;http://blog.golang.org/pipelines&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这是 Go 官方 blog 的一篇文章，介绍了如何使用 Go 来编写并发程序，并按照程序的演化顺序，介绍了不同模式遇到的问题以及解决的问题。主要解释了用管道模式链接不同的线程，以及如何在某个线程取消工作时，保证所有线程以及管道资源的正常回收。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Go 并发模式：管道和取消&lt;/p&gt;&#xA;&#xA;&lt;p&gt;作者：Sameer Ajmani，&lt;a href=&#34;http://blog.golang.org&#34;&gt;blog.golang.org&lt;/a&gt;，写于 2014 年 3 月 13 日。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;介绍&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Go 本身提供的并发特性，可以轻松构建用于处理流数据的管道，从而高效利用 I/O 和多核 CPU。这篇文章就展示了这种管道的例子，并关注当操作失败时要处理的一些细节，并介绍了如何干净的处理错误的技巧。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;什么是管道？&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Go 语言里没有明确定义管道，而只是把管道当作一类并发程序。简单来说，管道是一系列由 channel 联通的状态（stage），而每个状态是一组运行相同函数的 Goroutine。每个状态上，Goroutine&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过流入（inbound）channel 接收上游的数值&lt;/li&gt;&#xA;&lt;li&gt;运行一些函数来处理接收的数据，一般会产生新的数值&lt;/li&gt;&#xA;&lt;li&gt;通过流出（outbound）channel 将数值发给下游&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;每个语态都会有任意个流入或者流出 channel，除了第一个状态（只有流出 channel）和最后一个状态（只有流入 channel）。第一个状态有时被称作源或者生产者；最后一个状态有时被称作槽（sink）或者消费者。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们先从一个简单的管道例子开始解释这些想法和技术。之后，我们再来看一些更真实的例子。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;求平方数&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;考虑一个管道和三个状态。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;第一个状态，&lt;code&gt;gen&lt;/code&gt;，是一个将一系列整数一一传入 channel 的函数。&lt;code&gt;gen&lt;/code&gt;函数启动一个 Goroutine，将整数数列发送给 channel，如果所有数都发送完成，关闭这个 channel：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func gen(nums ...int) &amp;lt;-chan int {&#xA;    out := make(chan int)&#xA;    go func() {&#xA;        for _, n := range nums {&#xA;            out &amp;lt;- n&#xA;        }&#xA;        close(out)&#xA;    }()&#xA;    return out&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;第二个状态，&lt;code&gt;sq&lt;/code&gt;，从一个 channel 接收整数，并求整数的平方，发送给另一个 channel。当流入 channel 被关闭，而且状态已经把所有数值都发送给了下游，关闭流出 channel：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func sq(in &amp;lt;-chan int) &amp;lt;-chan int {&#xA;    out := make(chan int)&#xA;    go func() {&#xA;        for n := range in {&#xA;            out &amp;lt;- n * n&#xA;        }&#xA;        close(out)&#xA;    }()&#xA;    return out&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;主函数建立起管道，并执行最终的状态：从第二个状态接收所有的数值并打印，直到 channel 被关闭：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    // 建立管道&#xA;    c := gen(2, 3)&#xA;    out := sq(c)&#xA;&#xA;    // 产生输出&#xA;    fmt.Println(&amp;lt;-out) // 4&#xA;    fmt.Println(&amp;lt;-out) // 9&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;因为&lt;code&gt;sq&lt;/code&gt;有相同类型的流入和流出 channel，我们可以将其组合任意次。我们也可以将&lt;code&gt;main&lt;/code&gt;函数写成和其他状态类似的范围循环的形式：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    // 建立管道并产生输出&#xA;    for n := range sq(sq(gen(2, 3))) {&#xA;        fmt.Println(n) // 16 和 81&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;扇出，扇入&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;多个函数可以同时从一个 channel 接收数据，直到 channel 关闭，这种情况被称作_扇出_。这是一种将工作分布给一组工作者的方法，目的是并行使用 CPU 和 I/O。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一个函数同时接收并处理多个 channel 输入并转化为一个输出 channel，直到所有的输入 channel 都关闭后，关闭输出 channel。这种情况称作_扇入_。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以将我们的管道改为同时执行两个&lt;code&gt;sq&lt;/code&gt;实例，每个都从同样的输入 channel 读取数据。我们还引入新函数，&lt;code&gt;merge&lt;/code&gt;，来扇入所有的结果：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    in := gen(2, 3)&#xA;&#xA;    // 在两个从 in 里读取数据的 Goroutine 间分配 sq 的工作&#xA;    c1 := sq(in)&#xA;    c2 := sq(in)&#xA;&#xA;    // 输出从 c1 和 c2 合并的数据&#xA;    for n := range merge(c1, c2) {&#xA;        fmt.Println(n) // 4 和 9, 或者 9 和 4&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;merge&lt;/code&gt;对每个流入 channel 启动一个 Goroutine，并将流入的数值复制到流出 channel，由此将一组 channel 转换到一个 channel。一旦启动了所有的&lt;code&gt;output&lt;/code&gt; Goroutine，&lt;code&gt;merge&lt;/code&gt;函数会多启动一个 Goroutine，这个 Goroutine 在所有的输入 channel 输入完毕后，关闭流出 channel。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;往一个已经关闭的 channel 输出会产生异常（panic），所以一定要保证所有数据发送完成后再执行关闭。&lt;a href=&#34;http://golang.org/pkg/sync/#WaitGroup&#34;&gt;&lt;code&gt;sync.WaitGroup&lt;/code&gt;&lt;/a&gt;类型提供了方便的方法，来保证这种同步：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func merge(cs ...&amp;lt;-chan int) &amp;lt;-chan int {&#xA;    var wg sync.WaitGroup&#xA;    out := make(chan int)&#xA;&#xA;    // 为 cs 中每个输入 channel 启动输出 Goroutine。output 从 c 中复制数值，直到 c 被关闭&#xA;    // 之后调用 wg.Done&#xA;    output := func(c &amp;lt;-chan int) {&#xA;        for n := range c {&#xA;            out &amp;lt;- n&#xA;        }&#xA;        wg.Done()&#xA;    }&#xA;    wg.Add(len(cs))&#xA;    for _, c := range cs {&#xA;        go output(c)&#xA;    }&#xA;&#xA;    // 启动一个 Goroutine，当所有 output Goroutine 都工作完后（wg.Done），关闭 out，&#xA;    // 保证只关闭一次。这个 Goroutine 必须在 wg.Add 之后启动&#xA;    go func() {&#xA;        wg.Wait()&#xA;        close(out)&#xA;    }()&#xA;    return out&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;突然关闭&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;我们的管道函数里有个模式：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;状态会在所有发送操作做完后，关闭它们的流出 channel&lt;/li&gt;&#xA;&lt;li&gt;状态会持续接收从流入 channel 输入的数值，直到 channel 关闭&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;这个模式使得每个接收状态可以写为一个&lt;code&gt;range&lt;/code&gt;循环，并保证所有的 Goroutine 在将所有的数值发送成功给下游后立刻退出。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是实际的管道，状态不能总是接收所有的流入数值。有时这是设计决定的：接收者可能只需要一部分数值做进一步处理。更常见的情况是，一个状态会由于从早先的状态流入的数值有误而退出。不管哪种情况，接收者都不应该继续等待剩下的数值，而且我们希望早先的状态可以停止生产后续状态不需要的数据。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在我们的管道例子里，如果一个状态无法处理所有的流入数值，试图发送那些数值的 Goroutine 会被永远阻塞住：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    // 处理输出的第一个数值&#xA;    out := merge(c1, c2)&#xA;    fmt.Println(&amp;lt;-out) // 4 或者 9&#xA;    return&#xA;    // 由于我们不再接收从 out 输出的第二个数值，其中一个输出 Goroutine 会由于试图发送数值而挂起&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这是资源泄漏：Goroutine 会占用内存和运行时资源，而且 Goroutine 栈里的堆引用会一直持有数据，这些数据无法被垃圾回收。Goroutine 本身也无法被垃圾回收，它们必须靠自己退出（而不是被其他人杀死）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;即便下游的状态无法接收所有的流入数值，我们依然需要让管道里的上游状态正常退出。一种方法是修改流出 channel，使其含有缓冲区。缓冲区可以持有固定数量的数值，当缓冲区有空间时，发送操作会立刻完成（，不会产生阻塞）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在创建 channel 时，如果已经知道要发送数值的数量，缓冲区可以简化代码。比如，我们可以让&lt;code&gt;gen&lt;/code&gt;把整数列表里的数复制进 channel 缓冲区，而不需使用新的 Goroutine：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func gen(nums ...int) &amp;lt;-chan int {&#xA;    out := make(chan int, len(nums))&#xA;    for _, n := range nums {&#xA;        out &amp;lt;- n&#xA;    }&#xA;    close(out)&#xA;    return out&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;回到我们管道的阻塞问题上来，我们可以考虑给&lt;code&gt;merge&lt;/code&gt;的流出 channel 加上缓冲区：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func merge(cs ...&amp;lt;-chan int) &amp;lt;-chan int {&#xA;    var wg sync.WaitGroup&#xA;    out := make(chan int, 1) // 1 个空间足够应付未读的输入&#xA;    // ... 其余未变 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这个改动当然修正了程序中阻塞 Goroutine 的问题，但这不是好的代码。缓冲区的大小为 1，依赖于我们已经知道我们将要&lt;code&gt;merge&lt;/code&gt;的数值总数和下游状态要处理的数值总数。这太脆弱了：如果我们从&lt;code&gt;gen&lt;/code&gt;传入额外的数值，或者下游状态再多读一些数值，我们仍将看到 Goroutine 被阻塞住了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不使用缓冲区的话，我们需要提供一种方法，让下游状态通知发送者，下游状态将停止接收输入。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;显式取消&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;当&lt;code&gt;main&lt;/code&gt;要在不接收所有来自&lt;code&gt;out&lt;/code&gt;的数值前退出，就需要告诉所有上游状态的 Goroutine，放弃尝试发送数值的行为。这可以通过发送数值到一个叫做&lt;code&gt;done&lt;/code&gt;的 channel 来完成。例子里有两个潜在的会被阻塞的发送者，所以给&lt;code&gt;done&lt;/code&gt;发送了两个数值：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    in := gen(2, 3)&#xA;&#xA;    // 发布 sq 的工作到两个都从 in 里读取数据的 Goroutine&#xA;    c1 := sq(in)&#xA;    c2 := sq(in)&#xA;&#xA;    // 处理来自 output 的第一个数值&#xA;    done := make(chan struct{}, 2)&#xA;    out := merge(done, c1, c2)&#xA;    fmt.Println(&amp;lt;-out) // 4 或者 9&#xA;&#xA;    // 通知其他发送者，该退出了&#xA;    done &amp;lt;- struct{}{}&#xA;    done &amp;lt;- struct{}{}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;发送 Goroutine 将发送操作替换为一个&lt;code&gt;select&lt;/code&gt;语句，要么把数据发送给&lt;code&gt;out&lt;/code&gt;，要么处理来自&lt;code&gt;done&lt;/code&gt;的数值。&lt;code&gt;done&lt;/code&gt;的类型是个空结构，因为具体数值并不重要：接收事件本身就指明了应当放弃继续发送给 out 的动作。而&lt;code&gt;output&lt;/code&gt; Goroutine 会继续循环处理流入的 channel，&lt;code&gt;c&lt;/code&gt;, 而不会阻塞上游状态：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func merge(done &amp;lt;-chan struct{}, cs ...&amp;lt;-chan int) &amp;lt;-chan int {&#xA;    var wg sync.WaitGroup&#xA;    out := make(chan int)&#xA;&#xA;    // 为每个 cs 中的输入 channel 启动一个 output Goroutine。outpu 从 c 里复制数值直到 c 被关闭&#xA;    // 或者从 done 里接收到数值，之后 output 调用 wg.Done&#xA;    output := func(c &amp;lt;-chan int) {&#xA;        for n := range c {&#xA;            select {&#xA;            case out &amp;lt;- n:&#xA;            case &amp;lt;-done:&#xA;            }&#xA;        }&#xA;        wg.Done()&#xA;    }&#xA;    // ... 其余的不变 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;但是这种方法有个问题：下游的接收者需要知道潜在会被阻塞的上游发送者的数量。追踪这些数量不仅枯燥，还容易出错。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们需要一种方法，让不知道也不限制数量的 Goroutine，停止往它们下游发送数据的行为。在 Go 里，我们可以通过关闭 channel 来实现这个工作，因为&lt;a href=&#34;http://golang.org/ref/spec#Receive_operator&#34;&gt;channel 被关闭时，接收工作会立刻执行，并产生一个符合类型的 0 值&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这就是说，&lt;code&gt;main&lt;/code&gt;可以容易的通过关闭&lt;code&gt;done&lt;/code&gt;channel 来释放所有的发送者。关闭是个高效的发送给所有发送者的广播信号。我们扩展管道里的每个函数，让其以参数方式接收&lt;code&gt;done&lt;/code&gt;，并通过&lt;code&gt;defer&lt;/code&gt;语句在函数退出时执行关闭操作，这样&lt;code&gt;main&lt;/code&gt;里所有的退出路径都会触发管道里的所有状态退出。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    // 构建 done channel，整个管道里分享 done，并在管道退出时关闭这个 channel&#xA;    // 以此通知所有 Goroutine 该推出了。&#xA;    done := make(chan struct{})&#xA;    defer close(done)&#xA;&#xA;    in := gen(done, 2, 3)&#xA;&#xA;    // 发布 sq 的工作到两个都从 in 里读取数据的 Goroutine&#xA;    c1 := sq(done, in)&#xA;    c2 := sq(done, in)&#xA;&#xA;    // 处理来自 output 的第一个数值&#xA;    out := merge(done, c1, c2)&#xA;    fmt.Println(&amp;lt;-out) // 4 或者 9&#xA;&#xA;    // done 会通过 defer 调用而关闭&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;管道里的每个状态现在都可以随意的提早退出了：&lt;code&gt;sq&lt;/code&gt;可以在它的循环中退出，因为我们知道如果&lt;code&gt;done&lt;/code&gt;已经被关闭了，也会关闭上游的&lt;code&gt;gen&lt;/code&gt;状态。&lt;code&gt;sq&lt;/code&gt;通过&lt;code&gt;defer&lt;/code&gt;语句，保证不管从哪个返回路径，它的&lt;code&gt;out&lt;/code&gt; channel 都会被关闭。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func sq(done &amp;lt;-chan struct{}, in &amp;lt;-chan int) &amp;lt;-chan int {&#xA;    out := make(chan int)&#xA;    go func() {&#xA;        defer close(out)&#xA;        for n := range in {&#xA;            select {&#xA;            case out &amp;lt;- n * n:&#xA;            case &amp;lt;-done:&#xA;                return&#xA;            }&#xA;        }&#xA;    }()&#xA;    return out&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;下面列出了构建管道的指南：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;状态会在所有发送操作做完后，关闭它们的流出 channel&lt;/li&gt;&#xA;&lt;li&gt;状态会持续接收从流入 channel 输入的数值，直到 channel 关闭或者其发送者被释放。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;管道要么保证足够能存下所有发送数据的缓冲区，要么接收来自接收者明确的要放弃 channel 的信号，来保证释放发送者。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;对目录做摘要&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;来考虑一个更现实的管道。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;MD5 是一个摘要算法，经常在对文件的校验的时候使用。命令行上使用&lt;code&gt;md5sum&lt;/code&gt;来打印出一系列文件的摘要数值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们的程序类似&lt;code&gt;md5sum&lt;/code&gt;，但是参数是一个目录，之后会打印出这个目录下所有常规文件的摘要值，以文件路径名排序。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们的主函数包含一个&lt;code&gt;MD5All&lt;/code&gt;的辅助函数，返回一个路径名到摘要值的映射，之后排序并打印结果：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    // 计算指定目录下所有文件的 MD5 值，之后按照目录名排序并打印结果&#xA;    m, err := MD5All(os.Args[1])&#xA;    if err != nil {&#xA;        fmt.Println(err)&#xA;        return&#xA;    }&#xA;    var paths []string&#xA;    for path := range m {&#xA;        paths = append(paths, path)&#xA;    }&#xA;    sort.Strings(paths)&#xA;    for _, path := range paths {&#xA;        fmt.Printf(&amp;quot;%x  %s\n&amp;quot;, m[path], path)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;MD5All&lt;/code&gt;函数是我们讨论的焦点。在&lt;a href=&#34;http://blog.golang.org/pipelines/serial.go&#34;&gt;&lt;code&gt;serial.go&lt;/code&gt;&lt;/a&gt;文件里，是非并发的函数实现，再扫描目录树时简单读取并计算每个文件。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// MD5All 读取文件目录 root 下所有文件，并返回从文件路径到文件内容 MD5 值的映射。如果扫描目录&#xA;// 出错或者任何操作失败，MD5All 返回失败。&#xA;func MD5All(root string) (map[string][md5.Size]byte, error) {&#xA;    m := make(map[string][md5.Size]byte)&#xA;    err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {&#xA;        if err != nil {&#xA;            return err&#xA;        }&#xA;        if info.IsDir() {&#xA;            return nil&#xA;        }&#xA;        data, err := ioutil.ReadFile(path)&#xA;        if err != nil {&#xA;            return err&#xA;        }&#xA;        m[path] = md5.Sum(data)&#xA;        return nil&#xA;    })&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    return m, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;并行摘要&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在&lt;a href=&#34;http://blog.golang.org/pipelines/parallel.go&#34;&gt;&lt;code&gt;parallel.go&lt;/code&gt;&lt;/a&gt;里，我们把&lt;code&gt;MD5All&lt;/code&gt;分解为两个状态的管道。第一个状态，&lt;code&gt;sumFiles&lt;/code&gt;，遍历目录，在一个新的 Goroutine 里对每个文件做摘要，并把结果发送到类型为&lt;code&gt;result&lt;/code&gt;的 channel：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type result struct {&#xA;    path string&#xA;    sum  [md5.Size]byte&#xA;    err  error&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;sumFiles&lt;/code&gt;返回两个 channel：一个用来传递&lt;code&gt;result&lt;/code&gt;，另一个用来返回&lt;code&gt;filepath.Walk&lt;/code&gt;的错误。遍历函数启动一个新的 Goroutine 来处理每个常规文件，之后检查&lt;code&gt;done&lt;/code&gt;。如果&lt;code&gt;done&lt;/code&gt;已经被关闭了，遍历就立刻停止：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func sumFiles(done &amp;lt;-chan struct{}, root string) (&amp;lt;-chan result, &amp;lt;-chan error) {&#xA;    // 对每个常规文件，启动一个 Goroutine 计算文件内容并发送结果到 c。发送 walk 的结果到 errc&#xA;    c := make(chan result)&#xA;    errc := make(chan error, 1)&#xA;    go func() {&#xA;        var wg sync.WaitGroup&#xA;        err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {&#xA;            if err != nil {&#xA;                return err&#xA;            }&#xA;            if info.IsDir() {&#xA;                return nil&#xA;            }&#xA;            wg.Add(1)&#xA;            go func() {&#xA;                data, err := ioutil.ReadFile(path)&#xA;                select {&#xA;                case c &amp;lt;- result{path, md5.Sum(data), err}:&#xA;                case &amp;lt;-done:&#xA;                }&#xA;                wg.Done()&#xA;            }()&#xA;            // 如果 done 被关闭了，停止 walk&#xA;            select {&#xA;            case &amp;lt;-done:&#xA;                return errors.New(&amp;quot;walk canceled&amp;quot;)&#xA;            default:&#xA;                return nil&#xA;            }&#xA;        })&#xA;        // walk 已经返回，所有 wg.Add 的工作都做完了。开启新进程，在所有发送完成后&#xA;        // 关闭 c。&#xA;        go func() {&#xA;            wg.Wait()&#xA;            close(c)&#xA;        }()&#xA;        // 因为 errc 有缓冲区，所以这里不需要 select。&#xA;        errc &amp;lt;- err&#xA;    }()&#xA;    return c, errc&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;MD5All&lt;/code&gt;从&lt;code&gt;c&lt;/code&gt;接收所有的摘要值。&lt;code&gt;MD5All&lt;/code&gt;返回早先的错误，通过&lt;code&gt;defer&lt;/code&gt;关闭&lt;code&gt;done&lt;/code&gt;：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func MD5All(root string) (map[string][md5.Size]byte, error) {&#xA;    // MD5All 在返回时关闭 done channel；这个可能在从 c 和 errc 收到所有的值之前被调用&#xA;    done := make(chan struct{})&#xA;    defer close(done)&#xA;&#xA;    c, errc := sumFiles(done, root)&#xA;&#xA;    m := make(map[string][md5.Size]byte)&#xA;    for r := range c {&#xA;        if r.err != nil {&#xA;            return nil, r.err&#xA;        }&#xA;        m[r.path] = r.sum&#xA;    }&#xA;    if err := &amp;lt;-errc; err != nil {&#xA;        return nil, err&#xA;    }&#xA;    return m, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;受限的并发&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在&lt;a href=&#34;http://blog.golang.org/pipelines/parallel.go&#34;&gt;&lt;code&gt;parallel.go&lt;/code&gt;&lt;/a&gt;里实现的&lt;code&gt;MD5All&lt;/code&gt;对每个文件启动一个新的 Goroutine。如果目录里含有很多大文件，这可能会导致申请大量内存，超出机器上的可用内存。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以通过控制并行读取的文件数量来限制内存的申请。在&lt;a href=&#34;http://blog.golang.org/pipelines/bounded.go&#34;&gt;&lt;code&gt;bounded.go&lt;/code&gt;&lt;/a&gt;，我们创建固定数量的用于读取文件的 Goroutine，来限制内存使用。现在整个管道有三个状态：遍历树，读取并对文件做摘要，收集摘要值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;第一个状态，&lt;code&gt;walkFiles&lt;/code&gt;，发送树里的每个常规文件的路径：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func walkFiles(done &amp;lt;-chan struct{}, root string) (&amp;lt;-chan string, &amp;lt;-chan error) {&#xA;    paths := make(chan string)&#xA;    errc := make(chan error, 1)&#xA;    go func() {&#xA;        // 在 Walk 之后关闭 paths channel&#xA;        defer close(paths)&#xA;        // 因为 errc 有缓冲区，所以这里不需要 select。&#xA;        errc &amp;lt;- filepath.Walk(root, func(path string, info os.FileInfo, err error) error {&#xA;            if err != nil {&#xA;                return err&#xA;            }&#xA;            if info.IsDir() {&#xA;                return nil&#xA;            }&#xA;            select {&#xA;            case paths &amp;lt;- path:&#xA;            case &amp;lt;-done:&#xA;                return errors.New(&amp;quot;walk canceled&amp;quot;)&#xA;            }&#xA;            return nil&#xA;        })&#xA;    }()&#xA;    return paths, errc&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;中间的状态启动固定数量的&lt;code&gt;digester&lt;/code&gt; Goroutine，从&lt;code&gt;paths&lt;/code&gt;接收文件名，并将结果&lt;code&gt;result&lt;/code&gt;发送到 channel &lt;code&gt;c&lt;/code&gt;：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func digester(done &amp;lt;-chan struct{}, paths &amp;lt;-chan string, c chan&amp;lt;- result) {&#xA;    for path := range paths {&#xA;        data, err := ioutil.ReadFile(path)&#xA;        select {&#xA;        case c &amp;lt;- result{path, md5.Sum(data), err}:&#xA;        case &amp;lt;-done:&#xA;            return&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;不象之前的例子，&lt;code&gt;digester&lt;/code&gt;并不关闭输出 channel，因为多个 Goroutine 会发送到共享的 channel。另一边，&lt;code&gt;MD5All&lt;/code&gt;中的代码会在所有&lt;code&gt;digester&lt;/code&gt;完成后关闭 channel：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   // 启动固定数量的 Goroutine 来读取并对文件做摘要。&#xA;    c := make(chan result)&#xA;    var wg sync.WaitGroup&#xA;    const numDigesters = 20&#xA;    wg.Add(numDigesters)&#xA;    for i := 0; i &amp;lt; numDigesters; i++ {&#xA;        go func() {&#xA;            digester(done, paths, c)&#xA;            wg.Done()&#xA;        }()&#xA;    }&#xA;    go func() {&#xA;        wg.Wait()&#xA;        close(c)&#xA;    }()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们也可以让每个&lt;code&gt;digester&lt;/code&gt;创建并返回自己的输出 channel，但是这就需要一个单独的 Goroutine 来扇入所有结果。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最终从&lt;code&gt;c&lt;/code&gt;收集到所有结果&lt;code&gt;result&lt;/code&gt;，并检查从&lt;code&gt;errc&lt;/code&gt;传入的错误。这个错误的检查不能提早，因为在这个时间点之前，&lt;code&gt;walkFiles&lt;/code&gt;可能会因为正在发送消息给下游而阻塞：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    m := make(map[string][md5.Size]byte)&#xA;    for r := range c {&#xA;        if r.err != nil {&#xA;            return nil, r.err&#xA;        }&#xA;        m[r.path] = r.sum&#xA;    }&#xA;    // 检查 Walk 是否失败&#xA;    if err := &amp;lt;-errc; err != nil {&#xA;        return nil, err&#xA;    }&#xA;    return m, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;结论&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;这篇文章展示了使用 Go 构建流数据管道的技术。要慎重处理这种管道产生的错误，因为管道里的每个状态都可能因为向下游发送数值而阻塞，而下游的状态却不再关心输入的数据。我们展示了如何将关闭 channel 作为“完成”信号广播给所有由管道启动的 Goroutine，并且定义了正确构建管道的指南。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;进一步阅读：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://talks.golang.org/2012/concurrency.slide#1&#34;&gt;Go 并发模式&lt;/a&gt;（&lt;a href=&#34;https://www.youtube.com/watch?v=f6kdp27TYZs&#34;&gt;视频&lt;/a&gt;）展示了 Go 的并发特性的基础知识，并演示了应用这些知识的方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/advanced-Go-concurrency-patterns&#34;&gt;高级 Go 并发模式&lt;/a&gt;（&lt;a href=&#34;http://www.youtube.com/watch?v=QDDwwePbDtw&#34;&gt;视频&lt;/a&gt;）覆盖了关于 Go 特性更复杂的使用场景，尤其是 select。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Douglas McIlroy 的论文&lt;a href=&#34;http://swtch.com/~rsc/thread/squint.pdf&#34;&gt;《一窥级数数列》&lt;/a&gt;展示了 Go 使用的这类并发技术是如何优雅地支持复杂计算&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux 文件 Loop设备 LVM</title>
      <link>http://prisoner.github.io/2014/03/13/Linux-%E6%96%87%E4%BB%B6-Loop%E8%AE%BE%E5%A4%87-LVM.html</link>
      <pubDate>2014-03-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;不知道标题该怎么取. 本文主要介绍在Linux下怎样将文件挂载成磁盘并且用LVM进行分区管理.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;什么是loop设备&#34; href=&#34;#什么是loop设备&#34;&gt;&lt;/a&gt;什么是loop设备&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;loop设备是一种伪设备. 是使用文件来模拟块设备的一种技术. 文件模拟成块设备后, 就像一个磁盘或光盘一样使用. 回环可以理解成回复重用, 在已有设备上建立文件来模拟物理块设备.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;关联loop设备&#34; href=&#34;#关联loop设备&#34;&gt;&lt;/a&gt;关联loop设备&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一般在linux中会有8个loop设备. 我们可以将文件关联到这些设备上.&#xA;查看所有的loop设备: &lt;code&gt;losetup -a&lt;/code&gt;, 输出:&#xA;&lt;code&gt;&#xA;/dev/loop0: [0806]:5373954 (/mnt/var/disk/disk0.img)&#xA;/dev/loop1: [0806]:5373955 (/mnt/var/disk/disk1.img)&#xA;/dev/loop2: [0806]:5373956 (/mnt/var/disk/disk2.img)&#xA;/dev/loop3: [0806]:5373957 (/mnt/var/disk/disk3.img)&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;查看下一个未使用的loop设备: &lt;code&gt;losetup -f&lt;/code&gt;, 输出:&#xA;&lt;code&gt;&#xA;/dev/loop4&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用&lt;code&gt;dd&lt;/code&gt;或者&lt;code&gt;truncate&lt;/code&gt;创建文件. 如:&#xA;&lt;code&gt;truncate -s 10M disk0.img&lt;/code&gt;&#xA;或者&#xA;&lt;code&gt;dd if=/dev/zero of=disk0.img ibs=1M count=10&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后执行:&#xA;&lt;code&gt;losetup /dev/loop0 disk0.img&lt;/code&gt;&#xA;将文件disk0.img关联到&lt;code&gt;/dev/loop0&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这时候disk0.img已经可以做为块设备使用了. 我们可以将它分区,并创建文件系统, 然后挂载, 就好像使用一个普通的硬盘一样.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;使用lvm管理分区&#34; href=&#34;#使用lvm管理分区&#34;&gt;&lt;/a&gt;使用LVM管理分区&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;我们也可以使用LVM来管理分区.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;按照上文创建3个loop设备.&#xA;&lt;code&gt;&#xA;/dev/loop0&#xA;/dev/loop1&#xA;/dev/loop2&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;创建物理卷&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pvcreate /dev/loop0 /dev/loop1 /dev/loop2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;创建卷组&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;vgcreate vg0 /dev/loop0 /dev/loop1 /dev/loop2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;创建逻辑卷&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;lvcreate --size 20m --name lv0 vg0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们现在已经有一个使用3个文件来创建的lvm逻辑卷了. 对这个逻辑卷创建文件系统并挂载后就可以像普通文件系统一样使用了.&#xA;如果在以后的使用中觉得空间不够的话, 还可以创建新的文件并关联loop设备, 然后添加到lvm的卷组中, 并且对逻辑卷进行在线扩容. 具体可以参考LVM的使用手册.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>什么是Node？</title>
      <link>http://prisoner.github.io/2014/02/23/%E4%BB%80%E4%B9%88%E6%98%AFNode%EF%BC%9F.html</link>
      <pubDate>2014-02-23 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;什么是node？&#34; href=&#34;#什么是node？&#34;&gt;&lt;/a&gt;什么是Node？&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://img03.taobaocdn.com/tps/i3/T15q4UXa4CXXXXXXXX-320-419.jpg&#34; alt=&#34;http://img03.taobaocdn.com/tps/i3/T15q4UXa4CXXXXXXXX-320-419.jpg&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;node不是万能药！但的确能解决一些关键问题。&#34; href=&#34;#node不是万能药！但的确能解决一些关键问题。&#34;&gt;&lt;/a&gt;Node不是万能药！但的确能解决一些关键问题。&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;学习Node不是一件轻松事儿，但你所收到的回报是对得起你的付出的。因为当下Web应用开发中的诸多难题唯有JavaScript才能解决。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;作者：&lt;a href=&#34;http://www.oreillynet.com/pub/au/152&#34;&gt;Brett McLaughlin&lt;/a&gt; ，翻译：&lt;a href=&#34;http://jayli.github.com&#34;&gt;拔赤&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;原文：&lt;a href=&#34;http://oreilly.com/catalog/0636920021506&#34;&gt;What is Node?&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;目录&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;专家们的警告！&lt;/li&gt;&#xA;&lt;li&gt;Node：几个小例子&lt;/li&gt;&#xA;&lt;li&gt;Node不是JavaScript，Node可以运行JavaScript&lt;/li&gt;&#xA;&lt;li&gt;和Node服务器的交互&lt;/li&gt;&#xA;&lt;li&gt;快速入门手册&lt;/li&gt;&#xA;&lt;li&gt;解释器之惑&lt;/li&gt;&#xA;&lt;li&gt;基于事件的Web应用&lt;/li&gt;&#xA;&lt;li&gt;Node的用武之地&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;“你够酷吗？来用我吧！” Node.js 为最新潮的编程语言提供了一系列很酷的API和工具箱，它可以直接应用于传统的Rails、Ajax、Hadoop、甚至可以某种程度上用于iPhone开发和HTML5。如果你参加过一些大型技术会议，你总是会听到一些关于Node.js的主题演讲，尽管这些话题对普通的开发者来说依然有些难以企及。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你可能已经听说Node.js（有时我们将其简称为“Node”）是一个服务器端的解决方案，它可以运行JavaScript，并可以作为Web服务来处理HTTP请求。如果这些东东还不至于让你晕头转向的话，转眼间关于端口、sockets和线程的讨论就又成了当下最热门的话题，你会觉得这些东西让你眼花缭乱。这些内容真的属于JavaScript的范畴吗？为什么世界上那么多人宁愿将JavaScript脱离浏览器而运行，更不用说将JavaScript运行于服务器端了？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;好消息是，你所听到的（所想到的）关于Node的一切都是正确的。Node的的确确是属于网络编程的范畴，用以处理服务器端的请求和响应。坏消息是和之前的Rails、Ajax和Hadoop一样，真正实用的技术资料实在太少。等到基于Node的“优秀的”框架成熟之后，技术资料一定会跟得上的，但何必要等到技术书籍和教程都出来之后再去尝试使用Node呢？现在就使用Node，说不定会给你的代码带来意想不到的改观，甚至让你的程序变得更易实现。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;专家们的警告！&#34; href=&#34;#专家们的警告！&#34;&gt;&lt;/a&gt;专家们的警告！&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;和大多数技术一样，Node也是新瓶装旧酒：它看起来不透明而且很怪异，但独受小开发团队的青睐。如果你没有接触过Node，则需要学习一些很容易上手的服务器端脚本。你需要化时间来搞清楚Node，因为即便是运行于服务器端的JavaScript，它和客户端JavaScript也极为不同。实际情况是，你不得不自己给自己洗脑，以便重新学习理解围绕JavaScript的事件处理机制、异步IO和一些网络基础知识。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不幸的是，这意味着如果你已经用Node作开发超过两年时间的话，你会觉得这篇文章内容很单调乏而且过于简单。你会开始寻找新的“刺激”，比如将Node运行于客户端，或者开始尝试事件I/O、反射器模式和npm。你会发现Node的世界是如此有趣，甚至很多Node高级技术具有某种史诗般的美感，而这些东西对于初学者来说依然是难于企及的。因此，或许你应该将你掌握的知识分享给你的同伴，尤其是对于那些不了解Node的同学，当他们开始对Node感兴趣时，给他们分享传授Node高级技术。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;node：几个小例子&#34; href=&#34;#node：几个小例子&#34;&gt;&lt;/a&gt;Node：几个小例子&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;首先，你应当意识到Node是用于运行独立的JavaScript程序的，而不是运行于浏览器中的某个HTML片段里。它是存放在文件系统中的真实存在的文件，由Node程序执行，以一种守护进程的模式运行，同时打开对某些端口的监听。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;跳过 hello world&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;最经典的例子当然是“Hello World“，在Node官网（http://nodejs.org/docs/latest ）上有源码。几乎每个人都是从Hello World开始接触Node的。现在让我们跳过这个最简单的例子，来看一些更有趣的例子：实现一个可以从服务器发送文件到客户端的程序（而不仅仅是发送一段文本到客户端）。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var sys = require(&amp;quot;sys&amp;quot;),&#xA;http = require(&amp;quot;http&amp;quot;),&#xA;url = require(&amp;quot;url&amp;quot;),&#xA;path = require(&amp;quot;path&amp;quot;),&#xA;fs = require(&amp;quot;fs&amp;quot;);&#xA;http.createServer(function(request, response) {&#xA;    var uri = url.parse(request.url).pathname;&#xA;    var filename = path.join(process.cwd(), uri);&#xA;    path.exists(filename, function(exists) {&#xA;        if(!exists) {&#xA;            response.writeHead(404, {&amp;quot;Content-Type&amp;quot;: &amp;quot;text/plain&amp;quot;});&#xA;            response.end(&amp;quot;404 Not Found&#xA;&amp;quot;);&#xA;            return;&#xA;        }&#xA;        fs.readFile(filename, &amp;quot;binary&amp;quot;, function(err, file) {&#xA;            if(err) {&#xA;                response.writeHead(500, {&amp;quot;Content-Type&amp;quot;: &amp;quot;text/plain&amp;quot;});&#xA;                response.end(err %2B &amp;quot;&#xA;&amp;quot;);&#xA;                return;&#xA;            }&#xA;            response.writeHead(200);&#xA;            response.end(file, &amp;quot;binary&amp;quot;);&#xA;        });&#xA;    });&#xA;}).listen(8080);&#xA;console.log(&amp;quot;Server running at http://localhost:8080/&amp;quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;感谢Mike Amundsen，他给出了这段代码的相似的实现。这个例子是由Devon Govett在Nettuts+上提交的一段代码，尽管已经根据新版本的Node作了更新，但Devon的&lt;a href=&#34;http://net.tutsplus.com/tutorials/javascript-ajax/learning-serverside-javascript-with-Node-js/&#34;&gt;整个帖子&lt;/a&gt;是一个非常好的入门学习教材，对于初学者来说更是如此。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你是一个新手，你可以将上述代码保存到一个文本文件中，命名为NodeFileServer.js。在运行之前你需要一个Node运行环境，最新的Node版本可以从&lt;a href=&#34;http://Nodejs.org/&#34;&gt;官网&lt;/a&gt;下载&lt;a href=&#34;http://Nodejs.org/docs/latest/#download&#34;&gt;这个文件&lt;/a&gt;或者从&lt;a href=&#34;https://github.com/joyent/Node&#34;&gt;github上&lt;/a&gt;将源码取下来。你需要编译源码，如果你没有用过Unix、对make和configure不甚熟悉，则需要查阅在&lt;a href=&#34;https://github.com/joyent/Node/wiki/Installation&#34;&gt;线编译手册&lt;/a&gt;来寻求帮助。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;node不是javascript，node可以运行javascript&#34; href=&#34;#node不是javascript，node可以运行javascript&#34;&gt;&lt;/a&gt;Node不是JavaScript，Node可以运行JavaScript&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;刚刚你将NodeFileServer.js存成了某个文件，别担心，我们等下会回过头来运行它的。现在，让我们移步到现实当中来，在Unix中执行典型的配置和编译命令：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    ./configure&#xA;    make&#xA;    make install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这让我们确信一个事实：Node不是JavaScript，Node是一个可以运行JavaScript的程序，但Node绝对不是JavaScript。实际上，Node是基于C写的程序。可以通过ls来查看Node/src目录中的文件，可以看到Node的源码：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://img04.taobaocdn.com/tps/i4/T1rtxUXjNzXXXXXXXX-500-335.png&#34; alt=&#34;png&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大多数人会以为，JavaScript是一门糟糕的语言，更不用说用它来实现服务器端的功能了，其实你只对了一半。不错，对于操作系统级别的Socket和网络编程来说，JavaScript可能并不能胜任。但Node并不是JavaScript实现的，它是基于C实现的。C语言是可以完美的胜任任意量级的网络编程的。而JavaScript则完全有能力将指令传递给C程序，然后由C程序来操控操作系统“地下城”。实际上，和C语言相比，JavaScript更容易被开发者们接触到，这是值得引起注意的地方，如果你想用Node进行一些严肃的编程的话，这个原因会被一再提及。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Node的基本用法进一步反映出了Node是如何和JavaScript一起工作的，Node不是JavaScript。你可以通过命令行来运行它：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    — (bdm0509@Bretts-MacBook-Pro Sun, 29 May 11)&#xA;    — — — — — — — — — — (/Users/bdm0509/tmp/Node/src) —&#xA;    — (09:09 $)-&amp;gt; export PATH=$HOME/local/Node/bin:$PATH&#xA;    — (bdm0509@Bretts-MacBook-Pro Sun, 29 May 11)&#xA;    — — — — — — — — — — (/Users/bdm0509/tmp/Node/src) —&#xA;    — (09:09 $)-&amp;gt; cd ~/examples&#xA;    — (bdm0509@Bretts-MacBook-Pro Sun, 29 May 11)&#xA;    — — — — — — — — — — — — (/Users/bdm0509/examples) —&#xA;    — (09:09 $)-&amp;gt; Node NodeFileServer.js&#xA;    Server running at http://127.0.0.1:1337/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;现在你肯定对Node有个大概的了解了吧。对于这段命令行，的确还有很多知识点需要进一步解释说明，比如在端口1337到底发生了什么？但这里你只需知道，Node只是一个可以让你运行JavaScript的程序。读者不必纠结于Node如何和JavaScript协同工作，这里也不会对此做过多介绍，只要知道Node可以运行JavaScript，这就足够了。而且你只需学习JavaScript这一门编程语言即可，不用担心自己不懂C语言。记住这是最最重要的一点，不必了解C也可写出Node可运行的程序。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;和node服务器的交互&#34; href=&#34;#和node服务器的交互&#34;&gt;&lt;/a&gt;和Node服务器的交互&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;刚才我们在Node上运行了NodeFileServer.js。这时你可以访问你本机的1337端口，可以看到正常的输出。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://jayli.github.com/whatisnode/assets/interacting.png&#34; alt=&#34;interacting&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;没错，输出结果不足为奇。但应当意识到我们只用短短20行代码就实现了一个文件服务器。输出结果是你刚刚保存的脚本源文件的文本，并没有以二进制的形式输出。这个文件服务器可以输出它上面的任何文件。如果在同样目录下放入一张图片，在URL后缀中写上图片文件名，就像这样：http://localhost:8080/my_image.png。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://jayli.github.com/whatisnode/assets/mockup.png&#34; alt=&#34;mockup&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Node也可以展示出二进制的图片文件。当你回头再看这段短小的程序时，一定觉得这太不可思议了。用JavaScript轻易就能写出一个你想要的服务程序难道不让人感到惬意吗？不仅如此，假设你想写一个可以处理多个请求的服务（这是一个提示，同时打开四个五个甚至十个浏览器访问服务器），这也是很容易做到的。Node让人着迷的地方在于，你完全可以用很简单而且很不起眼的JavaScript程序来完成你想要的这些结果。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;快速入门手册&#34; href=&#34;#快速入门手册&#34;&gt;&lt;/a&gt;快速入门手册&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;围绕Node的话题总是会比纯粹运行在服务器端的代码更值得花点时间来讨论。不管怎样，我们还是从一段代码开始我们的话题，概览一下NodeFileServer.js文件，观察代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;    var http = require(&#39;http&#39;);&#xA;    http.createServer(function (req, res) {&#xA;        res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});&#xA;        res.end(&#39;Hello World&#xA;    &#39;);&#xA;    }).listen(1337, &amp;quot;127.0.0.1&amp;quot;);&#xA;    console.log(&#39;Server running at http://127.0.0.1:1337/&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;首先调用了函数require()，require()是程序员最常用的函数之一。实际上，在&lt;a href=&#34;http://www.commonjs.org&#34;&gt;CommonJS规范&lt;/a&gt;中也有提到这个函数，在&lt;a href=&#34;http://wiki.commonjs.org/wiki/Modules/1.1&#34;&gt;讨论到关于JavaScript模块&lt;/a&gt;概念的时候有提及，此外，Davd Flanagan在2009年的&lt;a href=&#34;http://www.davidflanagan.com/2009/11/commonjs-module.html&#34;&gt;一个很酷的实现&lt;/a&gt;中也有提到。换句话说，require()对于你来说可能是个新鲜事物，但它不是Node随意添加的一个函数，他是使用JavaScript进行模块化编程的核心概念，Node将这一特性发挥的淋漓尽致。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接下来，http变量用以创建一个服务器。这个服务使用一个回调函数来处理当产生一个连接时的动作。这里的回调函数并未对请求作过多修饰，仅仅以text/plain格式输出一个字符串“Hello World”作为请求响应。这个逻辑非常简单。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;实际上，这里展示了使用Node的标准模式：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义交互类型，并获得一个用以处理这个交互的变量（通过require()）。&lt;/li&gt;&#xA;&lt;li&gt;创建一个新的服务（通过createServer()）。&lt;/li&gt;&#xA;&lt;li&gt;给服务绑定一个回调，用以处理请求。&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;处理请求的函数应当包括一个请求&amp;hellip;&lt;/li&gt;&#xA;&lt;li&gt;&amp;hellip;和一个响应&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;通知服务器启动服务，这里需要指定IP和端口（通过listen）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;解释器之惑&#34; href=&#34;#解释器之惑&#34;&gt;&lt;/a&gt;解释器之惑&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;尽管通过这种方法可以使用JavaScript轻易的实现一个服务（不管运行代码的虚机实际上跑的是C程序还是其他什么程序），这种做法回避了一个问题：你需要使用JavaScript写出一个服务器吗？为了找到这个问题的答案，我们来考虑一个非常典型的场景。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;JSON的处理&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;这是一种非常典型的web应用，前台使用HTML和CSS，JavaScript用来作数据验证，并和后台进行数据交互。由于你处于web交互的最顶端，你使用Ajax提交数据到后台并从后台获取数据，而不是单单依靠表单提交来实现。如果你是这样做的话，那么你同样会非常喜欢使用JSON的。JSON是如今最流行的传输数据的格式。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此，这个Ajax也可以比作“把在线拍卖网站里的某些吉他的信息发给我”。这个请求通过网络到达一个运行PHP程序的服务器。PHP服务器不得不给JavaScript返回很多信息，而且这些信息必须以某种形式的数据包发给客户端，而且这个数据包是可以被JavaScript解析的。因此数据可以打包成数组，然后转换为JSON，就像这样：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;    $itemGuitar = array(&#xA;        &#39;id&#39; =&amp;gt; &#39;itemGuitar&#39;,&#xA;        &#39;description&#39; =&amp;gt; &#39;Pete Townshend once played this guitar while his own axe &#39; .&#xA;            was in the shop having bits of drumkit removed from it.&#39;,&#xA;        &#39;price&#39; =&amp;gt; 5695.99,&#xA;        &#39;urls&#39; =&amp;gt; array(&#39;http://www.thewho.com&#39;,&#xA;            &#39;http://en.wikipedia.com/wiki/Pete_Townshend&#39;)&#xA;    );&#xA;&#xA;    $output = json_encode($itemGuitar);&#xA;    print($output);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;回到客户端，JavaScript得到这个返回的数据包，由于经过转换，数据编程了JSON格式。就像这样：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;    {&#xA;        &amp;quot;id&amp;quot;: &amp;quot;itemGuitar&amp;quot;,&#xA;        &amp;quot;description&amp;quot;: &amp;quot;Pete Townshend once played this guitar...&amp;quot;,&#xA;        &amp;quot;price&amp;quot;: 5695.99,&#xA;        &amp;quot;urls&amp;quot;: [&amp;quot;http://www.thewho.com&amp;quot;, &amp;quot;http://en.wikipedia.com/wiki/Pete_Townshend&amp;quot;]&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这种转换是标准的，转换前后也是相互等价的。接下来，就可以将这个字符串转换为JavaScript对象，可以调用eval()，就像这样：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;    var itemDetails = eval(&#39;(&#39; %2B jsonDataString %2B &#39;)&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;计算结果是一个普通的JavaScript对象，这个对象的属性和JSON数组的数据结构保持一致。当然，由于jsonDataString通常是由服务器返回的，通常需要这样来解析返回结果：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;    var itemDetails = eval(&#39;(&#39; %2B request.responseText %2B &#39;)&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这就是最最典型的JSON处理，但存在一个非常严重的问题。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;对实体代码微妙的破坏性&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;（译注：这个小标题着实让人费解，作者这里拐弯抹角的解释了Node的一个好处，就是前端和后端都采用同样的语言JavaScript，在作JSON解析时是无障碍的，而当前端使用JavaScript作JSON编码，后台用PHP作JSON解码时，多少会因为多种语言的JSON解析的实现不同而带来一些兼容性问题）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先，这类代码的一个主要问题是，它对解释器的依赖比较严重。在上个例子中，解释器就是指内置的JSON解析器或者实现解析JSON的代码，这实际上依赖了两样东西：和eval()解析响应文本的操作一样的基于Java的JSON解析器，以及基于PHP的JSON解析器。在PHP5.2.0中已经包含了JSON解析器，但却是以外部依赖的形式给出的，并不是内置于PHP的内核中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但这并不是大肆宣扬解释器的种种。毕竟解释器本身还存在很多问题，比如将“I”解析成了“i”，数组中的元素1解释成了2。当然，在JSON工具正式发布之前会有大量的测试，以保证在各种复杂场景中都不会出现错误，包括在客户端的解析结果和在服务器端的解析结果完全一致。无论如何，这都需要大量的测试才行。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不管怎样，JSON依然存在很多实际的问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;基于某种语言（基于JavaScript或者PHP）的JSON解析器选择是一个很大的问题。换句话说，问题不是在于“翻译”（translation）而在于“翻译器”（translator）（译注：作者的意思是说JSON本身的规则没有问题，反倒是各种语言的JSON实现的质量参差不齐，甚至有很多bug）。当一个语言的版本比较稳定时，基于这门语言的JSON解析器的运用和推广会比较快。结果是，JSON解析器变的越来越强大，以至于可以解析任意复杂的数据结构，即便这么复杂的数据结构根本不会实际用到。反之，每次迭代中（每次计算迭代的路径和数据类型的组合），也很有可能出现JSON解释器无法解析的数据结构（或者很深的JSON路径）的情况。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下图就是可选的JSON解释器&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://img03.taobaocdn.com/tps/i3/T1oR5lXnhoXXXXXXXX-500-292.jpg&#34; alt=&#34;img&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这并不是说JSON本身很糟糕，实际上，我们认为JSON的流行正是得益于其在新领域中的应用（译注：作者的言外之意是，在新领域中的初次JSON实现往往伴随很多问题）。对于新的领域，我们不禁要问：“这个新东东支持JSON吗？” 因此，JSON需要不断进化，需要不断的测试，不断的兼容新的平台。而作为程序员的，可能需要重新组织你的数据结构，或者等待新的版本出现以满足你的需求，或者干脆直接hack JSON。而这些正是我们所说的编程资源的浪费。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;假设你可以自己动手丰衣足食实现一个解释器，即便这样，你也没有通过“抄近道”拣到便宜，而是用JavaScript重复造轮子而已。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而Node则规避了此类问题，刚刚你读到的文字——关于内嵌JSON的PHP5.2.0、关于将对象转换为数组、关于采用新的结构组织数据的方式、关于JSON中新特性的实现——这一切扰人的问题在Node中都将不复存在，因为前端通过JavaScript作JSON编码，后台使用JavaScript作JSON解码，永远不会出问题。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;JavaScript中eval()的潜在隐患&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;正如我们不用将Node当作一门新的语言来对待一样，在Node中通过eval()来执行一段代码也和JavaScript中的eval()一样（不被推荐）。众所周知eval()是&lt;a href=&#34;http://stackoverflow.com/questions/86513/why-is-using-javascript-eval-function-a-bad-idea&#34;&gt;非常危险&lt;/a&gt;的。eval()用以执行一段文本表示的代码逻辑，可以理解为在文本框中“直接敲入SQL代码来执行查询”，这是不安全的，这实际上是恶意SQL注入。当每次eval()执行一段字符串的时候，（美国）中西部的一只小狗都会瑟瑟发抖，东部海滩上的某位母亲的脚趾会被刺伤并受到诅咒。eval()非常危险。网上有很多关于此的资料，这里不再赘述。可以用google查询“eval JavaScript evil”或者“eval JavaScript injection”获取更多信息。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当然，如果没有任何其他上下文的约束，在Node中也是允许使用eval()的，因此eval()的隐患在Node依然存在。毕竟Node的目的并不是完全解决eval()的问题。Node被称之为基于事件的JavaScript或基于事件的I/O，这里所说的“基于事件”是Node中非常重要的概念。但要彻底理解什么是基于事件，以及为什么基于事件能让你规避eval()的危险，则需要理解JSON在应用之中是如何工作的，此外还要搞清楚适应于web应用典型架构的特有数据结构。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;基于事件的web应用&#34; href=&#34;#基于事件的web应用&#34;&gt;&lt;/a&gt;基于事件的Web应用&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;传统的Web表单提交就是典型的基于事件的模式。换句话说，在Web表单里输入了很多数据（用户输入文本框，点选复选框，从列表中选中某些项等等），之后这些数据提交给服务器。这个场景中实际是一个单一的程序事件：使用POST方式将表单数据提交。这也是基于Ajax的Web应用的工作原理。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;一次性发送大量数据&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;对于Ajax来说，是可以和基于事件编程扯上一点关系。客户端和服务器端之间有些交互可以认为是基于事件的。典型的场景是输入一个省市代码，发送请求到服务器获得城市和省的名称。这里通过XmlHttpRequest的Ajax并不需要将很多数据一次性扔给服务器。但这并不能改变大部分web应用都是基于页面刷新这种模式的现状。Ajax已经更广泛的用于很多有意思的视觉相关的交互，快速的作表单验证，无刷新提交数据，这样就可以避免重新载入页面。因此，尽管并未通过提交表单来发起一个真正的POST请求，通过Ajax可以模拟POST表单提交。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;坦率的讲，这种传统的Ajax交互方式也阻碍了Ajax程序员的创新。每次发送一个请求时（不管请求的数据多么小），都会在网络里走一个来回。服务器必须针对这个请求作出响应，通常是开辟一个新的进程。因此，如果你真正置身于一个事件模型的环境中作开发，你可能需要通过发起10到15个单独的小请求来保持你的页面和服务器之间的联系，服务器也会为之创建10到15个线程（可能更少，这取决于服务器处理新请求时分配线程池的策略），当这个数量乘以1000或者10000或者100000时（译注：每个页面需要10个请求，那么越多用户访问这个页面，所发起的请求个数就会越来越多），就会出现内存溢出、逻辑交错带来的冲突、网络瘫痪、系统崩溃这些问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;结果是，在大多数场景中，Web应用需要保持对事件的最小依赖。有一个折衷方案，就是服务器端程序的响应返回的不是一个微小的数据片段，而是带有更多冗余数据结构的数据包，通常是JSON数据，这时就又遇到了eval()的问题。问题当然出在eval()身上，但这也和Web本身和服务器线程控制、包括页面和服务器之间的HTTP请求和响应策略（至少在这个场景下）有密不可分的关系。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;或许有些人对上文提到的问题不以为然，因为你知道有很多方法来规避直接eval()带来的问题，你会使用诸如&lt;a href=&#34;http://stackoverflow.com/questions/1843343/json-parse-vs-eval&#34;&gt;JSON.parse()&lt;/a&gt;来代替eval()。同样有很多&lt;a href=&#34;http://javascriptweblog.wordpress.com/2010/04/19/how-evil-is-eval/&#34;&gt;令人信服的论据&lt;/a&gt;鼓励我们小心的使用eval()。这些东东都是值得进一步讨论的。但不管怎样，看一看eval()带来了太多类似&lt;a href=&#34;http://stackoverflow.com/&#34;&gt;栈溢出（Stack Overflow）&lt;/a&gt;这类的问题吧，你会发现大部分程序员并未正确或者安全的使用eval()。这着实是一个问题。因为太多菜鸟程序员似乎根本没有意识到eval()的问题有多严重。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;不断的发送少量的数据&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Node带来了架构应用的新思路，我们可以基于Node采用事件模型来架构Web应用，或者说“小型的”事件模型。换句话说，你应当基于大量的事件发送大量的请求，每个请求的数据包都很小，或者根据需要从后台抓取少量数据，而不是发送很少的请求，每次请求都带有大量的数据。在很多场景中，大多数情况下你需要唤醒GUI程序（Java Swing程序员的GUI知识储备可以派上用场了）。因此，当用户输入姓氏和名字后，移步到下一个输入框，这时就已经发起了一个请求来验证输入的用户名是否已经存在。省市代码、地址和电话号码的验证也是同理。页面上每发生一个时间，都会产生一个请求和响应。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这有什么不同吗？为什么Node可以做到，并规避了已有的线程问题？其实Node并没有这么神秘，Node官网充分解释了其哲学：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Node的目标是提供一种构建可伸缩的网络应用的方案，在hello world例子中，服务器可以同时处理很多客户端连接。Node和操作系统有一种约定，如果创建了新的链接，操作系统就将通知Node，然后进入休眠。如果有人创建了新的链接，那么它（Node）执行一个回调，每一个链接只占用了非常小的（内存）堆栈开销。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Node是无阻塞的，不会出现同源竞争线程的情况（Node非常乐于处理即时的请求，发生了什么事情，那就让他发生吧），新请求到达服务器时，不需要为这个请求单独作什么事情。Node仅仅是悠闲的坐在那里等待（请求的发生），有请求就处理请求。用非常简单的代码就可以实现，而不用花费程序员宝贵的精力去实现一整套服务器端逻辑。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;没错，混乱不可避免&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;值得一提的是，非阻塞系统带来的问题也会出现在这种编程模式中：一个进程（非线程）等待一个数据存储操作，这时产生了另外一个抓取与之无关的数据的操作，这个意外的操作会对现有的等待造成影响（译注：作者的意思是说多个操作同时发生或者没有按照预定顺序发生时，会产生混乱，也就是说，操作本身并不是原子性的）。但要注意，大多数基于事件的web编程模式都是“只读的”！你大概也没有遇到过通过“微请求”来修改数据的情况，或者说非常罕见。相反，通过这种请求来验证数据合法性、查询数据的情形则非常常见。这种情况下，最好直接根据请求作响应。数据库本身会作加锁操作，一般来讲，一个优秀的数据库完全可以高效的做到数据操作的加锁解锁，而不用服务器端的程序代码去多做什么。而Node又比操作系统处理线程的保持和释放更加高效，使得服务器不必单独为“web响应”开辟一个进程。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此外，Node也计划实现“进程分支”（process forking），&lt;a href=&#34;http://www.whatwg.org/specs/web-apps/current-work/complete/workers.html&#34;&gt;HTML5 Web Workers API&lt;/a&gt;为更复杂的进程控制提供了引擎（规范）支持。同样，如果你采用基于事件的模型来架构web应用，你的程序可能至少有100多个场景需要线程的支持。最终你会发现，你的编程思路和思考问题的方式发生了改变，你的注意力将放在服务器端处理请求的逻辑上，而不必在乎Node如何工作。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;node的用武之地&#34; href=&#34;#node的用武之地&#34;&gt;&lt;/a&gt;Node的用武之地&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这里我们讨论另外一种web开发模式，不管是不是采用了Node、或者是不是采用了基于事件的编程模式，这都无关紧要，因为这种模式实在太重要了。简言之：对症下药！概括讲就是，针对不同的问题采取不同的解决方案，而不管这种解决方案是否解决其他问题。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;思维定势&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;不止在web设计领域，在所有编程之中都存在某种思维定势。可以这么描述这种思维定势：你学到的、掌握的越多，你能解决的问题就越多，你所掌握的技能的应用场景也就越多。这看起来理所当然，除非你在技术上钻研的更深。没错，学习新的语言和新的工具并广泛使用它总不是坏事。但往往会进入一个误区，就是，因为你了解它，所以你使用它，而不是因为你所掌握的技能和工具是“最适合”你的业务的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们来看一下Ajax，关于Ajax已经有太多太多的讨论了。我们知道，Ajax为无刷新的快速查询请求提供了可靠的解决方案。而如今因为Ajax的滥用以至于过分替代了传统的表单提交。我们遇到一个新技术、学习它、掌握它、应用它，然后“滥用它”。毕竟很多业务场景仅仅需要传统的表单提交，而不需要Ajax。说起来简单，实际上还有成千上万的滥用Ajax的案例场景，仅仅因为某个应用的开发工程师对Ajax的盲目尊崇。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同样的，Node也面临这样一个问题。当你初识Node发现它的种种好处，就想到处使用它。就会一股脑的将PHP或Perl程序换成Node。结果呢？糟透了。其实你已经害上了强迫症，总是想将Node用于有违其设计初衷的场景中：使用JavaScript提交大量数据给Node，或者通过Node返回给JavaScript大量的JSON数据，交给前端去作eval()，或者干脆使用Node作一个文件服务器用以返回HTML页面或做HTTP重定向。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但这些场景均不是Node所擅长的。Node更擅长处理体积小的请求以及基于事件的I/O，使用Node解决客户端和服务器之间的快速沟通，使用表单提交将大量的数据发送给服务器，使用PHP和Perl来处理重型数据库操作以及动态HTML页面的生成。使用Node运行于服务器端来处理体积不大的请求。不管是采用Rails还是Spring以及各式各样的服务端容器，只要按需索取即可。一定要明白你需要解决的问题是什么，基于此采取最佳解决方案，而不是基于你当下所掌握的技能来解决遇到的问题。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Node的简单的初衷&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;还有最后一点需要注意，当你越来越深入你的编程时，你会发现你不必每个工具、API和所使用的框架都达到精通。将刀用在刀刃上，不要将锤子当成钻头来使用。了解每个工具所适用的场景和能解决的问题，然后找到这个工具的最适合的应用场景。如果你想变成超人式的通才（程序员往往什么都想知道），你离“专家”也就越来越远，所谓专家，就是指在一两个方面达到非常精通。当然，每个老板都希望能找到超人式的通才，但这种人往往可遇不可求。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;学习Node可能会有些吃力，但是非常值得的。为什么？因为你正在寻求基于JavaScript的web应用的解决方案。这意味着你已有的JavaScript编程技能不会丢掉，当你需要使用PHP或者Perl时，你必须重新学习一门新的语言，而Node不必如此大动干戈。学习新语言带来的问题比学习他们带来的好处要大的多。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;学习Node所面临的挑战是，你需要更加活跃思维，将程序拆成低耦合的小片段，然后像组装数组一样的组装他们。但Node和基于事件的I/O并不能解决所有问题，但确定的是，很多关键问题，只能依靠Node来解决。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Dockerfile最佳实践</title>
      <link>http://prisoner.github.io/2013/12/30/Dockerfile%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html</link>
      <pubDate>2013-12-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Dockerfile提供了一个简单的语法来构建Image. 以下是几点技巧帮助你更好的使用Dockerfile.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;使用缓存&#34; href=&#34;#使用缓存&#34;&gt;&lt;/a&gt;使用缓存&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Dockerfile中的每一个操作都会提交一个更改到一个新的Image中, 并且这个Image会做为下一个操作的Base Image. 如果一个使用相同操作的Image存在, 那么这些操作不会执行, 而是直接使用这个Image.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;例如所有的Dockerfile都可以使用以下的共通代码.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;FROM ubuntu&#xA;MAINTAINER Michael Crosby &amp;lt;michael@crosbymichael.com&amp;gt;&#xA;&#xA;RUN echo &amp;quot;deb http://archive.ubuntu.com/ubuntu precise main universe&amp;quot; &amp;gt; /etc/apt/sources.list&#xA;RUN apt-get update&#xA;RUN apt-get upgrade -y&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;保持通用操作在Dockerfile顶部, 以使用缓存&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;使用标签&#34; href=&#34;#使用标签&#34;&gt;&lt;/a&gt;使用标签&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;除非仅仅是出于实验目的, 不然你应该使用&lt;code&gt;docker build -t&lt;/code&gt;命令来创建Image.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;总是使用参数&lt;code&gt;-t&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;暴露端口&#34; href=&#34;#暴露端口&#34;&gt;&lt;/a&gt;暴露端口&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;docker的两个重要特性是可重复利用和可移植. Image应该在任何主机上能运行多次. 所以你不应该在Dockerfile中指定公开端口. 如果Image的使用者需要指定公开端口, 他/她们会使用&lt;code&gt;-p&lt;/code&gt;参数的.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;不要在Dockerfile中指定公开端口&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;cmd和entrypoint语法&#34; href=&#34;#cmd和entrypoint语法&#34;&gt;&lt;/a&gt;CMD和ENTRYPOINT语法&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;CMD和ENTRYPOINT都有两种语法.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;CMD /bin/echo&#xA;# or&#xA;CMD [&amp;quot;/bin/echo&amp;quot;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;第一种语法在执行的时候, docker会将命令包装成&lt;code&gt;/bin/sh -c&lt;/code&gt;的形式. 这在有些情况下会产生一些难以发现的错误.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;CMD和ENTRYPOINT总是使用数组形式的语法&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;cmd和entrypoint更好的配合&#34; href=&#34;#cmd和entrypoint更好的配合&#34;&gt;&lt;/a&gt;CMD和ENTRYPOINT更好的配合&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;ENTRYPOINT可以让你docker化的程序像一个可执行程序一样运行. 你可以传递参数到ENTRYPOINT指定的命令中, 而不用担心在运行&lt;code&gt;docker run&lt;/code&gt;的时候会被覆盖. 有时ENTRYPOINT和CMD同时使用会有更好的效果. 例如&lt;a href=&#34;http://www.rethinkdb.com/&#34;&gt;Rethinkdb&lt;/a&gt;的Dockerfile.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# Dockerfile for Rethinkdb&#xA;# http://www.rethinkdb.com/&#xA;&#xA;FROM ubuntu&#xA;&#xA;MAINTAINER Michael Crosby &amp;lt;michael@crosbymichael.com&amp;gt;&#xA;&#xA;RUN echo &amp;quot;deb http://archive.ubuntu.com/ubuntu precise main universe&amp;quot; &amp;gt; /etc/apt/sources.list&#xA;RUN apt-get update&#xA;RUN apt-get upgrade -y&#xA;&#xA;RUN apt-get install -y python-software-properties&#xA;RUN add-apt-repository ppa:rethinkdb/ppa&#xA;RUN apt-get update&#xA;RUN apt-get install -y rethinkdb&#xA;&#xA;# Rethinkdb process&#xA;EXPOSE 28015&#xA;# Rethinkdb admin console&#xA;EXPOSE 8080&#xA;&#xA;# Create the /rethinkdb_data dir structure&#xA;RUN /usr/bin/rethinkdb create&#xA;&#xA;ENTRYPOINT [&amp;quot;/usr/bin/rethinkdb&amp;quot;]&#xA;&#xA;CMD [&amp;quot;--help&amp;quot;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;所有运行&lt;code&gt;docker run&lt;/code&gt;时传递的参数都会被传递到ENTRYPOINT指定的命令&lt;code&gt;/usr/bin/rethinkdb&lt;/code&gt;中, 当没有指定参数时使用CMD指定的&lt;code&gt;--help&lt;/code&gt;参数.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;运行&lt;code&gt;docker run crosbymichael/rethinkdb&lt;/code&gt;, 会输出:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Running &#39;rethinkdb&#39; will create a new data directory or use an existing one,&#xA;  and serve as a RethinkDB cluster node.&#xA;File path options:&#xA;  -d [ --directory ] path           specify directory to store data and metadata&#xA;  --io-threads n                    how many simultaneous I/O operations can happen&#xA;                                    at the same time&#xA;&#xA;Machine name options:&#xA;  -n [ --machine-name ] arg         the name for this machine (as will appear in&#xA;                                    the metadata).  If not specified, it will be&#xA;                                    randomly chosen from a short list of names.&#xA;&#xA;Network options:&#xA;  --bind {all | addr}               add the address of a local interface to listen&#xA;                                    on when accepting connections; loopback&#xA;                                    addresses are enabled by default&#xA;  --cluster-port port               port for receiving connections from other nodes&#xA;  --driver-port port                port for rethinkdb protocol client drivers&#xA;  -o [ --port-offset ] offset       all ports used locally will have this value&#xA;                                    added&#xA;  -j [ --join ] host:port           host and port of a rethinkdb node to connect to&#xA;  .................&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;而运行&lt;code&gt;docker run crosbymichael/rethinkdb --bind all&lt;/code&gt;, 会输出:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;info: Running rethinkdb 1.7.1-0ubuntu1~precise (GCC 4.6.3)...&#xA;info: Running on Linux 3.2.0-45-virtual x86_64&#xA;info: Loading data from directory /rethinkdb_data&#xA;warn: Could not turn off filesystem caching for database file: &amp;quot;/rethinkdb_data/metadata&amp;quot; (Is the file located on a filesystem that doesn&#39;t support direct I/O (e.g. some encrypted or journaled file systems)?) This can cause performance problems.&#xA;warn: Could not turn off filesystem caching for database file: &amp;quot;/rethinkdb_data/auth_metadata&amp;quot; (Is the file located on a filesystem that doesn&#39;t support direct I/O (e.g. some encrypted or journaled file systems)?) This can cause performance problems.&#xA;info: Listening for intracluster connections on port 29015&#xA;info: Listening for client driver connections on port 28015&#xA;info: Listening for administrative HTTP connections on port 8080&#xA;info: Listening on addresses: 127.0.0.1, 172.16.42.13&#xA;info: Server ready&#xA;info: Someone asked for the nonwhitelisted file /js/handlebars.runtime-1.0.0.beta.6.js, if this should be accessible add it to the whitelist.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;更好的配合使用CMD和ENTRYPOINT&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;原文: &lt;a href=&#34;http://crosbymichael.com/dockerfile-best-practices.html&#34;&gt;Dockerfile Best Practices&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参考:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.kstaken.com/blog/2013/07/06/how-to-use-entrypoint-in-a-dockerfile/&#34;&gt;How to Use Entrypoint in Docker Builder&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.docker.io/learn/dockerfile/level1/&#34;&gt;Dockerfile tutorial Level1&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.docker.io/learn/dockerfile/level2/&#34;&gt;Dockerfile tutorial Level2&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Docker发布0.7版本</title>
      <link>http://prisoner.github.io/2013/11/27/Docker%E5%8F%91%E5%B8%830.7%E7%89%88%E6%9C%AC.html</link>
      <pubDate>2013-11-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;轻量级容器工具Docker发布0.7版本. 新版本最大的亮点是带来了标准Linux支持, 不再需要特定的内核.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;新版本带来七个特性:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;标准Linux支持, 提供对Fedora, RHEL, Ubuntu, Debian, Suse, Gentoo, Arch, 等发行版的支持. 还是没有CentOS&amp;hellip;&lt;/li&gt;&#xA;&lt;li&gt;存储驱动. 之前的版本一直使用AUFS做为存储, 但是AUFS并不在Linux内核中. 所以只有少数发行版能直接支持Docker. 新的storage driver API改变了这一现状, 实现统一的存储驱动, 包含了对三种存储方式的支持: AUFS, VFS和DeviceMapper 的支持. 正在开发包括Btrfs和ZFS.&lt;/li&gt;&#xA;&lt;li&gt;离线传输. 使用离线传输, container images可以打包迁移到其它运行机器.&lt;/li&gt;&#xA;&lt;li&gt;改善的端口映射. 支持更复杂的端口映射. 同时调整了端口映射语法.&lt;/li&gt;&#xA;&lt;li&gt;容器连接. 允许各个容器进行通信. 详细:&lt;a href=&#34;http://docs.docker.io/en/latest/use/working_with_links_names/#links-service-discovery-for-docker&#34;&gt;Working with Links and Names&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;容器自定义名称.&lt;/li&gt;&#xA;&lt;li&gt;质量改善.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;详细请参考&lt;a href=&#34;http://blog.docker.io/2013/11/docker-0-7-docker-now-runs-on-any-linux-distribution/&#34;&gt;官方发布公告&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>什么是Flight组件</title>
      <link>http://prisoner.github.io/2013/10/31/%E4%BB%80%E4%B9%88%E6%98%AFFlight%E7%BB%84%E4%BB%B6.html</link>
      <pubDate>2013-10-31 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Twitter Flight是基于组件的. 那么什么是组件了?&#xA;组件是一块自我包含的原子的功能片段.&#xA;一个组件由三个部分组成:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;组件定义&lt;/li&gt;&#xA;&lt;li&gt;组件工厂&lt;/li&gt;&#xA;&lt;li&gt;组件实例&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;组件定义&#34; href=&#34;#组件定义&#34;&gt;&lt;/a&gt;组件定义&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;组件由一个命名方法定义. 包括定义事件监听器, 触发器, 默认配置和私有方法.&#xA;组件没有public的方法或成员变量. 所有与外界的交互使用事件来完成.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function heartbeat () {&#xA;  this.defaultAttrs({&#xA;    bpm: 80&#xA;  });&#xA;  this.beat = function () {&#xA;    this.trigger(&#39;heartbeat&#39;); // trigger heartbeat event&#xA;  };&#xA;  this.after(&#39;initialize&#39;, function () {&#xA;    setInterval(this.beat.bind(this), 60000/bpm);&#xA;  });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;组件工厂&#34; href=&#34;#组件工厂&#34;&gt;&lt;/a&gt;组件工厂&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Flight的&lt;code&gt;defineComponent&lt;/code&gt;方法接受一个组件定义函数并返回一个组件工厂.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;组件工厂用来创建组件实例并绑定到DOM.&lt;/li&gt;&#xA;&lt;li&gt;一个组件工厂可以创建无数组件实例,&#xA;但是只有一个实例可以绑定到一个DOM节点.&lt;/li&gt;&#xA;&lt;li&gt;组件实例化的时候可以覆盖默认配置.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;HeartBeat = defineComponent(heartbeat);&#xA;HeartBeat.attachTo(&#39;body&#39;);&#xA;HeartBeat.attachTo(&#39;#child&#39;, {&#xA;  bpm: 90&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;组件实例&#34; href=&#34;#组件实例&#34;&gt;&lt;/a&gt;组件实例&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用组件工厂的attachTo方法创建组件实例.&lt;/li&gt;&#xA;&lt;li&gt;attachTo不会返回实例的应用.&lt;/li&gt;&#xA;&lt;li&gt;组件实例可以和它绑定的DOM节点以及该节点的子节点交互.&lt;/li&gt;&#xA;&lt;li&gt;组件实例通过事件与外界交互.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function heartbeatMonitor () {&#xA;  this.handleHeartbeat = function () {&#xA;    console.log(&#39;Still alive.&#39;);&#xA;  };&#xA;  this.after(&#39;initialize&#39;, function () {&#xA;    this.on(&#39;heartbeat&#39;, this.handleHeartbeat);&#xA;  });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;本文翻译自&lt;a href=&#34;http://simplebutgood.net/what-is-a-flight-component/&#34;&gt;What is a Flight component?&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>二维码的生成细节和原理</title>
      <link>http://prisoner.github.io/2013/10/29/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E7%94%9F%E6%88%90%E7%BB%86%E8%8A%82%E5%92%8C%E5%8E%9F%E7%90%86.html</link>
      <pubDate>2013-10-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;二维码又称QR Code，QR全称Quick Response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar Code条形码能存更多的信息，也能表示更多的数据类型：比如：字符，数字，日文，中文等等。这两天学习了一下二维码图片生成的相关细节，觉得这个玩意就是一个密码算法，在此写一这篇文章 ，揭露一下。供好学的人一同学习之。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于QR Code Specification，可参看这个PDF：&lt;a href=&#34;http://raidenii.net/files/datasheets/misc/qr_code.pdf&#34;&gt;http://raidenii.net/files/datasheets/misc/qr_code.pdf&amp;nbsp;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;基础知识&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;首先，我们先说一下二维码一共有40个尺寸。官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x 25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：(V-1)*4 + 21（V是版本号） 最高Version 40，(40-1)*4+21 = 177，所以最高是177 x 177 的正方形。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面我们看看一个二维码的样例：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/QR-Code-Overview.jpeg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;span id=&#34;more-10590&#34;&gt;&lt;/span&gt;&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;定位图案&lt;/h5&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Position Detection Pattern是定位图案，用于标记二维码的矩形大小。这三个定位图案有白边叫Separators for Postion Detection Patterns。之所以三个而不是四个意思就是三个就可以标识一个矩形了。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Timing Patterns也是用于定位的。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Alignment Patterns 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h5&gt;功能性数据&lt;/h5&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Format Information 存在于所有的尺寸中，用于存放一些格式化数据的。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Version Information 在 &amp;gt;= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h5&gt;数据码和纠错码&lt;/h5&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;除了上述的那些地方，剩下的地方存放 Data Code 数据码 和 Error Correction Code 纠错码。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h4&gt;数据编码&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;我们先来说说数据编码。QR码支持如下的编码：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Numeric mode&lt;/strong&gt;&amp;nbsp;数字编码，从0到9。如果需要编码的数字的个数不是3的倍数，那么，最后剩下的1或2位数会被转成4或7bits，则其它的每3位数字会被编成 10，12，14bits，编成多长还要看二维码的尺寸（下面有一个表Table 3说明了这点）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Alphanumeric mode&lt;/strong&gt;&amp;nbsp;字符编码。包括 0-9，大写的A到Z（没有小写），以及符号$ % * + – . / : 包括空格。这些字符会映射成一个字符索引表。如下所示：（其中的SP是空格，Char是字符，Value是其索引值） 编码的过程是把字符两两分组，然后转成下表的45进制，然后转成11bits的二进制，如果最后有一个落单的，那就转成6bits的二进制。而编码模式和字符的个数需要根据不同的Version尺寸编成9, 11或13个二进制（如下表中Table 3）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Alphanumeric-mode.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Byte mode&lt;/strong&gt;, 字节编码，可以是0-255的ISO-8859-1字符。有些二维码的扫描器可以自动检测是否是UTF-8的编码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Kanji mode&lt;/strong&gt;&amp;nbsp;这是日文编码，也是双字节编码。同样，也可以用于中文编码。日文和汉字的编码会减去一个值。如：在0X8140 to 0X9FFC中的字符会减去8140，在0XE040到0XEBBF中的字符要减去0XC140，然后把前两位拿出来乘以0XC0，然后再加上后两位，最后转成13bit的编码。如下图示例：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Kanji-mode.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Extended Channel Interpretation (ECI) mode&lt;/strong&gt;&amp;nbsp;主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Structured Append mode&lt;/strong&gt;&amp;nbsp;用于混合编码，也就是说，这个二维码中包含了多种编码格式。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;FNC1 mode&lt;/strong&gt;&amp;nbsp;这种编码方式主要是给一些特殊的工业或行业用的。比如GS1条形码之类的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;简单起见，后面三种不会在本文 中讨论。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面两张表中，&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Table 2 是各个编码格式的“编号”，这个东西要写在Format Information中。注：中文是1101&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Table 3 表示了，不同版本（尺寸）的二维码，对于，数字，字符，字节和Kanji模式下，对于单个编码的2进制的位数。（在二维码的规格说明书中，有各种各样的编码规范表，后面还会提到）&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Mode-Indicator.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面我们看几个示例，&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;示例一：数字编码&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;在Version 1的尺寸下，纠错级别为H的情况下，编码： 01234567&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;把上述数字分成三组: 012 345 67&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;把他们转成二进制: &amp;nbsp;012 转成 0000001100； &amp;nbsp;345 转成 0101011001； &amp;nbsp;67 转成 1000011。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;把这三个二进制串起来: 0000001100 0101011001 1000011&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;把数字的个数转成二进制 (version 1-H是10 bits ):&amp;nbsp;8个数字的二进制是 0000001000&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;把数字编码的标志0001和第4步的编码加到前面: &amp;nbsp;0001 0000001000 0000001100 0101011001 1000011&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h5&gt;示例二：字符编码&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;在Version 1的尺寸下，纠错级别为H的情况下，编码: AC-42&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;从字符索引表中找到 AC-42 这五个字条的索引 (10,12,41,4,2)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;两两分组: (10,12) (41,4) (2)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;3.把每一组转成11bits的二进制:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(10,12) 10*45+12 等于 462 转成 00111001110&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(41,4) 41*45+4 等于 1849 转成 11100111001&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(2) 等于 2 转成 000010&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;把这些二进制连接起来：00111001110 11100111001 000010&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;把字符的个数转成二进制 (Version 1-H为9 bits ):&amp;nbsp;5个字符，5转成 000000101&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;在头上加上编码标识 0010 和第5步的个数编码: &amp;nbsp;0010 000000101 00111001110 11100111001 000010&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h4&gt;结束符和补齐符&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;假如我们有个HELLO WORLD的字符串要编码，根据上面的示例二，我们可以得到下面的编码，&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;编码&lt;/th&gt;&#xA;&lt;th&gt;字符数&lt;/th&gt;&#xA;&lt;th&gt;HELLO WORLD的编码&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;0010&lt;/td&gt;&#xA;&lt;td&gt;000001011&lt;/td&gt;&#xA;&lt;td&gt;01100001011 01111000110 10001011100 10110111000 10011010100 001101&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;我们还要加上结束符：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;编码&lt;/th&gt;&#xA;&lt;th&gt;字符数&lt;/th&gt;&#xA;&lt;th&gt;HELLO WORLD的编码&lt;/th&gt;&#xA;&lt;th&gt;结束&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;0010&lt;/td&gt;&#xA;&lt;td&gt;000001011&lt;/td&gt;&#xA;&lt;td&gt;01100001011 01111000110 10001011100 10110111000 10011010100 001101&lt;/td&gt;&#xA;&lt;td&gt;0000&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;h5&gt;按8bits重排&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;如果所有的编码加起来不是8个倍数我们还要在后面加上足够的0，比如上面一共有78个bits，所以，我们还要加上2个0，然后按8个bits分好组：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;00100000 &amp;nbsp; 01011011 &amp;nbsp; 00001011 &amp;nbsp; 01111000 &amp;nbsp; 11010001 &amp;nbsp; 01110010 &amp;nbsp; 11011100 &amp;nbsp; 01001101 &amp;nbsp; 01000011 &amp;nbsp; 010000&lt;span style=&#34;color: #ff0000;&#34;&gt;&lt;strong&gt;00&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;补齐码（Padding Bytes）&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;最后，如果如果还没有达到我们最大的bits数的限制，我们还要加一些补齐码（Padding Bytes），Padding Bytes就是重复下面的两个bytes：11101100 00010001 （这两个二进制转成十进制是236和17，我也不知道为什么，只知道Spec上是这么写的）关于每一个Version的每一种纠错级别的最大Bits限制，可以参看&lt;a href=&#34;http://raidenii.net/files/datasheets/misc/qr_code.pdf&#34;&gt;QR Code Spec&lt;/a&gt;的第28页到32页的Table-7一表。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;假设我们需要编码的是Version 1的Q纠错级，那么，其最大需要104个bits，而我们上面只有80个bits，所以，还需要24个bits，也就是需要3个Padding Bytes，我们就添加三个，于是得到下面的编码：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000&amp;nbsp;&lt;span style=&#34;color: #ff0000;&#34;&gt;&lt;strong&gt;11101100 00010001 11101100&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;纠错码&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;上面我们说到了一些纠错级别，Error Correction Code Level，二维码中有四种级别的纠错，这就是为什么二维码有残缺还能扫出来，也就是为什么有人在二维码的中心位置加入图标。&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;th colspan=&#34;2&#34;&gt;错误修正容量&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;L水平&lt;/td&gt;&#xA;&lt;td&gt;7%的字码可被修正&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;M水平&lt;/td&gt;&#xA;&lt;td&gt;15%的字码可被修正&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Q水平&lt;/td&gt;&#xA;&lt;td&gt;25%的字码可被修正&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;H水平&lt;/td&gt;&#xA;&lt;td&gt;30%的字码可被修正&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;那么，QR是怎么对数据码加上纠错码的？首先，我们需要对数据码进行分组，也就是分成不同的Block，然后对各个Block进行纠错编码，对于如何分组，我们可以查看&lt;a href=&#34;http://raidenii.net/files/datasheets/misc/qr_code.pdf&#34;&gt;QR Code Spec&lt;/a&gt;的第33页到44页的Table-13到Table-22的定义表。注意最后两列：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Number of Error Code Correction Blocks&lt;/strong&gt; ：需要分多少个块。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Error Correction Code Per Blocks&lt;/strong&gt;：每一个块中的code个数，所谓的code的个数，也就是有多少个8bits的字节。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Error-Correction-Blocks.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举个例子：上述的Version 5 + Q纠错级：需要4个Blocks（2个Blocks为一组，共两组），头一组的两个Blocks中各15个bits数据 + 各 9个bits的纠错码（注：表中的codewords就是一个8bits的byte）（再注：最后一例中的（c, k, r ）的公式为：c = k + 2 * r，因为后脚注解释了：纠错码的容量小于纠错码的一半）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下图给一个5-Q的示例（因为二进制写起来会让表格太大，所以，我都用了十进制）&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;组&lt;/th&gt;&#xA;&lt;th&gt;块&lt;/th&gt;&#xA;&lt;th&gt;数据&lt;/th&gt;&#xA;&lt;th&gt;对每个块的纠错码&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td style=&#34;text-align: center;&#34; rowspan=&#34;2&#34;&gt;1&lt;/td&gt;&#xA;&lt;td style=&#34;text-align: center;&#34;&gt;1&lt;/td&gt;&#xA;&lt;td&gt;67 85 70 134 87 38 85 194 119 50 6 18 6 103 38&lt;/td&gt;&#xA;&lt;td&gt;213 199 11 45 115 247 241 223 229 248 154 117 154 111 86 161 111 39&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td style=&#34;text-align: center;&#34;&gt;2&lt;/td&gt;&#xA;&lt;td&gt;246 246 66 7 118 134 242 7 38 86 22 198 199 146 6&lt;/td&gt;&#xA;&lt;td&gt;87 204 96 60 202 182 124 157 200 134 27 129 209 17 163 163 120 133&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td style=&#34;text-align: center;&#34; rowspan=&#34;2&#34;&gt;2&lt;/td&gt;&#xA;&lt;td style=&#34;text-align: center;&#34;&gt;1&lt;/td&gt;&#xA;&lt;td&gt;182 230 247 119 50 7 118 134 87 38 82 6 134 151 50 7&lt;/td&gt;&#xA;&lt;td&gt;148 116 177 212 76 133 75 242 238 76 195 230 189 10 108 240 192 141&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td style=&#34;text-align: center;&#34;&gt;2&lt;/td&gt;&#xA;&lt;td&gt;70 247 118 86 194 6 151 50 16 236 17 236 17 236 17 236&lt;/td&gt;&#xA;&lt;td&gt;235 159 5 173 24 147 59 33 106 40 255 172 82 2 131 32 178 236&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;注：二维码的纠错码主要是通过&lt;a href=&#34;http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction&#34;&gt;Reed-Solomon error correction&lt;/a&gt;（里德-所罗门纠错算法）来实现的。对于这个算法，对于我来说是相当的复杂，里面有很多的数学计算，比如：多项式除法，把1-255的数映射成2的n次方（0&amp;lt;=n&amp;lt;=255）的伽罗瓦域Galois Field之类的神一样的东西，以及基于这些基础的纠错数学公式，因为我的数据基础差，对于我来说太过复杂，所以我一时半会儿还有点没搞明白，还在学习中，所以，我在这里就不展开说这些东西了。还请大家见谅了。（当然，如果有朋友很明白，也繁请教教我）&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;最终编码&lt;/h4&gt;&#xA;&#xA;&lt;h5&gt;穿插放置&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;如果你以为我们可以开始画图，你就错了。二维码的混乱技术还没有玩完，它还要把数据码和纠错码的各个codewords交替放在一起。如何交替呢，规则如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于数据码：把每个块的第一个codewords先拿出来按顺度排列好，然后再取第一块的第二个，如此类推。如：上述示例中的Data Codewords如下：&lt;/p&gt;&#xA;&#xA;&lt;table class=&#34;coolshell&#34;&gt;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=&#34;head&#34;&gt;块 1&lt;/td&gt;&#xA;&lt;td&gt;67&lt;/td&gt;&#xA;&lt;td&gt;85&lt;/td&gt;&#xA;&lt;td&gt;70&lt;/td&gt;&#xA;&lt;td&gt;134&lt;/td&gt;&#xA;&lt;td&gt;87&lt;/td&gt;&#xA;&lt;td&gt;38&lt;/td&gt;&#xA;&lt;td&gt;85&lt;/td&gt;&#xA;&lt;td&gt;194&lt;/td&gt;&#xA;&lt;td&gt;119&lt;/td&gt;&#xA;&lt;td&gt;50&lt;/td&gt;&#xA;&lt;td&gt;6&lt;/td&gt;&#xA;&lt;td&gt;18&lt;/td&gt;&#xA;&lt;td&gt;6&lt;/td&gt;&#xA;&lt;td&gt;103&lt;/td&gt;&#xA;&lt;td&gt;38&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=&#34;head&#34;&gt;块 2&lt;/td&gt;&#xA;&lt;td&gt;246&lt;/td&gt;&#xA;&lt;td&gt;246&lt;/td&gt;&#xA;&lt;td&gt;66&lt;/td&gt;&#xA;&lt;td&gt;7&lt;/td&gt;&#xA;&lt;td&gt;118&lt;/td&gt;&#xA;&lt;td&gt;134&lt;/td&gt;&#xA;&lt;td&gt;242&lt;/td&gt;&#xA;&lt;td&gt;7&lt;/td&gt;&#xA;&lt;td&gt;38&lt;/td&gt;&#xA;&lt;td&gt;86&lt;/td&gt;&#xA;&lt;td&gt;22&lt;/td&gt;&#xA;&lt;td&gt;198&lt;/td&gt;&#xA;&lt;td&gt;199&lt;/td&gt;&#xA;&lt;td&gt;146&lt;/td&gt;&#xA;&lt;td&gt;6&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=&#34;head&#34;&gt;块 3&lt;/td&gt;&#xA;&lt;td&gt;182&lt;/td&gt;&#xA;&lt;td&gt;230&lt;/td&gt;&#xA;&lt;td&gt;247&lt;/td&gt;&#xA;&lt;td&gt;119&lt;/td&gt;&#xA;&lt;td&gt;50&lt;/td&gt;&#xA;&lt;td&gt;7&lt;/td&gt;&#xA;&lt;td&gt;118&lt;/td&gt;&#xA;&lt;td&gt;134&lt;/td&gt;&#xA;&lt;td&gt;87&lt;/td&gt;&#xA;&lt;td&gt;38&lt;/td&gt;&#xA;&lt;td&gt;82&lt;/td&gt;&#xA;&lt;td&gt;6&lt;/td&gt;&#xA;&lt;td&gt;134&lt;/td&gt;&#xA;&lt;td&gt;151&lt;/td&gt;&#xA;&lt;td&gt;50&lt;/td&gt;&#xA;&lt;td&gt;7&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=&#34;head&#34;&gt;块 4&lt;/td&gt;&#xA;&lt;td&gt;70&lt;/td&gt;&#xA;&lt;td&gt;247&lt;/td&gt;&#xA;&lt;td&gt;118&lt;/td&gt;&#xA;&lt;td&gt;86&lt;/td&gt;&#xA;&lt;td&gt;194&lt;/td&gt;&#xA;&lt;td&gt;6&lt;/td&gt;&#xA;&lt;td&gt;151&lt;/td&gt;&#xA;&lt;td&gt;50&lt;/td&gt;&#xA;&lt;td&gt;16&lt;/td&gt;&#xA;&lt;td&gt;236&lt;/td&gt;&#xA;&lt;td&gt;17&lt;/td&gt;&#xA;&lt;td&gt;236&lt;/td&gt;&#xA;&lt;td&gt;17&lt;/td&gt;&#xA;&lt;td&gt;236&lt;/td&gt;&#xA;&lt;td&gt;17&lt;/td&gt;&#xA;&lt;td&gt;236&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;我们先取第一列的：67， 246， 182， 70&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后再取第二列的：67， 246， 182， 70， 85，246，230 ，247&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如此类推：67， 246， 182， 70， 85，246，230 ，247 ……… &amp;nbsp;……… ，38，6，50，17，7，236&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于纠错码，也是一样：&lt;/p&gt;&#xA;&#xA;&lt;table class=&#34;coolshell&#34;&gt;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=&#34;head&#34;&gt;块 1&lt;/td&gt;&#xA;&lt;td&gt;213&lt;/td&gt;&#xA;&lt;td&gt;199&lt;/td&gt;&#xA;&lt;td&gt;11&lt;/td&gt;&#xA;&lt;td&gt;45&lt;/td&gt;&#xA;&lt;td&gt;115&lt;/td&gt;&#xA;&lt;td&gt;247&lt;/td&gt;&#xA;&lt;td&gt;241&lt;/td&gt;&#xA;&lt;td&gt;223&lt;/td&gt;&#xA;&lt;td&gt;229&lt;/td&gt;&#xA;&lt;td&gt;248&lt;/td&gt;&#xA;&lt;td&gt;154&lt;/td&gt;&#xA;&lt;td&gt;117&lt;/td&gt;&#xA;&lt;td&gt;154&lt;/td&gt;&#xA;&lt;td&gt;111&lt;/td&gt;&#xA;&lt;td&gt;86&lt;/td&gt;&#xA;&lt;td&gt;161&lt;/td&gt;&#xA;&lt;td&gt;111&lt;/td&gt;&#xA;&lt;td&gt;39&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=&#34;head&#34;&gt;块 2&lt;/td&gt;&#xA;&lt;td&gt;87&lt;/td&gt;&#xA;&lt;td&gt;204&lt;/td&gt;&#xA;&lt;td&gt;96&lt;/td&gt;&#xA;&lt;td&gt;60&lt;/td&gt;&#xA;&lt;td&gt;202&lt;/td&gt;&#xA;&lt;td&gt;182&lt;/td&gt;&#xA;&lt;td&gt;124&lt;/td&gt;&#xA;&lt;td&gt;157&lt;/td&gt;&#xA;&lt;td&gt;200&lt;/td&gt;&#xA;&lt;td&gt;134&lt;/td&gt;&#xA;&lt;td&gt;27&lt;/td&gt;&#xA;&lt;td&gt;129&lt;/td&gt;&#xA;&lt;td&gt;209&lt;/td&gt;&#xA;&lt;td&gt;17&lt;/td&gt;&#xA;&lt;td&gt;163&lt;/td&gt;&#xA;&lt;td&gt;163&lt;/td&gt;&#xA;&lt;td&gt;120&lt;/td&gt;&#xA;&lt;td&gt;133&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=&#34;head&#34;&gt;块 3&lt;/td&gt;&#xA;&lt;td&gt;148&lt;/td&gt;&#xA;&lt;td&gt;116&lt;/td&gt;&#xA;&lt;td&gt;177&lt;/td&gt;&#xA;&lt;td&gt;212&lt;/td&gt;&#xA;&lt;td&gt;76&lt;/td&gt;&#xA;&lt;td&gt;133&lt;/td&gt;&#xA;&lt;td&gt;75&lt;/td&gt;&#xA;&lt;td&gt;242&lt;/td&gt;&#xA;&lt;td&gt;238&lt;/td&gt;&#xA;&lt;td&gt;76&lt;/td&gt;&#xA;&lt;td&gt;195&lt;/td&gt;&#xA;&lt;td&gt;230&lt;/td&gt;&#xA;&lt;td&gt;189&lt;/td&gt;&#xA;&lt;td&gt;10&lt;/td&gt;&#xA;&lt;td&gt;108&lt;/td&gt;&#xA;&lt;td&gt;240&lt;/td&gt;&#xA;&lt;td&gt;192&lt;/td&gt;&#xA;&lt;td&gt;141&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=&#34;head&#34;&gt;块 4&lt;/td&gt;&#xA;&lt;td&gt;235&lt;/td&gt;&#xA;&lt;td&gt;159&lt;/td&gt;&#xA;&lt;td&gt;5&lt;/td&gt;&#xA;&lt;td&gt;173&lt;/td&gt;&#xA;&lt;td&gt;24&lt;/td&gt;&#xA;&lt;td&gt;147&lt;/td&gt;&#xA;&lt;td&gt;59&lt;/td&gt;&#xA;&lt;td&gt;33&lt;/td&gt;&#xA;&lt;td&gt;106&lt;/td&gt;&#xA;&lt;td&gt;40&lt;/td&gt;&#xA;&lt;td&gt;255&lt;/td&gt;&#xA;&lt;td&gt;172&lt;/td&gt;&#xA;&lt;td&gt;82&lt;/td&gt;&#xA;&lt;td&gt;2&lt;/td&gt;&#xA;&lt;td&gt;131&lt;/td&gt;&#xA;&lt;td&gt;32&lt;/td&gt;&#xA;&lt;td&gt;178&lt;/td&gt;&#xA;&lt;td&gt;236&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;和数据码取的一样，得到：213，87，148，235，199，204，116，159，…… ……&amp;nbsp;39，133，141，236&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后，再把这两组放在一起（纠错码放在数据码之后）得到：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;67, 246, 182, 70, 85, 246, 230, 247, 70, 66, 247, 118, 134, 7, 119, 86, 87, 118, 50, 194, 38, 134, 7, 6, 85, 242, 118, 151, 194, 7, 134, 50, 119, 38, 87, 16, 50, 86, 38, 236, 6, 22, 82, 17, 18, 198, 6, 236, 6, 199, 134, 17, 103, 146, 151, 236, 38, 6, 50, 17, 7, 236, 213, 87, 148, 235, 199, 204, 116, 159, 11, 96, 177, 5, 45, 60, 212, 173, 115, 202, 76, 24, 247, 182, 133, 147, 241, 124, 75, 59, 223, 157, 242, 33, 229, 200, 238, 106, 248, 134, 76, 40, 154, 27, 195, 255, 117, 129, 230, 172, 154, 209, 189, 82, 111, 17, 10, 2, 86, 163, 108, 131, 161, 163, 240, 32, 111, 120, 192, 178, 39, 133, 141, 236&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;Remainder Bits&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;最后再加上Reminder&amp;nbsp;Bits，对于某些Version的QR，上面的还不够长度，还要加上Remainder Bits，比如：上述的5Q版的二维码，还要加上7个bits，Remainder Bits加零就好了。关于哪些Version需要多少个Remainder bit，可以参看&lt;a href=&#34;http://raidenii.net/files/datasheets/misc/qr_code.pdf&#34;&gt;QR Code Spec&lt;/a&gt;的第15页的Table-1的定义表。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;画二维码图&lt;/h4&gt;&#xA;&#xA;&lt;h5&gt;Position Detection Pattern&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;首先，先把Position Detection图案画在三个角上。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/finder.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;Alignment Pattern&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;然后，再把Alignment图案画上&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/alignment-pattern.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于Alignment的位置，可以查看&lt;a href=&#34;http://raidenii.net/files/datasheets/misc/qr_code.pdf&#34;&gt;QR Code Spec&lt;/a&gt;的第81页的Table-E.1的定义表（下表是不完全表格）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Alignment-Position.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下图是根据上述表格中的Version8的一个例子（6，24，42）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/alignment-example.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;Timing Pattern&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;接下来是Timing Pattern的线（这个不用多说了）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Timing-Pattern.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;Format Information&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;再接下来是Formation Information，下图中的蓝色部分。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Format-Information.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Format Information是一个15个bits的信息，每一个bit的位置如下图所示：（注意图中的Dark Module，那是永远出现的）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Format-Info-bits-postion.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这15个bits中包括：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5个数据bits：其中，2个bits用于表示使用什么样的Error Correction Level， 3个bits表示使用什么样的Mask&lt;/li&gt;&#xA;&lt;li&gt;10个纠错bits。主要通过BCH Code来计算&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;然后15个bits还要与101010000010010做XOR操作。这样就保证不会因为我们选用了00的纠错级别，以及000的Mask，从重造成全部为白色，这会增加我们的扫描器的图像识别的困难。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面是一个示例：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Format-Information-Example.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于Error Correction Level如下表所示：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Error-Correction-Indicator-Code.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于Mask图案如后面的Table 23所示。&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;Version Information&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;再接下来是Version Information（版本7以后需要这个编码），下图中的蓝色部分。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Version-Information.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Version Information一共是18个bits，其中包括6个bits的版本号以及12个bits的纠错码，下面是一个示例：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Version-Information-Example.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而其填充位置如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Version-Information-Position.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;数据和数据纠错码&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;然后是填接我们的最终编码，最终编码的填充方式如下：从左下角开始沿着红线填我们的各个bits，1是黑色，0是白色。如果遇到了上面的非数据区，则绕开或跳过。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Data-Placement.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;掩码图案&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;这样下来，我们的图就填好了，但是，也许那些点并不均衡，所以，我们还要做Masking操作（靠，还嫌不复杂）QR的Spec中说了，QR有8个Mask你可以使用，如下所示：其中，各个mask的公式在各个图下面。所谓mask，说白了，就是和上面生成的图做XOR操作。Mask只会和数据区进行XOR，不会影响功能区。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/masking-pattern.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其Mask的标识码如下所示：（其中的i,j分别对应于上图的x,y）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Mask-Pattern-Code.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面是Mask后的一些样子，我们可以看到被某些Mask XOR了的数据变得比较零散了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://coolshell.cn//wp-content/uploads/2013/10/Masking-Examples.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Mask过后的二维码就成最终的图了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;好了，大家可以去尝试去写一下QR的编码程序，当然，你可以用网上找个Reed Soloman的纠错算法的库，或是看看别人的源代码是怎么实现这个繁锁的编码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;（全文完）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;转载自&lt;a href=&#34;http://coolshell.cn/&#34;&gt;酷壳&lt;/a&gt;, 原文&lt;a href=&#34;http://coolshell.cn/articles/10590.html&#34;&gt;链接&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>CoreOS介绍</title>
      <link>http://prisoner.github.io/2013/10/22/CoreOS%E4%BB%8B%E7%BB%8D.html</link>
      <pubDate>2013-10-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;ldquo;Linux for Massive Server Deployments&amp;rdquo; 这是&lt;a href=&#34;http://coreos.com/&#34;&gt;CoreOS&lt;/a&gt;官方对自己的介绍.&#xA;CoreOS被设计用做集群系统的大规模部署. 在linux世界里有大量的发行版可以做为服务器系统使用, 但是这些系统大多部署复杂, 更新系统更是困难重重. 这些都是CoreOS试图解决的问题.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CoreOS由几个部分组成:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最小化的Linux内核&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;CoreOS一个独特的设计是它拥有两个root分区. 一个被用作启动分区, 一个被用作更新分区. 系统更新将会被安装到更新分区, 并会自动切换. 在更新安装过程中, 为保证应用不会受到影响, CoreOS会使用Linux cgroups来限制磁盘 网络等IO使用. 详细请参考&lt;a href=&#34;http://coreos.com/using-coreos/updates/&#34;&gt;http://coreos.com/using-coreos/updates/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务发现组件 &lt;a href=&#34;https://github.com/coreos/etcd&#34;&gt;etcd&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;etcd负责节点间的服务发现和配置共享. etcd的目的是在你构建的服务的地方增加更多的机器和服务自动扩展变得非常的容易.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;容器管理 &lt;a href=&#34;http://www.docker.io/&#34;&gt;docker&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;CoreOS使用docker做为容器管理工具. CoreOS没有软件的包管理工具, 在CoreOS中运行的所有应用程序都要使用docker打包.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;系统服务管理 &lt;a href=&#34;http://zh.wikipedia.org/wiki/Systemd&#34;&gt;systemd&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;CoreOS使用systemd做为系统服务管理工具主要是因为下面几个原因:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;性能.&lt;/li&gt;&#xA;&lt;li&gt;日志. systemd有现代化的日志功能.&lt;/li&gt;&#xA;&lt;li&gt;同时采用socket 式与D-Bus 总线式激活服务.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;目前CoreOS并不是非常成熟, 如果想要尝试的话, 可以使用虚拟机进行安装实验.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;安装VirtualBox&lt;/li&gt;&#xA;&lt;li&gt;安装&lt;a href=&#34;/2013/08/30/vagrant.html&#34;&gt;Vagrant&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;运行:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;sh&#34;&gt;git clone https://github.com/coreos/coreos-vagrant/&#xA;cd coreos-vagrant&#xA;vagrant up&#xA;vagrant ssh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;登陆就可以使用CoreOS了. 详细使用可以参考&lt;a href=&#34;http://coreos.com/docs/vagrant/&#34;&gt;官方手册&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;参考链接:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.blogjava.net/yongboy/archive/2013/08/26/403325.html&#34;&gt;服务器操作系统CoreOS初体验&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;https://github.com/cloudcube/coreos-manual-chinese&#34;&gt;CoreOS 中文手册&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;http://www.sebastien-han.fr/blog/2013/09/03/first-glimpse-at-coreos/&#34;&gt;FIRST GLIMPSE AT COREOS&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;http://www.activestate.com/blog/2013/08/alex-polvi-explains-coreos&#34;&gt;Alex Polvi Explains CoreOS&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>开源的Linux Container</title>
      <link>http://prisoner.github.io/2013/10/16/%E5%BC%80%E6%BA%90%E7%9A%84Linux-Container.html</link>
      <pubDate>2013-10-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近比较关注Linux Container技术, 了解了几个开源的Linux Container. 下面做一些简单的介绍.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Docker&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.docker.io/static/img/docker-top-logo.png&#34; alt=&#34;Docker&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;主页: &lt;a href=&#34;http://www.docker.io/&#34;&gt;http://www.docker.io/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Docker是一个可以将任何应用包装在LXC中运行的开源项目.  当应用被打包成Docker Image后, 部署和运维就变得极其简单. 可以使用统一的方式 来下载,启动,扩展,删除,迁移.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Docker的常用场景:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自动打包和部署应用&lt;/li&gt;&#xA;&lt;li&gt;创建轻量级的私有PASS环境&lt;/li&gt;&#xA;&lt;li&gt;自动测试和持续集成环境&lt;/li&gt;&#xA;&lt;li&gt;部署和扩展web apps, databases 和 backend services&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Docker使用Golang开发, 可以在github上找到它的&lt;a href=&#34;https://github.com/dotcloud/docker/&#34;&gt;源代码&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Dokku&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;主页: &lt;a href=&#34;https://github.com/progrium/dokku&#34;&gt;https://github.com/progrium/dokku&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Dokku 是一个微型的 Heroku, 由 Docker 使用不多于 100 行的 Bash 编写.  完成安装后, 你就可以通过Git推送兼容Heroku 的应用到平台上运行. 该系统将使用 Heroku buildpacks 构建并在一个独立容器里运行, 最终结果就相当于是一个单机版的 Heroku.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Warden&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;主页: &lt;a href=&#34;https://github.com/cloudfoundry/warden&#34;&gt;https://github.com/cloudfoundry/warden&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;warden是cloudfoundry的核心组件之一.   warden的主要目的是提供一种简单的API来管理被隔离的容器，这种容器可以限制CPU, 内存, 存储, 网络等等资源. warden目前只支持linux. &lt;a href=&#34;http://blog.csdn.net/k_james/article/details/8523934&#34;&gt;这里&lt;/a&gt;有一篇使用介绍.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;lmctfy&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;主页: &lt;a href=&#34;https://github.com/google/lmctfy&#34;&gt;https://github.com/google/lmctfy&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;lmctfy是Google刚刚发布的Linux容器系统, 读音为lem-kut-fee. 目前项目还在密集开发中, 只提供了CPU与内存隔离. 按计划，lmctfy将提供磁盘IO和网络隔离, 名字空间, 根文件系统, 磁盘映像, 冻结层次和检查点恢复等, 规划还包括支持不同级别的服务质量, 监控和统计功能等.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Cells&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;主页: &lt;a href=&#34;http://systems.cs.columbia.edu/projects/cells/&#34;&gt;http://systems.cs.columbia.edu/projects/cells/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Cells是一个用于在一个物理设备上运行多个智能手机或平板的基于LXC的项目.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Mac环境下的JNI例子</title>
      <link>http://prisoner.github.io/2013/10/13/Mac%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84JNI%E4%BE%8B%E5%AD%90.html</link>
      <pubDate>2013-10-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Mac环境下的JNI例子&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Java可以通过JNI接口访问本地的动态连接库, 来调用C或者C++实现的功能.&#xA;使用Java JNI主要有几个步骤:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;编写Java代码 注明native方法.&lt;/li&gt;&#xA;&lt;li&gt;编译Java代码得到class文件.&lt;/li&gt;&#xA;&lt;li&gt;使用javah -jni生成该类对应的C语言头文件.&lt;/li&gt;&#xA;&lt;li&gt;使用C/C++实现头文件中声明的函数.&lt;/li&gt;&#xA;&lt;li&gt;编译C/C++实现代码, 生成动态连接库.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;下面是一个简单的例子&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;创建Java文件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;class HelloWorld {&#xA;    private native void print();&#xA;    public static void main(String[] args) {&#xA;        new HelloWorld().print();&#xA;    }&#xA;    static {&#xA;        System.loadLibrary(&amp;quot;HelloWorld&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编译Java代码&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;javac helloWorld.java&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生成C语言头文件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;javah -jni HelloWorld&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现头文件声明的函数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include &amp;lt;jni.h&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;quot;HelloWorld.h&amp;quot;&#xA;using namespace std;&#xA;&#xA;JNIEXPORT void JNICALL&#xA;Java_HelloWorld_print(JNIEnv *, jobject){&#xA;    cout &amp;lt;&amp;lt; &amp;quot;hello JNI\n&amp;quot;;&#xA;    return;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生成动态链接库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;编译C++代码的时候在MacOS下和在Linux Windows有所不同, 不是编译成.so或者dll, 而是MacOS自己的jnilib. 并且jni.h的目录也比较特殊, 是/System/Library/Frameworks/JavaVM.framework/Headers/, 这个需要稍微注意一下.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;命令:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;g++ -dynamiclib -o libhelloworld.jnilib HelloWorld.cpp -framework JavaVM -I/System/Library/Frameworks/JavaVM.framework/Headers&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一切成功后, 运行&lt;code&gt;java HelloWorld&lt;/code&gt;, 就可以看到输出&lt;code&gt;hello JNI&lt;/code&gt;了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;带参数和返回值的例子:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Java文件:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;class HelloWorld {&#xA;    private native String print(String str);&#xA;    public static void main(String[] args) {&#xA;        HelloWorld o = new HelloWorld();&#xA;        String str = o.print(&amp;quot;JNI&amp;quot;);&#xA;        System.out.println(str);&#xA;    }&#xA;    static {&#xA;        System.loadLibrary(&amp;quot;HelloWorld&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;实现:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include &amp;lt;jni.h&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;#include &amp;quot;HelloWorld.h&amp;quot;&#xA;using namespace std;&#xA;&#xA;JNIEXPORT jstring JNICALL&#xA;Java_HelloWorld_print(JNIEnv *env, jobject obj, jstring str){&#xA;  const char *cstr = env-&amp;gt;GetStringUTFChars(str, 0);&#xA;  char cap[128] = &amp;quot;hello &amp;quot;;&#xA;  strcat(cap, cstr);&#xA;  env-&amp;gt;ReleaseStringUTFChars(str, cstr);&#xA;  return env-&amp;gt;NewStringUTF(cap);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 1.2 Release Notes</title>
      <link>http://prisoner.github.io/2013/09/21/Go-1.2-Release-Notes.html</link>
      <pubDate>2013-09-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;http://tip.golang.org/doc/go1.2&#34;&gt;Go 1.2 Release Notes&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;nil的使用&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在Go 1.0中, 以下代码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type T struct {&#xA;    X [1&amp;lt;&amp;lt;24]byte&#xA;    Field int32&#xA;}&#xA;&#xA;func main() {&#xA;    var x *T&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;x.Field&lt;/code&gt;将会访问&lt;code&gt;1&amp;lt;&amp;lt;24&lt;/code&gt;指向的内存地址. 但是在Go 1.2中将会抛出&lt;code&gt;run-time panic&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;允许设置slice容量的新切片语法&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;var array [10]int&#xA;slice = array[2:4:6]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;slice的容量为6.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;godoc和vet移动到go.tools&lt;/h3&gt;&#xA;&#xA;&lt;h3&gt;gccgo的状态&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;将来GCC4.9能包含完整的Go1.2. 目前的GCC4.8.2包含Go1.1.2.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;cgo的变化&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;支持C++语法, 但是只支持C的导入符号. 详情参&lt;a href=&#34;http://tip.golang.org/cmd/cgo/&#34;&gt;http://tip.golang.org/cmd/cgo/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;支持测试覆盖率&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;通过安装&lt;code&gt;go get code.google.com/p/go.tools/cmd/cover&lt;/code&gt;, 可以获得一个支持测试覆盖率的工具.&#xA;使用:&#xA;&lt;code&gt;shell&#xA;$ go test -cover fmt&#xA;ok      fmt 0.060s  coverage: 91.4% of statements&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;删除go doc命令&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;godoc依然可以使用&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;go命令的变化&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;go get&lt;/code&gt;增加&lt;code&gt;-t&lt;/code&gt;参数, 用于下载包的测试用例.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;性能优化&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;compress/bzip2: 30%的性能提升&lt;/li&gt;&#xA;&lt;li&gt;crypto/des: 5倍的性能提升&lt;/li&gt;&#xA;&lt;li&gt;encoding/json: encoding 30% 的性能提升&lt;/li&gt;&#xA;&lt;li&gt;windows和BSD下, 网络和runtime的深度集成, 30% 的性能提升.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;标准库的变化&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;encoding: 新包, 提供通用的encoding接口&lt;/li&gt;&#xA;&lt;li&gt;fmt: 引入参数索引支持&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;参考资料:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://my.oschina.net/chai2010/blog/160143&#34;&gt;Go1.2新功能预览&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://mikespook.com/2013/08/%E7%BF%BB%E8%AF%91go-tip%EF%BC%882013-08-23%EF%BC%89%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%8F%98%E5%8C%96/&#34;&gt;翻译Go tip带来的变化&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>使用Supervisor管理进程</title>
      <link>http://prisoner.github.io/2013/09/17/%E4%BD%BF%E7%94%A8Supervisor%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B.html</link>
      <pubDate>2013-09-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Supervisor是用来管理和监控进程的工具. 有时候我们希望我们自己开发的程序也能做到随系统自动启动, 而且启动之后最好还能方便的控制其停止/重启.  并且在出现问题的时候能够自动重启.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一般我们可以在&lt;code&gt;/etc/init.d/&lt;/code&gt;下建立启动脚本, 但是启动脚本写起来比较繁琐, 并且不能自动重启.&#xA;这时候我们就可以使用Supervisor了.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;安装&#34; href=&#34;#安装&#34;&gt;&lt;/a&gt;安装&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;ubuntu系统下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install supervisor&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;配置&#34; href=&#34;#配置&#34;&gt;&lt;/a&gt;配置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;配置文件默认为&lt;code&gt;/etc/supervisord.conf&lt;/code&gt;. 如果要添加一个被管理的进程, 在该文件加入配置:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[program:test]&#xA;command=python path/to/test.py&#xA;autostart=true&#xA;autorestar=unexpected&#xA;stdout_logfile=path/to/log.log&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;[program:test] test是指定控制任务时使用的名称.&lt;/li&gt;&#xA;&lt;li&gt;command=python path/to/test.py 被控制的程序, 可以是任何命令&lt;/li&gt;&#xA;&lt;li&gt;autostart=true 是否随着supervisord启动而启动&lt;/li&gt;&#xA;&lt;li&gt;autorestar=unexpected 当进程死亡后, 是否重新启动进程&lt;/li&gt;&#xA;&lt;li&gt;stdout_logfile=path/to/log.log stdout输出的日子文件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;配置文件更改后, 需要执行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo supervisorctl update&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;来更新配置&lt;/p&gt;&#xA;&#xA;&lt;p&gt;更多详细配置可以参考&lt;a href=&#34;http://supervisord.org/configuration.html#program-x-section-values&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;使用&#34; href=&#34;#使用&#34;&gt;&lt;/a&gt;使用&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Supervisor安装后有两个可执行命令:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;supervisord 后台守护进程&lt;/li&gt;&#xA;&lt;li&gt;supervisorctl 控制程序, 用来向守护进程发送命令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;supervisorctl命令:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;supervisorctl status test 查看test的状态&lt;/li&gt;&#xA;&lt;li&gt;supervisorctl start test 启动test&lt;/li&gt;&#xA;&lt;li&gt;supervisorctl stop test 停止test&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;更多命令请参考: &lt;code&gt;supervisorctl help&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;web客户端&#34; href=&#34;#web客户端&#34;&gt;&lt;/a&gt;web客户端&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在配置中有一段&lt;code&gt;[inet_http_server]&lt;/code&gt;,  配置好后就打开&lt;code&gt;127.0.0.1:9001&lt;/code&gt;, 就可以看到一个网页版控制界面了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;配置:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[inet_http_server]&#xA;port = 127.0.0.1:9001&#xA;username = user&#xA;password = 123&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>LXC介绍</title>
      <link>http://prisoner.github.io/2013/09/16/LXC%E4%BB%8B%E7%BB%8D.html</link>
      <pubDate>2013-09-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;LXC(Linux containers): Linux容器. 网上介绍都说lxc是一种虚拟化技术. 但是我觉得lxc更多的是一种资源的控制和隔离工具.&#xA;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;The linux containers, lxc, aims to use these new functionalities to provide&#xA;an userspace container object which provides full resource isolation&#xA;and resource control for an applications or a system.&#xA;&amp;nbsp;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;以上是&lt;a href=&#34;https://github.com/lxc/lxc&#34;&gt;lxc官方&lt;/a&gt;的介绍. 可见lxc是一种将系统资源按照类型和需求分割给多个对象独立使用, 对象之间保持隔离的工具. 系统资源通常指CPU、内存、网卡、磁盘等.&#xA;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于lxc并不需要对硬件进行模拟并且lxc容器与主机共享内核和一些其它资源,  这也使得lxc非常的轻量级.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&#xA;使用lxc运行应用有以下好处:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&#xA;* &lt;strong&gt;安全&lt;/strong&gt; 因为应用都运行在被隔离的各个不同容器中, 一个容器或容器中的应用出现问题, 并不会影响到其它容器.&#xA;* &lt;strong&gt;便携性&lt;/strong&gt; 容器可以打包并部署到其它相同cpu架构的机器上.&#xA;* &lt;strong&gt;可控性&lt;/strong&gt; 容器能使用的资源都可以进行限制.&#xA;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当然lxc的机制也有不足的地方.&#xA;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;lxc的使用场景比较适合应用的运行, 而不适合需要完全掌控系统的场景. 另外, lxc不支持不同的cpu体系结构. 也就是说64位的容器不能运行在32位机器上.&#xA;lxc对资源的控制和隔离是基于chroot和Cgroups的.&#xA;chroot(change root directory). 在 linux系统中, 默认的目录结构都是以根(root) 开始的. 而使用 chroot, 可以设置将系统的目录结构以指定的位置做为&amp;rsquo;/&amp;lsquo;的位置.  因为linux中一切都是基于文件的(比如/proc 就是所有的进程所在的目录). 所以可以说, chroot相当于启动了一个非常简单的被隔离的容器. 如果再为每个容器加上自己的上下文,进程和网络, 那么就可以做到真正的资源隔离了.&#xA;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Cgroups(control groups)是Linux内核提供的一种可以限制,记录,隔离进程组(process groups)所使用的物理资源(如:cpu,内存,IO等等)的机制.&#xA;Cgroups提供了以下功能:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;限制进程组可以使用的资源数量&lt;/li&gt;&#xA;&lt;li&gt;进程组的优先级控制&lt;/li&gt;&#xA;&lt;li&gt;记录进程组使用的资源数量&lt;/li&gt;&#xA;&lt;li&gt;进程组隔离&lt;/li&gt;&#xA;&lt;li&gt;进程组控制&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Vagrant中的VirtualBox配置</title>
      <link>http://prisoner.github.io/2013/09/13/Vagrant%E4%B8%AD%E7%9A%84VirtualBox%E9%85%8D%E7%BD%AE.html</link>
      <pubDate>2013-09-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;VirtualBox provider暴露了一些额外的配置项可以用于配置VirtualBox选项.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;配置虚拟机名称&#34; href=&#34;#配置虚拟机名称&#34;&gt;&lt;/a&gt;配置虚拟机名称&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;ruby&#34;&gt;config.vm.provider &amp;quot;virtualbox&amp;quot; do |v|&#xA;  v.name = &amp;quot;my_vm&amp;quot;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;配置是否使用headless模式&#34; href=&#34;#配置是否使用headless模式&#34;&gt;&lt;/a&gt;配置是否使用headless模式&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Vagrant默认使用VirtualBox的headless模式. 如果需要也可以设置不使用.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;ruby&#34;&gt;config.vm.provider &amp;quot;virtualbox&amp;quot; do |v|&#xA;  v.gui = true&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;vboxmanage设置&#34; href=&#34;#vboxmanage设置&#34;&gt;&lt;/a&gt;VBoxManage设置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Vagrant可以使用&lt;a href=&#34;http://www.virtualbox.org/manual/ch08.html&#34;&gt;VBoxManage&lt;/a&gt;进行一些额外的配置.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;ruby&#34;&gt;config.vm.provider &amp;quot;virtualbox&amp;quot; do |v|&#xA;  v.customize [&amp;quot;modifyvm&amp;quot;, :id, &amp;quot;--cpuexecutioncap&amp;quot;, &amp;quot;50&amp;quot;]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;配置中的&lt;code&gt;:id&lt;/code&gt;会在创建虚拟机时使用实际的虚拟机ID替换.&lt;/li&gt;&#xA;&lt;li&gt;数组中的所有参数会被组合做为VBoxManage的参数传入.&lt;/li&gt;&#xA;&lt;li&gt;如果有多个&lt;code&gt;customize&lt;/code&gt;, 会被按顺序执行.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;详细的可供修改参数请参考&lt;a href=&#34;http://www.virtualbox.org/manual/ch08.html&#34;&gt;VBoxManage&lt;/a&gt;, 以下是一些常用参数.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;modifyvm 使用的参数:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&amp;ndash;ostype &lt;ostype&gt;: 指定虚拟机的类型. 类型可以使用&lt;code&gt;VBoxManage list ostypes&lt;/code&gt;查看.&lt;/li&gt;&#xA;&lt;li&gt;&amp;ndash;memory &lt;memorysize&gt;: 指定虚拟机使用的内存, 单位是MB.&lt;/li&gt;&#xA;&lt;li&gt;&amp;ndash;vram &lt;vramsize&gt;: 指定显卡使用的内存.&lt;/li&gt;&#xA;&lt;li&gt;&amp;ndash;cpus &lt;cpucount&gt;: 指定使用cpu的个数.&lt;/li&gt;&#xA;&lt;li&gt;&amp;ndash;rtcuseutc on|off: 指定硬件时钟使用UTC.&lt;/li&gt;&#xA;&lt;li&gt;&amp;ndash;cpuexecutioncap &lt;1-100&gt;: 设置虚拟机使用cpu的运行峰值.&lt;/li&gt;&#xA;&lt;li&gt;&amp;ndash;boot&lt;1-4&gt; none|floppy|dvd|disk|net: 指定启动设备.&lt;/li&gt;&#xA;&lt;li&gt;&amp;ndash;snapshotfolder default|&lt;path&gt;: 指定snapshot保存目录.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Java 8全面解析</title>
      <link>http://prisoner.github.io/2013/09/01/Java-8%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90.html</link>
      <pubDate>2013-09-01 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;转载自:&lt;a href=&#34;http://www.infoq.com/cn/news/2013/08/everything-about-java-8&#34;&gt;InfoQ&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;TechEmpower是位于加利福尼亚州埃尔塞贡多的一家定制应用开发公司，该公司发表了一篇题为“&lt;a href=&#34;http://www.techempower.com/blog/2013/03/26/everything-about-java-8/&#34;&gt;Java 8全面解析&lt;/a&gt;”的博客文章。该博客文章全面概括了开发者在即将到来的Java 8中所要面对的变化。下面的内容快速概括了该博客文章中的信息。如果想查看所有的细节请访问TechEmpower的博客文章。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;改进接口&#34; href=&#34;#改进接口&#34;&gt;&lt;/a&gt;改进接口&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;现在可以在接口中定义静态方法了。例如，&lt;code&gt;java.util.Comparator&lt;/code&gt;接口中现在拥有一个静态的&lt;code&gt;naturalOrder&lt;/code&gt;方法。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public static &amp;lt;T extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; Comparator &amp;lt;T&amp;gt;naturalOrder() {&#xA;  return (Comparator&amp;lt;T&amp;gt;) Cmparators.NaturalOrderComparator.INSTANCE;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;还能够在接口中提供默认方法。通过该功能，程序员能够在不破坏已有的接口实现代码的前提下添加新方法。例如，java.lang.Iterable接口现在拥有一个默认的forEach方法。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public default void forEach(Consumer&amp;lt;? super T&amp;gt; action) {&#xA;  Objects.requireNonNull(action);&#xA;  for (T t : this) {&#xA;    action.accept(t);&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意，接口不能为Object类中的任何方法提供默认的实现。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;函数式接口&#34; href=&#34;#函数式接口&#34;&gt;&lt;/a&gt;函数式接口&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;函数式接口是只定义了一个抽象方法的接口。Java 8引入了&lt;a href=&#34;http://download.java.net/jdk8/docs/api/java/lang/FunctionalInterface.html&#34;&gt;FunctionalInterface&lt;/a&gt;注解来表明一个接口打算成为一个函数式接口。例如，java.lang.Runnable就是一个函数式接口。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@FunctionalInterface&#xA;public interface Runnable {&#xA;  public abstract void run();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意，不管FunctionalInterface注解是否存在，Java编译器都会将所有满足该定义的接口看作是函数式接口。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;lambda&#34; href=&#34;#lambda&#34;&gt;&lt;/a&gt;Lambda&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;函数式接口的重要属性是：我们能够使用lambda实例化它们，Lambda表达式让你能够将函数作为方法参数，或者将代码作为数据对待。下面是Lambda的一些例子。输入在左边，代码在右边。输入类型能够被推断出来，同时是可选的。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;(int x, int y) -&amp;gt;{ return x + y; }&#xA;(x, y) -&amp;gt; x + y&#xA;x -&amp;gt; x * x&#xA;() -&amp;gt; x&#xA;x -&amp;gt; { System.out.println(x); }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;下面是实例化Runnable函数式接口的一个例子。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;Runnable r = () -&amp;gt;{ System.out.println(&amp;quot;Running!&amp;quot;); }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;方法引用&#34; href=&#34;#方法引用&#34;&gt;&lt;/a&gt;方法引用&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html&#34;&gt;方法引用&lt;/a&gt;&#xA;是简洁的Lambda表达式，能够用于已经拥有名称的方法。下面是一些方法引用的例子，右边是同样效果的Lambda表达式。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;String::valueOf x -&amp;gt;String.valueOf(x)&#xA;Object::toString x -&amp;gt;x.toString()&#xA;x::toString () -&amp;gt;x.toString()&#xA;ArrayList::new () -&amp;gt; new ArrayList&amp;lt;&amp;gt;()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;与捕获相对的非捕获lambda&#34; href=&#34;#与捕获相对的非捕获lambda&#34;&gt;&lt;/a&gt;与捕获相对的非捕获Lambda&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;如果使用Lambda表达式访问一个在Lambda语句体外定义的非静态变量或者对象，那么它会被说成是“捕获”。&#xA;例如，下面的Lambda会访问变量x:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;int x = 5;&#xA;return y -&amp;gt; x + y;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一个Lambda表达式仅能够访问final或者有效final封闭块中的局部变量和参数。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java.util.function&#34; href=&#34;#java.util.function&#34;&gt;&lt;/a&gt;java.util.function&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;新版本向 &lt;a href=&#34;http://download.java.net/jdk8/docs/api/java/util/function/package-summary.html&#34;&gt;java.util.function&lt;/a&gt;包中添加了很多新的函数式接口。下面是一些例子：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Function&lt;T, R&gt;——将T作为输入，返回R作为输出&lt;/li&gt;&#xA;&lt;li&gt;Predicate&lt;T&gt;——将T作为输入，返回一个布尔值作为输出&lt;/li&gt;&#xA;&lt;li&gt;Consumer&lt;T&gt;——将T作为输入，不返回任何内容&lt;/li&gt;&#xA;&lt;li&gt;Supplier&lt;T&gt;——没有输入，返回T&lt;/li&gt;&#xA;&lt;li&gt;BinaryOperator&lt;T&gt;——将两个T作为输入，返回一个T作为输出&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java.util.stream&#34; href=&#34;#java.util.stream&#34;&gt;&lt;/a&gt;java.util.stream&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;新的 &lt;a href=&#34;http://download.java.net/jdk8/docs/api/java/util/stream/package-summary.html&#34;&gt;java.util.stream&lt;/a&gt;包提供了对值流进行函数式操作的类。从一个集合中获取流的一种常见方式是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;Stream&amp;lt;T&amp;gt; stream = collection.stream();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;下面是一个来自于Javadocs包中的例子。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;intsumOfWeights = blocks.stream().filter(b -&amp;gt;b.getColor() == RED).mapToInt(b -&amp;gt;b.getWeight()).sum();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在该例子中我们首先使用了一个块集合作为流的来源，然后在流上执行了filter-map-reduce操作获取红块重量的和。&#xA;流可以是无限的、有状态的，可以是顺序的，也可以是并行的。&#xA;在使用流的时候，你首先需要从一些来源中获取一个流，执行一个或者多个中间操作，然后执行一个最终操作。&#xA;中间操作包括filter、map、flatMap、peel、distinct、sorted、limit和substream。&#xA;终止操作包括forEach、toArray、reduce、collect、min、max、count、anyMatch、allMatch、noneMatch、findFirst和findAny。&#xA;&lt;a href=&#34;http://download.java.net/jdk8/docs/api/java/util/stream/Collectors.html&#34;&gt;java.util.stream.Collectors&lt;/a&gt;是一个非常有用的实用类。&#xA;该类实现了很多归约操作，例如将流转换成集合和聚合元素。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;改进了泛型推断&#34; href=&#34;#改进了泛型推断&#34;&gt;&lt;/a&gt;改进了泛型推断&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这提升了Java编译器推断泛型和在泛型方法调用中减少显式类型参数的能力。在Java 7中，代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;foo(Utility.&amp;lt;Type&amp;gt;bar());&#xA;Utility.&amp;lt;Type&amp;gt;foo().bar();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在Java 8中，改进后的参数和调用链推断让你能够按照下面的方式编写代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;foo(Utility.bar());&#xA;Utility.foo().bar();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java.time&#34; href=&#34;#java.time&#34;&gt;&lt;/a&gt;java.time&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;新的日期/时间API包含在 &lt;a href=&#34;http://download.java.net/jdk8/docs/api/java/time/package-summary.html&#34;&gt;java.time&lt;/a&gt;包中。所有的类都是不可变且线程安全的。日期和时间类型包括Instant、LocalDate、LocalTime、LocalDateTime和ZonedDateTime。除了日期和时间之外，还有Duration和Period类型。另外，值类型包括Month、DayOfWeek、Year、 Month、YearMonth、MonthDay、OffsetTime和OffsetDateTime。这些新的日期/时间类大部分JDBC都支持。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;新增集合API&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接口可以拥有默认函数的能力让Java 8得以向集合API中添加大量的新方法。所有的接口都提供了默认的实现，而更加有效的实现则是被添加到了具体的类中。下面是新方法的列表：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Iterable.forEach(Consumer)&lt;/li&gt;&#xA;&lt;li&gt;Iterator.forEachRemaining(Consumer)&lt;/li&gt;&#xA;&lt;li&gt;Collection.removeIf(Predicate)&lt;/li&gt;&#xA;&lt;li&gt;Collection.spliterator()&lt;/li&gt;&#xA;&lt;li&gt;Collection.stream()&lt;/li&gt;&#xA;&lt;li&gt;Collection.parallelStream()&lt;/li&gt;&#xA;&lt;li&gt;List.sort(Comparator)&lt;/li&gt;&#xA;&lt;li&gt;List.replaceAll(UnaryOperator)&lt;/li&gt;&#xA;&lt;li&gt;Map.forEach(BiConsumer)&lt;/li&gt;&#xA;&lt;li&gt;Map.replaceAll(BiFunction)&lt;/li&gt;&#xA;&lt;li&gt;Map.putIfAbsent(K, V)&lt;/li&gt;&#xA;&lt;li&gt;Map.remove(Object, Object)&lt;/li&gt;&#xA;&lt;li&gt;Map.replace(K, V, V)&lt;/li&gt;&#xA;&lt;li&gt;Map.replace(K, V)&lt;/li&gt;&#xA;&lt;li&gt;Map.computeIfAbsent(K, Function)&lt;/li&gt;&#xA;&lt;li&gt;Map.computeIfPresent(K, BiFunction)&lt;/li&gt;&#xA;&lt;li&gt;Map.compute(K, BiFunction)&lt;/li&gt;&#xA;&lt;li&gt;Map.merge(K, V, BiFunction)&lt;/li&gt;&#xA;&lt;li&gt;Map.getOrDefault(Object, V)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;新增并发api&#34; href=&#34;#新增并发api&#34;&gt;&lt;/a&gt;新增并发API&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java 8还向并发API中添加了一些新内容，我们将会在此简要介绍其中的一部分。&#xA;&lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;是处理所有并行流操作的结构。&#xA;没有明确提交到某个特定池中的所有&lt;code&gt;ForkJoinTask&lt;/code&gt;都将会使用通用池。&#xA;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;已经被完全重写。&#xA;&lt;code&gt;StampedLock&lt;/code&gt;是一个新的锁实现，它可以作为&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;的一个备选方案。&#xA;&lt;code&gt;CompletableFuture&lt;/code&gt;是&lt;code&gt;Future&lt;/code&gt;接口的一个实现，它为异步任务的执行和链接提供了方法。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;新增io/nio-api&#34; href=&#34;#新增io/nio-api&#34;&gt;&lt;/a&gt;新增IO/NIO API&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在Java 8中有一些新的IO/NIO方法，我们能够使用它们从文件或者输入流中获取&lt;code&gt;java.util.stream.Stream&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;BufferedReader.lines()&lt;/li&gt;&#xA;&lt;li&gt;Files.list(Path)&lt;/li&gt;&#xA;&lt;li&gt;Files.walk(Path, int, FileVisitOption&amp;hellip;)&lt;/li&gt;&#xA;&lt;li&gt;Files.walk(Path, FileVisitOption&amp;hellip;)&lt;/li&gt;&#xA;&lt;li&gt;Files.find(Path, int, BiPredicate, FileVisitOption&amp;hellip;)&lt;/li&gt;&#xA;&lt;li&gt;Files.lines(Path, Charset)&lt;/li&gt;&#xA;&lt;li&gt;DirectoryStream.stream()&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;这里面有一个新的&lt;code&gt;UncheckedIOException&lt;/code&gt;，它是一个继承了&lt;code&gt;RuntimetimeException&lt;/code&gt;的&lt;code&gt;IOException&lt;/code&gt;。&#xA;还有一个&lt;code&gt;CloseableStream&lt;/code&gt;，它是一个能够并且应该被关闭的流。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;反射和注解的变化&#34; href=&#34;#反射和注解的变化&#34;&gt;&lt;/a&gt;反射和注解的变化&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;通过&lt;a href=&#34;http://types.cs.washington.edu/jsr308/&#34;&gt;类型注解&lt;/a&gt;，我们能够在更多的地方使用注解，&#xA;例如像&lt;code&gt;List&amp;lt;@Nullable String&amp;gt;&lt;/code&gt;这样的泛型参数中。&#xA;这增强了通过静态分析工具发现错误的能力，它将增强并重定义Java内置的类型系统。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;nashorn-javascript引擎&#34; href=&#34;#nashorn-javascript引擎&#34;&gt;&lt;/a&gt;Nashorn JavaScript引擎&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Nashorn是一个集成到JDK中的新的、轻量级、高性能的JavaScript实现。&#xA;Nashorn是Rhino的继任者，它提升了性能和内存使用情况。&#xA;它将会支持&lt;code&gt;javax.script API&lt;/code&gt;，但是它并不会支持DOM/CSS，也不会包含浏览器插件API。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java.lang、java.util等其他地方的新增功能&#34; href=&#34;#java.lang、java.util等其他地方的新增功能&#34;&gt;&lt;/a&gt;java.lang、java.util等其他地方的新增功能&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java 8还向很多其他的包中添加了大量其他的功能，在本文中我们并没有提及。&#xA;下面是一些值得注意的内容。可以使用ThreadLocal.withInitial(Supplier)更加简洁的声明本地线程变量。&#xA;长期未兑现的StringJoiner和String.join(&amp;hellip;)现在已经是Java 8的一部分了。&#xA;比较器提供了一些新的方法能够用于链接和基于域的比较。默认的字符串池映射大小更大了，大约在25—50K。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果想要获取更加详细的介绍可以访问博客文章&lt;a href=&#34;http://www.techempower.com/blog/2013/03/26/everything-about-java-8/&#34;&gt;Java 8全面解析&lt;/a&gt;。该博客文章的最后一次更新时间是2013年5月29日。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;查看英文原文&lt;/strong&gt;：&lt;a href=&#34;http://www.infoq.com/news/2013/08/everything-about-java-8&#34;&gt;Everything About Java 8&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>vagrant介绍</title>
      <link>http://prisoner.github.io/2013/08/30/vagrant%E4%BB%8B%E7%BB%8D.html</link>
      <pubDate>2013-08-30 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;vagrant介绍&#34; href=&#34;#vagrant介绍&#34;&gt;&lt;/a&gt;vagrant介绍&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Vagrant是一个使用ruby编写基于VirtualBox的, 用于创建和配置轻量级的 可重用的 便携的虚拟化开发环境的工具.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以满足以下需求:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;创建隔离依赖的开发环境&lt;/li&gt;&#xA;&lt;li&gt;创建可重用的干净的测试环境&lt;/li&gt;&#xA;&lt;li&gt;创建可重用的工作流程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;安装&#34; href=&#34;#安装&#34;&gt;&lt;/a&gt;安装&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;安装Ruby, VirtualBox&lt;/li&gt;&#xA;&lt;li&gt;下载安装&lt;a href=&#34;http://downloads.vagrantup.com/&#34;&gt;Vagrant&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;配置&#34; href=&#34;#配置&#34;&gt;&lt;/a&gt;配置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Vagrant默认文件会保存在用户目录下. 如过要改动, 可以移动&lt;code&gt;~/.vagrant.d&lt;/code&gt;到你想要位置. 并且设置环境变量&lt;code&gt;VAGRANT_HOME&lt;/code&gt;指向新路径.&lt;br /&gt;&#xA;同时可以修改Vagrant创建的虚拟机的保存位置. 打开VirtualBox程序, 点击&lt;code&gt;管理/全局设定&lt;/code&gt;菜单项, 将&lt;code&gt;常规&lt;/code&gt;栏里的&lt;code&gt;默认虚拟电脑位置(M)&lt;/code&gt;改为其他路径.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;使用&#34; href=&#34;#使用&#34;&gt;&lt;/a&gt;使用&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;Box&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;box就相当于是一个环境，它一般是一个VirtualBox虚拟机的镜像，官方提供了一个基于Ubuntu 10.04的box。 给vagrant添加一个box:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;vagrant box add lucid32 http://files.vagrantup.com/lucid32.box&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;其中lucid32表示给这个box起名lucid32。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也可以把lucid32.box下载过来，然后直接执行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;vagrant box add lucid32 lucid32.box&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.vagrantbox.es/&#34;&gt;这个网站&lt;/a&gt;收集了很多用户自己创建的box, 可以根据需要选择下载.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;创建虚拟机&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;执行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;vagrant init lucid32&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;表示基于lucid32创建一个虚拟环境, 命令执行后会在当前目录下生成一个Vagrantfile文件. 这个就是当前虚拟环境的配置文件.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;再执行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;vagrant up&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;就可以启动虚拟机了.  默认启动后是没有界面的.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;执行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;vagrant ssh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;就可以ssh到虚拟机了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Vagrantfile有几项比较重要的配置:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;config.vm.box 虚拟机使用的Box&lt;/li&gt;&#xA;&lt;li&gt;config.vm.network 配置虚拟机网络连接方式&lt;/li&gt;&#xA;&lt;li&gt;config.vm.forward_port 配置虚拟机端口转发&lt;/li&gt;&#xA;&lt;li&gt;config.vm.share_folder 配置文件夹共享目录&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;打包Box&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;对虚拟机做过一些配置后, 可以对虚拟机的当前状态进行打包, 已供其他人使用.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;执行&lt;code&gt;vagrant package&lt;/code&gt;即可在当前目录生成一个package.box文件.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;其它命令&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;vagrant halt 关闭虚拟机&lt;/li&gt;&#xA;&lt;li&gt;vagrant suspend 休眠虚拟机&lt;/li&gt;&#xA;&lt;li&gt;vagrant reload 重启虚拟机&lt;/li&gt;&#xA;&lt;li&gt;vagrant status 查看当前虚拟机状态&lt;/li&gt;&#xA;&lt;li&gt;更多其他命令可以通过vagrant help查看。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;参考&#34; href=&#34;#参考&#34;&gt;&lt;/a&gt;参考&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://docs.vagrantup.com/v2/&#34;&gt;Vagrant docs&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://wushaobo.info/?p=83&#34;&gt;Vagrant 知识澄清与杂症诊治&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Android模拟器Genymotion</title>
      <link>http://prisoner.github.io/2013/08/28/Android%E6%A8%A1%E6%8B%9F%E5%99%A8Genymotion.html</link>
      <pubDate>2013-08-28 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;android模拟器genymotion&#34; href=&#34;#android模拟器genymotion&#34;&gt;&lt;/a&gt;Android模拟器Genymotion&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Genymotion是由Genymobile开发的一款Android模拟器. 相比google的模拟器, 速度快了不只一点点. 可以说是目前世界上最快的Android模拟器.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Genymotion是基于VitualBox开发, 支持绝大部分的模拟器功能与感应器. Genymotion可运行于各个操作系统平台, 并提供Eclipse IntelliJ插件.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;安装&#34; href=&#34;#安装&#34;&gt;&lt;/a&gt;安装&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;注册Genymotion账号 &lt;a href=&#34;http://www.genymotion.com/&#34;&gt;注册链接&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;安装&lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;VitualBox&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;下载安装Genymotion &lt;a href=&#34;https://cloud.genymotion.com/page/launchpad/download/&#34;&gt;下载链接&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;安装Eclipse或者Intellij插件 (可选操作)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt; 安装完成后登录时的用户名是你注册时填写的邮件地址.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;登录界面:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.genymotion.com/static/images/doc/screenshots/genymotion-connect.png&#34; alt=&#34;登录界面&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;主界面:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.genymotion.com/static/images/doc/screenshots/genymotion-main-window-submenu.png&#34; alt=&#34;主界面&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;设备设置:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.genymotion.com/static/images/doc/screenshots/genymotion-virtual-device-settings.png&#34; alt=&#34;设备设置&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;设备运行界面:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.genymotion.com/static/images/doc/screenshots/genymotion-player-ready.png&#34; alt=&#34;设备运行界面&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;使用virtualbox的共享文件夹&#34; href=&#34;#使用virtualbox的共享文件夹&#34;&gt;&lt;/a&gt;使用VirtualBox的共享文件夹&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Genymotion是基于VitualBox开发的, 所以可以使用VitualBox的一些功能. 例如共享文件夹.&#xA;打开VirtualBox虚拟机, 选择要设置共享文件夹的Android模拟器. 进入&lt;code&gt;Settings&lt;/code&gt;, 添加要共享的目录, 选中&lt;code&gt;Auto-mount选项&lt;/code&gt;. 打开模拟器, 在模拟器的&lt;code&gt;/mnt/shared/&lt;/code&gt;目录下已经有了我们刚才在VirtualBox 里共享的文件夹了.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>使用Redis bitmaps进行快速、简单、实时统计</title>
      <link>http://prisoner.github.io/2013/08/08/%E4%BD%BF%E7%94%A8Redis-bitmaps%E8%BF%9B%E8%A1%8C%E5%BF%AB%E9%80%9F%E3%80%81%E7%AE%80%E5%8D%95%E3%80%81%E5%AE%9E%E6%97%B6%E7%BB%9F%E8%AE%A1.html</link>
      <pubDate>2013-08-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;原文：&lt;a href=&#34;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/&#34;&gt;Fast, easy, realtime metrics using Redis bitmaps&lt;/a&gt;&lt;br /&gt;&#xA;由&lt;a href=&#34;http://my.csdn.net/gaoyingju&#34;&gt;gaoyingju&lt;/a&gt;翻译.   &lt;a href=&#34;http://blog.csdn.net/gaoyingju/article/details/9671283&#34;&gt;链接&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;getspool.com的重要统计数据是实时计算的。Redis的bitmap让我们可以实时的进行类似的统计，并且极其节省空间。在模拟1亿2千8百万用户的模拟环境下，在一台MacBookPro上，典型的统计如“日用户数”(dailyunique users) 的时间消耗小于50ms, 占用16MB内存。Spool现在还没有1亿2千8百万用户，但是我们的方案可以应对这样的规模。我们想分享这是如何做到的，也许能帮到其它创业公司。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;bitmap以及redis-bitmaps快速入门&#34; href=&#34;#bitmap以及redis-bitmaps快速入门&#34;&gt;&lt;/a&gt;Bitmap以及Redis Bitmaps快速入门&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;Bitmap(即Bitset)&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR以及其它位操作。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;位图计数（Population Count）&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;位图计数统计的是bitmap中值为1的位的个数。位图计数的效率很高，例如，一个bitmap包含10亿个位，90%的位都置为1，在一台MacBook Pro上对其做位图计数需要21.1ms。SSE4甚至有对整形(integer)做位图计数的硬件指令。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20130731182138046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2FveWluZ2p1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Redis Bitmaps&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Redis允许使用二进制数据的Key(binary keys) 和二进制数据的Value(binary values)。Bitmap就是二进制数据的value。Redis的 setbit(key, offset, value)操作对指定的key的value的指定偏移(offset)的位置1或0，时间复杂度是O(1)。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;一个简单的例子：日活跃用户&#34; href=&#34;#一个简单的例子：日活跃用户&#34;&gt;&lt;/a&gt;一个简单的例子：日活跃用户&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;为了统计今日登录的用户数，我们建立了一个bitmap,每一位标识一个用户ID。当某个用户访问我们的网页或执行了某个操作，就在bitmap中把标识此用户的位置为1。在Redis中获取此bitmap的key值是通过用户执行操作的类型和时间戳获得的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20130731182321171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2FveWluZ2p1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个简单的例子中，每次用户登录时会执行一次redis.setbit(daily_active_users, user_id, 1)。将bitmap中对应位置的位置为1，时间复杂度是O(1)。统计bitmap结果显示有今天有9个用户登录。Bitmap的key是daily_active_users，它的值是1011110100100101。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为日活跃用户每天都变化，所以需要每天创建一个新的bitmap。我们简单地把日期添加到key后面，实现了这个功能。例如，要统计某一天有多少个用户至少听了一个音乐app中的一首歌曲，可以把这个bitmap的redis key设计为play:yyyy-mm-dd-hh。当用户听了一首歌曲，我们只是简单地在bitmap中把标识这个用户的位置为1，时间复杂度是O(1)。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Redis.setbit(play:yyyy-mm-dd, user_id, 1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;今天听过歌曲的用户就是key是play:yyyy-mm-dd的bitmap的位图计数。如果要按周或月统计，只要对这周或这个月的所有bitmap求并集，得出新的bitmap，在对它做位图计数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20130731182438265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2FveWluZ2p1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;利用这些bitmap做其它复杂的统计也非常容易。例如，统计11月听过歌曲的高级用户(premium user)：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;(play:2011-11-01 ∪ play:2011-11-02 ∪...∪play:2011-11-30) ∩ premium:2011-11&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;1亿2千8百万用户的性能比较&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;下面的表格显示了在1亿2千8百万用户上完成的时间粒度为1天，一周，一个月的用户统计的时间消耗比较。&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;Period&lt;/th&gt;&#xA;&lt;th&gt;Time (ms)&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Daily&lt;/td&gt;&#xA;&lt;td&gt;50.2&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Weekly&lt;/td&gt;&#xA;&lt;td&gt;392.0&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Monthly&lt;/td&gt;&#xA;&lt;td&gt;1624.8&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;优化&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;前面的例子中，我们把日统计，周统计，月统计缓存到Redis，以加快统计速度。&lt;br /&gt;&#xA;这是一种非常灵活的方法。这样进行缓存的额外红利是可以进行更多的统计，如每周活跃的手机用户—求手机用户的bitmap与周活跃用户的交集。或者，如果要统计过去n天的活跃用户数，缓存的日活跃用户使这样的统计变得简单——从cache中获取过去n-1天的日活跃用户bitmap和今天的bitmap,对它们做并集(Union)，时间消耗是50ms。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;示例代码&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;下面的Java代码用来统计某个用户操作在某天的活跃用户。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;{% gist 6180999 %}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面的Java代码用来统计某个用户操作在一个指定多个日期的活跃用户。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;{% gist 6181008 %}&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux netcat 命令的8个实用示例</title>
      <link>http://prisoner.github.io/2013/07/29/Linux-netcat-%E5%91%BD%E4%BB%A4%E7%9A%848%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%A4%BA%E4%BE%8B.html</link>
      <pubDate>2013-07-29 12:00:00 +0800</pubDate>
      <description>&lt;h4&gt;1) 在服务器-客户端架构上使用 Netcat&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;netcat 工具可运行于服务器模式，侦听指定端口&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -l 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后你可以使用客户端模式来连接到 2389 端口：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc localhost 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;现在如果你输入一些文本，它将被发送到服务器端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc localhost 2389   &#xA;HI, Prisoner&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在服务器的终端窗口将会显示下面内容：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -l 2389&#xA;HI, Prisoner&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;2) 使用 Netcat 来传输文件&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;netcat 工具还可用来传输文件，在客户端，假设我们有一个 testfile 文件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ cat testfile&#xA;hello oschina&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;而在服务器端有一个空文件名为 test&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后我们使用如下命令来启用服务器端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -l 2389 &amp;gt; test&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;紧接着运行客户端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cat testfile | nc localhost 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后你停止服务器端，你可以查看 test 内容就是刚才客户端传过来的 testfile 文件的内容：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ cat test&#xA;hello oschina&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;3) Netcat 支持超时控制&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;多数情况我们不希望连接一直保持，那么我们可以使用 -w 参数来指定连接的空闲超时时间，该参数紧接一个数值，代表秒数，如果连接超过指定时间则连接会被终止。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;服务器:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;nc -l 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;客户端:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -w 10 localhost 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;该连接将在 10 秒后中断。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意: 不要在服务器端同时使用 -w 和 -l 参数，因为 -w 参数将在服务器端无效果。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;4) Netcat 支持 IPv6&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;netcat 的 -4 和 -6 参数用来指定 IP 地址类型，分别是 IPv4 和 IPv6：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;服务器端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -4 -l 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;客户端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -4 localhost 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后我们可以使用 netstat 命令来查看网络的情况：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ netstat | grep 2389&#xA;tcp        0      0 localhost:2389          localhost:50851         ESTABLISHED&#xA;tcp        0      0 localhost:50851         localhost:2389          ESTABLISHED&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接下来我们看看IPv6 的情况：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;服务器端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -6 -l 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;客户端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -6 localhost 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;再次运行 netstat 命令：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ netstat | grep 2389&#xA;tcp6       0      0 localhost:2389          localhost:33234         ESTABLISHED&#xA;tcp6       0      0 localhost:33234         localhost:2389          ESTABLISHED&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;前缀是 tcp6 表示使用的是 IPv6 的地址。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;5) 在 Netcat 中禁止从标准输入中读取数据&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;该功能使用 -d 参数，请看下面例子：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;服务器端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -l 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;客户端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -d localhost 2389&#xA;Hi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;你输入的 Hi 文本并不会送到服务器端。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;6) 强制 Netcat 服务器端保持启动状态&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;如果连接到服务器的客户端断开连接，那么服务器端也会跟着退出。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;服务器端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -l 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;客户端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc localhost 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;服务器端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -l 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上述例子中，但客户端断开时服务器端也立即退出。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以通过 -k 参数来控制让服务器不会因为客户端的断开连接而退出。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;服务器端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -k -l 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;客户端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc localhost 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;服务器端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -k -l 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;7) 配置 Netcat 客户端不会因为 EOF 而退出&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;Netcat 客户端可以通过 -q 参数来控制接收到 EOF 后隔多长时间才退出，该参数的单位是秒：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;客户端使用如下方式启动：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;nc  -q 5  localhost 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;现在如果客户端接收到 EOF ，它将等待 5 秒后退出。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;8) 使用 Netcat 来处理 UDP 协议&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;netcat 默认是使用 TCP 协议，但也支持 UDP，可使用 -u 参数来启用 UDP 协议通讯。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;服务器端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -4 -u -l 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;客户端：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ nc -4 -u localhost 2389&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样客户端和服务器端都使用了 UDP 协议，可通过 netstat 命令来查看：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ netstat | grep 2389&#xA;udp        0      0 localhost:42634         localhost:2389          ESTABLISHED&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>JavaZone 2013 年度大片《Java末日》预告片</title>
      <link>http://prisoner.github.io/2013/07/25/JavaZone-2013-%E5%B9%B4%E5%BA%A6%E5%A4%A7%E7%89%87%E3%80%8AJava%E6%9C%AB%E6%97%A5%E3%80%8B%E9%A2%84%E5%91%8A%E7%89%87.html</link>
      <pubDate>2013-07-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;JavaZone 2013 年度大片《Java末日》预告片&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://static.oschina.net/uploads/img/201307/25091432_uW0p.jpg&#34; alt=&#34;JavaZone 2013 年度大片《Java末日》预告片&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;又等来了JavaZone发布年度大片预告片的时候了，今年的片子很有调侃时事的味道，关注Java的人应该都知道最近Java接连爆出很多严重的安全漏洞，Oracle官方忙于发布安全补丁，但这些安全补丁却造成了更多的漏洞。《Java末日》跟JavaZone以往的风格一样，纯属搞笑，这里的末日跟其它大片，比如2012，一样的灾难深重，墙倒屋塌，飞机坠落，饥荒，流亡，追捕…..&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;embed src=&#34;http://player.youku.com/player.php/sid/XNTczMTU2ODQw/v.swf&#34; allowFullScreen=&#34;true&#34; quality=&#34;high&#34; width=&#34;480&#34; height=&#34;400&#34; align=&#34;middle&#34; allowScriptAccess=&#34;always&#34; type=&#34;application/x-shockwave-flash&#34;&gt;&lt;/embed&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>被Google送进墓地的41款产品</title>
      <link>http://prisoner.github.io/2013/07/25/%E8%A2%ABGoogle%E9%80%81%E8%BF%9B%E5%A2%93%E5%9C%B0%E7%9A%8441%E6%AC%BE%E4%BA%A7%E5%93%81.html</link>
      <pubDate>2013-07-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-45-deceased-google-products_cover_2013-07.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Google的墓地 – 给曾经伟大的idea一个安身之处”。这里整整列41款产品，供大家回忆。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Google SMS Search – RIP &lt;sup&gt;12&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;/2013&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-sms-search.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Cloud Connect (&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;27&lt;/sub&gt;/2011 – &lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;30&lt;/sub&gt;/2013)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-cloud-connect.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Reader (2005 – /032013)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-reader.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;University Research Program for Google Search (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;15&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_research.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Spreadsheet Gadgets (&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;19&lt;/sub&gt;/2008 – &lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;28&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-spreadsheet-gadgets.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Directory App for Android (&lt;sup&gt;6&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;/2009 – &lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;28&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_places-directory-app-for-android.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Health (&lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;20&lt;/sub&gt;/2008 – &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-health.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Pack (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;6&lt;/sub&gt;/2006 – &lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;/2011)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-45-deceased-google-products_google-pack.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;+1 reporting webmaster tools (&lt;sup&gt;6&lt;/sup&gt;&amp;frasl;&lt;sub&gt;29&lt;/sub&gt;/2011 – &lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;28&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-45-deceased-google-products_google-postini-services.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Apps for Teams (&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;6&lt;/sub&gt;/2008 – &lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;6&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-apps.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google AdSense for Feeds (&lt;sup&gt;15&lt;/sup&gt;&amp;frasl;&lt;sub&gt;8&lt;/sub&gt;/ 2008 – &lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;28&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-adSense-for-feeds.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google News Badges (&lt;sup&gt;7&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2011&lt;/sub&gt; – &lt;sup&gt;10&lt;/sup&gt;&amp;frasl;&lt;sub&gt;15&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-news-badges.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Lively (&lt;sup&gt;7&lt;/sup&gt;&amp;frasl;&lt;sub&gt;8&lt;/sub&gt;/2008 – &lt;sup&gt;12&lt;/sup&gt;&amp;frasl;&lt;sub&gt;31&lt;/sub&gt;/2008)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-lively.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Picasa for Linux (04/&lt;sup&gt;20&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2012&lt;/sub&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_picasa-for-linux.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Picasa Web Albums Uploader for Mac (04/&lt;sup&gt;20&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2012&lt;/sub&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_picasa-web-albums.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Video for Business (&lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;/2008 – &lt;sup&gt;8&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-Video-for-business.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Listen (August 2009 – &lt;sup&gt;11&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-listen.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Patent Search homepage&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-patent-search-homepage.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google One Pass (04/&lt;sup&gt;20&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2012&lt;/sub&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-one-pass.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Sync for Blackberry (06/01/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_blackberry.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;iGoogle Social Features (&lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2005&lt;/sub&gt; – &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;15&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_igoogle-social-features.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Labs Site (&lt;sup&gt;10&lt;/sup&gt;&amp;frasl;&lt;sub&gt;14&lt;/sub&gt;/2011)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-45-deceased-google-products_google-labs-site.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Related (04/&lt;sup&gt;20&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2012&lt;/sub&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-related.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Flu Vaccine Finder (04/&lt;sup&gt;20&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2012&lt;/sub&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-flu-vaccine-finder.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Code Search API (&lt;sup&gt;10&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;/2006 – &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;15&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-code-search-api.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Jaiku (&lt;sup&gt;10&lt;/sup&gt;&amp;frasl;&lt;sub&gt;9&lt;/sub&gt;/2007 – &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;15&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-buzz.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Sidewiki (&lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;23&lt;/sub&gt;/2001 – &lt;sup&gt;12&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2011&lt;/sub&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-sidewiki.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Search Timeline (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;22&lt;/sub&gt;/2011)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-search-timeline.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Notebook (&lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;15&lt;/sub&gt;/2006 – &lt;sup&gt;11&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;/2011)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-notebook.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Friend Connect (&lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;12&lt;/sub&gt;/2008 – &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-friend-connect.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Desktop (&lt;sup&gt;10&lt;/sup&gt;&amp;frasl;&lt;sub&gt;14&lt;/sub&gt;/2004 – &lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;/2011)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_desktop.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Fast Flip (&lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;14&lt;/sub&gt;/2009 – &lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;/2011)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-fast-flip.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Wave (&lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;27&lt;/sub&gt;/2009 – &lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;30&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-wave.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Knol (&lt;sup&gt;7&lt;/sup&gt;&amp;frasl;&lt;sub&gt;23&lt;/sub&gt;/2008 – &lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;30&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_igoogle.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Gears (&lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;31&lt;/sub&gt;/2007 – &lt;sup&gt;12&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;/2011)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-gears.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Video (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;25&lt;/sub&gt;/2005 – &lt;sup&gt;8&lt;/sup&gt;&amp;frasl;&lt;sub&gt;20&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-45-deceased-google-products_google-video.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Buzz (&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;9&lt;/sub&gt;/2012 – &lt;sup&gt;12&lt;/sup&gt;&amp;frasl;&lt;sub&gt;15&lt;/sub&gt;/2011)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-buzz1.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Talk Chatback (&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;28&lt;/sub&gt;/2008 – &lt;sup&gt;7&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;/2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-talk-chatback.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Mini (2005 – July 31, 2012)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_google-mini.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Google Bookmarks Lists (&lt;sup&gt;10&lt;/sup&gt;&amp;frasl;&lt;sub&gt;10&lt;/sub&gt;/2005 – &lt;sup&gt;12&lt;/sup&gt;&amp;frasl;&lt;sub&gt;19&lt;/sub&gt;/2011)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-45-deceased-google-products_google-bookmarks.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Aardvark (&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;10&lt;/sub&gt;/2012 – &lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;/2011)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.damndigital.com/wp-content/uploads/2013/07/damndigital_google-graveyard-40-deceased-google-products_Aardvark.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux Shell 的一些使用技巧</title>
      <link>http://prisoner.github.io/2013/07/24/Linux-Shell-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html</link>
      <pubDate>2013-07-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Linux Shell 的一些使用技巧&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;常用快捷键:&lt;br /&gt;&#xA;Ctrl + a ：移到命令行首&lt;br /&gt;&#xA;Ctrl + e ：移到命令行尾&lt;br /&gt;&#xA;Ctrl + f ：按字符前移（右向）&lt;br /&gt;&#xA;Ctrl + b ：按字符后移（左向）&lt;br /&gt;&#xA;Alt + f ：按单词前移（右向）&lt;br /&gt;&#xA;Alt + b ：按单词后移（左向）&lt;br /&gt;&#xA;Ctrl + xx：在命令行首和光标之间移动&lt;br /&gt;&#xA;Ctrl + u ：从光标处删除至命令行首&lt;br /&gt;&#xA;Ctrl + k ：从光标处删除至命令行尾&lt;br /&gt;&#xA;Ctrl + w ：从光标处删除至字首&lt;br /&gt;&#xA;Alt + d ：从光标处删除至字尾&lt;br /&gt;&#xA;Ctrl + d ：删除光标处的字符&lt;br /&gt;&#xA;Ctrl + h ：删除光标前的字符&lt;br /&gt;&#xA;Ctrl + y ：粘贴至光标后&lt;br /&gt;&#xA;Alt + c ：从光标处更改为首字母大写的单词&lt;br /&gt;&#xA;Alt + u ：从光标处更改为全部大写的单词&lt;br /&gt;&#xA;Alt + l ：从光标处更改为全部小写的单词&lt;br /&gt;&#xA;Ctrl + t ：交换光标处和之前的字符&lt;br /&gt;&#xA;Alt + t ：交换光标处和之前的单词&lt;br /&gt;&#xA;Alt + Backspace：与 Ctrl + w 类似，分隔符有些差别&lt;br /&gt;&#xA;Ctrl + l：清屏&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;Ctrl + z&lt;/code&gt; 快捷键可以让正在执行的命令挂起。如果要让该进程在后台执行，那么可以执行 &lt;code&gt;bg&lt;/code&gt; 命令。而 &lt;code&gt;fg&lt;/code&gt; 命令则可以让该进程重新回到前台来。使用 &lt;code&gt;jobs&lt;/code&gt; 命令能够查看到哪些进程在后台执行。 你也可以在 &lt;code&gt;fg&lt;/code&gt; 或 &lt;code&gt;bg&lt;/code&gt; 命令中使用作业 id，如： &lt;code&gt;fg %12&lt;/code&gt; 又如： &lt;code&gt;bg %37&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;man手册&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用书签来标记需要重复阅读的内容。方法为：先按m键，然后在 &lt;code&gt;mark:&lt;/code&gt; 后输入标记字母，如 p。 当你需要返回先前设置的书签时，可以按&lt;code&gt;&#39;&lt;/code&gt;键（单引号）。此时会显示 &lt;code&gt;goto mark:&lt;/code&gt;，输入你设置的标记符即可。&lt;/li&gt;&#xA;&lt;li&gt;在阅读man手册页时想要对命令的用法进行尝试的话，那么可以使用&lt;code&gt;!&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;tail -f /path/to/file.log | sed &#39;/^Finished: SUCCESS$/ q&#39;&lt;/code&gt;当file.log里出现Finished: SUCCESS时候就退出tail，这个命令用于实时监控并过滤log是否出现了某条记录&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;ssh user@server bash &amp;lt; /path/to/local/script.sh&lt;/code&gt;在远程机器上运行一段脚本。这条命令最大的好处就是不用把脚本拷到远程机器上。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;vim scp://username@host//path/to/somefile&lt;/code&gt; vim一个远程文件&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;python -m SimpleHTTPServer&lt;/code&gt; 一句话实现一个HTTP服务，把当前目录设为HTTP服务目录，可以通过http://localhost:8000访问&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;ps aux | sort -k4nr | head -n 10&lt;/code&gt; 或者 &lt;code&gt;top&lt;/code&gt;然后按下&lt;code&gt;M&lt;/code&gt; 查看linux占用内存最多的进程&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;ps aux | sort -k3nr | head -n 10&lt;/code&gt; 或者 &lt;code&gt;top&lt;/code&gt;然后按下&lt;code&gt;P&lt;/code&gt; 查看linux占用CPU最多的进程&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>HTML5/CSS3演示框架</title>
      <link>http://prisoner.github.io/2013/07/19/HTML5%2FCSS3%E6%BC%94%E7%A4%BA%E6%A1%86%E6%9E%B6.html</link>
      <pubDate>2013-07-19 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;扔掉你的PowerPoint, 使用这些超酷的HTML5/CSS3演示框架吧.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;&lt;a href=&#34;https://code.google.com/p/io-2012-slides/&#34;&gt;html5 Slides&lt;/a&gt;&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Google在2012年的I/O展会中使用的演示框架. &lt;a href=&#34;http://io-2012-slides.googlecode.com/git/template.html#1&#34;&gt;DEMO地址&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://static.oschina.net/uploads/img/201202/29140455_IB2s.png&#34; alt=&#34;html5 Slides&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/briancavalier/slides&#34;&gt;Slides Presentation with HTML5&lt;/a&gt;&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;这个工具用了纯HTML做主题和框架，CSS做切换效果，还有一个简单的JS MVC框架来展示幻灯片。这个工具最适合用来展示你的数据。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://static.oschina.net/uploads/img/201202/29140456_GgsA.png&#34; alt=&#34;Slides Presentation with HTML5&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/LeaVerou/CSSS&#34;&gt;CSSS&lt;/a&gt;&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;一个基于CSS的幻灯片系统，在开发者和设计师圈子中很流行。她提供了一些设计，你可以基于这些设计做一些快速的修改。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://static.oschina.net/uploads/img/201202/29140457_St1b.png&#34; alt=&#34;CSSS&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;&lt;a href=&#34;http://slides.html5rocks.com/#landing-slide&#34;&gt;HTML5 Rocks&lt;/a&gt;&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;支持代码高亮, 支持切换样式, 支持切换3D效果. &lt;a href=&#34;http://slides.html5rocks.com/#landing-slide&#34;&gt;DEMO&lt;/a&gt;是关于HTML5的, 也值得一看.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://static.oschina.net/uploads/img/201202/29140457_lIiz.png&#34; alt=&#34;HTML5 Rocks&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/bartaz/impress.js&#34;&gt;Impress.js&lt;/a&gt;&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;一个基于CSS 3D Transforms里的旋转，扭曲，缩放等特性的演示框架. &lt;a href=&#34;http://bartaz.github.com/impress.js&#34;&gt;DEMO&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://static.oschina.net/uploads/space/2012/0823/204549_Y8DA_12.jpg&#34; alt=&#34;Impress.js&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/hakimel/reveal.js&#34;&gt;reveal.js&lt;/a&gt;&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;一个使用HTML创建漂亮演示文档的易用的框架 &lt;a href=&#34;http://lab.hakim.se/reveal-js/&#34;&gt;DEMO&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://static.oschina.net/uploads/space/2012/0904/085201_1wpG_12.jpg&#34; alt=&#34;reveal.js&#34; /&gt;&#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>GNU隐私权保护加密系统 GPG 快速入门</title>
      <link>http://prisoner.github.io/2013/07/18/GNU%E9%9A%90%E7%A7%81%E6%9D%83%E4%BF%9D%E6%8A%A4%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F-GPG-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html</link>
      <pubDate>2013-07-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;英文原文：&lt;a href=&#34;http://futureboy.us/pgp.html&#34;&gt;GPG Tutorial&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由 &lt;a href=&#34;http://my.oschina.net/jidianren&#34;&gt;几点人&lt;/a&gt;, &lt;a href=&#34;http://my.oschina.net/yumingzhe&#34;&gt;NinjaSquid&lt;/a&gt;, &lt;a href=&#34;http://my.oschina.net/shichaoyuan&#34;&gt;袁不语&lt;/a&gt;, &lt;a href=&#34;http://my.oschina.net/u/234124&#34;&gt;尚御博豪&lt;/a&gt;, &lt;a href=&#34;http://my.oschina.net/u/1179770&#34;&gt;Joynic&lt;/a&gt; 翻译.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;译文地址: &lt;a href=&#34;http://www.oschina.net/translate/pgp-tutorial&#34;&gt;http://www.oschina.net/translate/pgp-tutorial&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;本文未包括全文.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;起初这篇文章只是简单地包含了我的公钥，但随着时间的增长，它已经演变成一篇介绍如何使用以及为何使用GnuPG加密软件来保护隐私的文章，并且本文还在继续完善中。如果您有任何的问题，意见或建议，以及本文所使用的工具和服务器的地址或者与GPG相关的有趣的事物要分享，请告知&lt;a href=&#34;eliasen@mindspring.com&#34;&gt;Alan Eliasen&lt;/a&gt;，谢谢。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###Alan Eliasen的GPG公钥&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面是armored化的OpenPGP格式的公钥( eliasen@mindspring.com)，你可以用它来加密信息但只有我能读取！&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-----BEGIN PGP PUBLIC KEY BLOCK-----&#xA;Version: GnuPG v1.4.12 (GNU/Linux)&#xA;&#xA;mQGiBD0ZXm4RBADS59M4Dy4aOBUA59mKkNg+bWqeKenYs+zTk7O8QKfqgKxLBNya&#xA;R9x1ZJ0WARCzjM6wbFvg/2cZyLEvGFqXdVXPuKlB9jR1cgKH+KClOLFWdIJng6B+&#xA;lwxw9ho7uE2Gf+faBOktvGaUWk5E8rAwdBkIuvYqDc1YwYcG3iN5zAdNpwCg2JS5&#xA;NUqwRMKEVd1q0qUGKuni9ykD/17kSo6XSnirbLE8I4hKt76G09XYaIGioCzyMAv6&#xA;kcHJ47yxVRpzTXH5K1Wq09HhHUnW1oZ1tRA0YxwrEESW/fns/U7IU4BgilXKF81m&#xA;0fo/NAHVrkgas5MuA0Tb5wR6KrJwvYrVF1JqKFjeswan+SfWsQ440R8xhnyNlUTN&#xA;DICgBACcth1uXuUo5rciL7kETZ2ge+aK64SpEJzwhBZFgPsrNjLOGmIP9O3A9eWR&#xA;fM/kghpBP0cBxryyojYTh9E+vqEsFFxPhNtqo7hMd7NDdHLqn4y1FbgbugpdZhpE&#xA;h/L93EZzj9qRFRL4a8hsouroBw5IeTdg8cDwl49SqP4BilzVqLREQWxhbiBFbGlh&#xA;c2VuIChodHRwOi8vZnV0dXJlYm95LmhvbWVpcC5uZXQvKSA8ZWxpYXNlbkBtaW5k&#xA;c3ByaW5nLmNvbT6IVwQTEQIAFwUCPRlebgULBwoDBAMVAwIDFgIBAheAAAoJEOSB&#xA;hLWwVnaxgnsAn1vhCRNK/4Qfb0OXfqy7JylWxWgbAJ42lrhz8XK5NOS7t29BDwem&#xA;0D+CfohFBBARAgAGBQI+I5z4AAoJEBQ6+k4y8bDkbEsAmOhZGZbyblTfYc//JyU/&#xA;5GJxYdAAnjU1x/LPJ5o3HPnM63rvFnBS7SW9iEYEEhECAAYFAj7BwZ0ACgkQnN+4&#xA;1NpzKvdfGQCeME6xs7y4NR19xsrGuOTC7KDIkwUAn0A8JZR4s/HhbegcqWuQKBP4&#xA;uo88iEYEExECAAYFAkR+J1YACgkQ370QvkqtFkw+OQCfdrYDIBU0qD40LTNfOIbz&#xA;pVb5jDYAnil88lTfVnriKsYUKHjhQ4uPWRPCuQENBD0ZXnEQBACrfxe432NVrvgV&#xA;Yjas8SWLGEfBUeMqrIytcfm7TP6YNRyyzUufL2lnFpaREkO/mLN61bMfQSrmzaR1&#xA;wk/KNnwWTIp9UdVVxLhfQWJpG2b1GlwlHVEwEG8Dw2lxinPU7mg1OkceyizPjeRV&#xA;hoxB9NCpV0L3aFb3+GQku4ZzMsDJBwAECwP+LVkqEJgPwz+AmhqveFVSbsy5yDBr&#xA;oP814XMbNaw3IILQaBPwPKHa3xmOB16pb2MIzy0m3Vxq2qOITs6LAeUvtRS9ERI1&#xA;hJSchncL6Kl1D6eplVuoU5lIA1jfYmjGHrVNUkyjoPU+dLb0BJZ2PGLGxH0DwWIY&#xA;gKaQz2CDCh/11WaIRgQYEQIABgUCPRlecQAKCRDkgYS1sFZ2sXzTAJ4ks2Z4eVtZ&#xA;vDZvz3jlgBYAQFBx0gCgmINosOaFJGJlTwsALWhJGmXls3k=&#xA;=MNy0&#xA;-----END PGP PUBLIC KEY BLOCK-----&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;文本文件可以从&lt;a href=&#34;http://futureboy.us/pgp.txt&#34;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###什么是公钥加密？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;简单地说，公钥加密解决了一个古老的问题“在不与某人预先交换秘钥的条件下，如何与其进行安全的通信”，安全地交换共享秘钥是一个很难解决的问题。如果你的通信处于监听的情况下，你是无法保证交换的安全性。&#xA;有了公钥加密体系，通信的双方分别生成由公钥和“机密的”私钥组成的秘钥对，然后双方可以将各自的公钥发布到网上或直接发送给对方即可。&#xA;如果你有了用户B的公钥，那么你可以用它完成下面的工作：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;加密消息并且只能由B解密(B需要他的私钥来解密)&lt;/li&gt;&#xA;&lt;li&gt;验证一个是否由B的私钥签名的消息，也可以用来验证消息在传输过程中的完整性和机密性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;你可以用你的私钥做下面的事情：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解密由你的公钥加密的消息&lt;/li&gt;&#xA;&lt;li&gt;对消息进行签名以便别人来验证此消息是否出自你手(对方需要你的公钥来验证签名)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;###我的工具箱&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我接收和发送的所有消息都使用的是OpenPGP格式(是一种开放的标准，最广泛使用的用于公共加密的标准)，因此通信可以在任何OpenPGPG兼容的程序间工作正常。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;要对电子邮件进行加密和签名，可以使用下面的工具：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GNU隐私卫士(GPG)&lt;/li&gt;&#xA;&lt;li&gt;Thunderbird，mozilla的邮件客户端&lt;/li&gt;&#xA;&lt;li&gt;Mozilla的Enigmail插件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;如果你使用的是Fedora，你可以直接从源中安装Enigmail插件，而不用到网上下载。以root用户运行下面命令：&#xA;yum install thunderbird-enigmail或者一次性安装所有的包：yum install gnupg thunderbird thunderbird-enigmail&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在安装完或更新系统后，如果在Thunderbird菜单中找不到OpenPGP选项，先找到Tools | Add-ons，禁用Enigmail，重启Thunderbird，开启Enigmail，重启Thunderbird。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不足的是，Thunderbird版本飙得太快，导致Enigmail有时无法与系统兼容，这就是为什么用类似yum的包管理器来保证包的兼容性，另一个好处就是可以手动运行gpg命令。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先我们要对Enigmail进行一番设置，打开OpenPGP | Preferences | Display Expert Settings。只进行基本设置是不够的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在Enigmail中，过去我最喜欢设置默认密钥服务器为pgp.mit.edu，但是现在没太大的必要了，因为现在Enigmail包含一个密钥服务器列表，而且比它之前使用的更加稳定。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Gnu隐私卫士FAQ罗列了一些其它兼容GPG的email程序。注意，配合命令行下的gpg可执行程序，你可以使用任意e-mail程序（只要它不篡改消息）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于苹果机，你可以从GPGTools中获取GPG。（我个人没有使用过，但是别人推荐这个。）&lt;br /&gt;&#xA;做为替换，有时候我在Emacs/XEmacs中使用pgg包，这个包是对个gpg功能的包装。你可以高亮一部分内容，执行: M-x pgg-encrypt-region直接加密文档。&lt;br /&gt;&#xA;对于加密文件或者其它更有趣的事情，我只是在命令行中使用gpg程序。如果你是个安全偏执狂，那么更少的可执行程序，更好。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;本文档的大部分内容就是教你使用gpg程序让你变得更安全，这是一件有趣而且重要的事情。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###gpg还是gpg2&lt;/p&gt;&#xA;&#xA;&lt;p&gt;GPG2的可执行文件名叫gpg2,两者都可以演示下面的例子，而且两个版本相互兼容。v1经受过了更多的测试，是庞大功能的集合体。v2使用了libgcryp之类的加密库进行编译的，可以与外部的密码工具良好的协作。从命令行中可以看出，我使用的是版本1。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###从Enigmail导入&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从e-mail客户端（比如Enigmail）导入我的密钥最简单的方式是从密钥服务器导入。在Enigmail中，你可以使用OpenPGP | Key Management | Keyserver | Search for Keys搜索密钥，搜索的内容可以是我的名字、我的e-mail地址eliasen@mindspring.com、我的密钥ID E48184B5B05676B1或者是短ID B05676B1。然后从搜索结果中选择对应的复选框，点击“OK”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从Enigmail中导入我的公钥更懒更危险的方式是直接尝试发给我一封加密的e-mail。（写邮件的时候，选择菜单项OpenPGP，同时勾选Sign Message和Encrypt message。）然后当你尝试发送的时候，Enigmail将会发现它没有我的公钥，接着就会出现密钥管理窗口。从这个窗口中，你可以选择Download Missing Keys。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外还有一种导入的方式是将我的密钥的明文版本发送到你自己的邮箱，然后选择“Import PGP Key”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###从GPG导入&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你的e-mail客户端不允许你从e-mail消息中自动导入密钥，你需要将上述密钥的明文保存到一个文件中，然后手工导入密钥。对于GNU隐私卫士，执行：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --import [filename]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我的密钥从pgp.mit.edu中是可获得的（虽然所有主要的密钥服务器都会互相做镜像，所有你可能可以从任意的密钥服务器获得，但是这个密钥服务器可能更可靠。）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你可以从&lt;a href=&#34;http://pgp.mit.edu&#34;&gt;pgp.mit.edu&lt;/a&gt;中浏览可获得的密钥，&lt;a href=&#34;http://sks-keyservers.net&#34;&gt;sks-keyservers.net&lt;/a&gt;也可以，只是有时比较慢。你知道谁已经发布公钥了么？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用GNU隐私卫士，你可以按照下述操作导入我的密钥（看起来更安全）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --keyserver pgp.mit.edu --search-keys eliasen@mindspring.com&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意在所有的例子中，无论何时你看到一个e-mail地址，你可以替换掉部分名字、部分地址或者部分密钥ID。大部分命令都可以进行子串搜索。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;或者更直接一点儿，我的公钥ID是E48184B5B05676B1，（使用最后8个字符更平常，但是不安全，所以B05676B1也是可以的。读读下述关于 短密钥ID的技术说明 ，你会发现使用短ID有一个有趣的攻击）下述gpg命令将会从密钥服务器导入我的密钥。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --keyserver pgp.mit.edu --recv-keys E48184B5B05676B1 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;继续读下去你会明白为什么仅仅从密钥服务器导入密钥并不能确定你正在跟我通信。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你可能不必在上述命令中指定一个密钥服务器。后续版本的GPG具有内建的更可靠的密钥服务器列表。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://sks-keyservers.net&#34;&gt;sks-keyservers.net&lt;/a&gt;实时监控密钥服务器的状态。如果你无法从某个密钥服务器导入签名或者想要一个可用密钥服务器的列表，那么就去这个网站看看。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###获得帮助&lt;/p&gt;&#xA;&#xA;&lt;p&gt;gpg &amp;ndash;help是你最好的朋友。它会列出GPG最常用的选项，但不是全部。下面是其他的一些完备的文档：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.gnupg.org/documentation/manuals.en.html&#34;&gt;GPG Manual&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.gnupg.org/documentation/manuals/gnupg/&#34;&gt;Using the GNU Privacy Guard&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.gnupg.org/gph/en/manual.html&#34;&gt;The GNU Privacy Handbook&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;###入门&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里的入门不会过于简单，因为这会让你误以为这些技能足以保护你的隐私了。然而最好的入门方式就是访问GNU Privacy Guard主页，阅读&amp;rdquo;Guides&amp;rdquo;小节的&amp;rdquo;GNU Privacy Handbook&amp;rdquo;(已有各种格式和语言的文档)部分。下面将会讲解如何设置GPG，包括如何创建自己的私钥。&#xA;运行下面的命令来创建私钥：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --gen-key&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;你可以选择使用默认项，因为它不会让key的长度超过允许的最大长度(当前最大长度为4096位)。key的长度越大，生成key的时间越长，加密、解密也会慢一些，但这也会给试图破解密信的恶意用户带来更高的时间开销。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###生成吊销秘钥&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在生成完私钥后，首先要做的就是创建一个吊销证书：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --gen-revoke your@email.address&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果你的私钥丢失或被盗，可以用此证书来吊销公钥。不要忽视它的重要性。不管是打印出来还是存储到硬盘上，总之要好好地保存起来。&#xA;如果私钥丢失或被盗，可以将吊销证书上传到公共keyserver上来吊销你的公钥，前提是你已经将你的公钥上传到keyserver上了。&#xA;如果让我看到你有多个未吊销的公钥并且说“私钥丢失，使用新的公钥来替换其他的公钥”(这话是从一个所谓具有保密经验的人口中说出的)之类的话，那么我会立马否决你，不会信任你，因为你没有遵循最佳实践，没能管理好你的机密信息。因此保护好吊销证书和保护好私钥一样的重要。请继续往下读，看看为什么当你看到“this key is my new key, ignore the others”这句话时就应立即想到这个人要么对加密不熟悉要么他就是假冒的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###验证过程&lt;/p&gt;&#xA;&#xA;&lt;p&gt;既然你已经得到了我的公钥，那么我们之间的通信就安全了吗？不，一点也不。许多人在刚开始接触密码系统时并没有意识到要去验证这个公钥是否真的属于我。以我，Alan Eliasen,为例，如果某人写了这篇文章，你怎样验证文章中的公钥就是我的呢？毕竟，心怀叵测的人可以将此文转载并修改公钥。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;听好了，下面的东西很重要。任何人都可以用任意的邮件地址来生成一个公钥，任何人都可以将公钥上传到任意的keyserver上。 只有验证了某个key确实属于那个人的时候 才能保证通信的安全。如果不进行严格的验证，那么密码学软件所做的只是确保消息在传输过程中的完整性和机密性。但这并不意味着你正与你想要交谈的人进行交谈。你可能正与另外一个人(坏人)交谈或遭受中间人攻击。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然而，如果你仅仅想要给我发一封加密邮件，防止他人窥探其中，那么你只需要用我的公钥加密即可。但你要知道我有理由不信任你所宣称的身份，在验证我的公钥前你也可以不信任我所宣称的身份。因此在我与你进行秘密交流前，我要验明你的身份。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###指纹&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一个密钥可以通过多种途径来验证（例如，我可以把我的完整的公钥读给你，这真的很耗费时间，而且很容易出错。除此之外，这样做不好还因为你在前面看到的密钥可能随着其他人签授而变得越来越长。）通常的选择是将你认为的我的公钥的指纹，与我所知道的我的公钥的指纹，进行比较。&#xA;一个指纹是一段更短的数字（通常使用十六进制数字表示），它包含一个对于我的公钥进行了高度加密的摘要。它比我的完整密钥短，因此这并不是一个不可利用的尝试，而且找到另一个有同样指纹的密钥的可能性确实很小。无限的小。小到你不需要担心它。如果其他人能够找到一个匹配的指纹，他们就有足够的能力和财力可以让你从地球表面消失。因此，在你导入了我的密钥之后，键入：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --fingerprint eliasen@mindspring.com&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;之后，你需要与我认证这个指纹。最好面对面的做这件事，但是如果是你通过声音认识的人，你可以通过电话做这件事。如果你不认识这个人，检查他们的驾驶证。问问其他人（你信任的人）谁知道他们。即使你不认识他们，至少你可以确认密钥属于正在和你交谈的那个人。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###我的密钥验证协议&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你想验证上述密钥，请联系我，我会在某个公开的约会场所验证它的指纹。我将会穿着一套风衣和海军蓝领带。你必须穿着或戴着黄色郁金香。任何别的花表示联系取消，即使下述交互正确进行。我不能低估充足的黄色郁金香存量对这次联系的重要性。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我将会说“天王盖地虎。”&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你必须回答“宝塔镇河妖。”&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果我对你的回答满意，我将回应“好叭哒。”&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不要做眼神交流或者显示出认识的样子。如果必要，我将会假装在手机上订购书籍，同时读出指纹的十六进制数字。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;好吧，这部分我有点儿开玩笑了。但是你必须同别人验证密钥才能确保真正的安全。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你已经验证了我的密钥，那么就相信我（相信你自己的判断）一定签了名。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###签名密钥&lt;/p&gt;&#xA;&#xA;&lt;p&gt;既然你已经验证了我的身份和公钥，那么你需要告诉你的加密软件你信任我的密钥。否则你的加密软件应当做正确的事情，并警告你你正在与没有经过确认的某个人通信。这正告诉你没有任何理由相信你正在使用的密钥是它应该属于的哪个人的密钥。 下面是GPG和Enigmail使用签名密钥和信任密钥的建议。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###Enigmail的签名密钥&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我有些许谨慎地推荐使用Enigmal来签名密钥，因为Enigmail的某些对话框是欺骗人的并且是错误的。请非常仔细地阅读下一部分。&lt;br /&gt;&#xA;在Enigmail里，你可以进入菜单项OpenPGP|密钥管理来签名密钥。&lt;br /&gt;&#xA;搜寻密钥，然后右击密钥，你将看到签名密钥的选项。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;签名密钥之后，你应当给签名密钥的这个人赋予信任级别。右击密钥名，选择“设置拥有者信任级别”。警告：这时弹出一个对话框，询问“你信任这个密钥程度？”，不过这不是正确的问题！GPG软件的信任意思是你信任这个人去验证其他人的密钥的程度，而不是你信任这个密钥的程度！在GPG里，问题陈述如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;&amp;quot;请确定你信任这个用户（通过查看护照，检查不同来源的指纹等）正确地验证其他用户的密钥的程度“&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正如你所看到的，这是完全不同的问题。这就是我鼓励你通过在命令行上使用GPG去学习的原因。它更加严密和正确。另外GPG给你更多有关像“无限制的信任”这样危险选择的告警。阅读下一节会明白更多&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###GPG的签名密钥&lt;/p&gt;&#xA;&#xA;&lt;p&gt;要从gpg签名我的密钥，你将做以下事情：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --sign-key eliasen@mindspring.com &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;(不过，下面将看到更好的选项。）&#xA;这儿将给出你签名密钥的一些选项。更好的选项是编辑你的签名并且使用交互式菜单信任这个用户的设置：&#xA;    gpg &amp;ndash;interactive &amp;ndash;edit-key eliasen@mindspring.com&lt;/p&gt;&#xA;&#xA;&lt;p&gt;提示：在交互式命令行里键入&amp;rdquo;help&amp;rdquo;。命令“sign&amp;rdquo;和&amp;rdquo;trust&amp;rdquo;是你正在查找的哪个命令。这既允许你可签名密钥也表明你信任我验证其他人密钥的程度。当验证和签名其他人的密钥的时候如果你认为我愚蠢且懒散，那么你将赋予我低的信任级别。&#xA;在你签名了某些人的密钥后，你应当把签名的密钥回送给他们，这样他们能向其他人展示你已经对它进行了签名。&#xA;你可以使用下面的命令导出他们的密钥：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --export -armor their@email.address &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后把输出发送给他们。接着他们可以使用下面命令导入这些变化：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --import &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;你还可以上传这些签名到密钥服务器，这让签名可在全世界使用。要知道如何做到这些，请参阅发布你的公共密钥一节。&#xA;如果你不能真正的确认为我的身份，而且不打算公开地替我保证，那么你将本地签名我的密钥，这意味着你只是自己信任这个密钥：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --lsign-key eliasen@mindspring.com &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;提示：如果你在没有同我验证密钥的情况下公开地签名我的密钥，那么我将给你赋予非常低的信任级别。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###发布你的公钥&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当然，你可以手动把你的公钥发送给你想要联系的人，但是假如需要安全与你通信，而你并没有把公钥发送给他们该怎么办呢？通常的办法是你把你的公钥发送到一台密钥服务器上，那么任何人都可以导入你的密钥。世界上大多数的密钥服务器相互镜像，所以你在其中一台服务器上发布你的密钥后很短的时间内，密钥就会被传送到其他服务器上。就像我前面说的，在过去的十年里使用pgp.mit.edu 发布公钥一直都很给力。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;尽管如此，在你发布你的公钥（或者别人的公钥）到密钥服务器之前你还是需要负起责任。正如在 入门 和 验证过程 章节里提到的一样，你最好为你的密钥生成一份吊销证书然后把它放在一个非常安全的地方保存。否则的话，一旦你弄丢了你的密钥，或者密钥失效，对应的公钥将会永久残留在公钥服务器上，那就好像是在嘲笑并证实你并不清楚该如何有效地保护你的机密。假如你认为可以不用吊销公钥，能从密钥服务器上删除的话，去读一下这篇文章 FAQ at MIT&amp;rsquo;s keyserver.（我认为有意思的是他们网站上有一个冒牌的 “删除密钥” 功能，不管你输入什么样的密钥，都会重定向到FAQ页面。）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;假如某些人持有你的公钥，他们主要可以用它来搞定下面几个操作：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;加密一些只有你可以解密的信息。&lt;/li&gt;&#xA;&lt;li&gt;验证时有力地保证这些信息是由你的密钥签名的，并且可以确保这些信息在传输过程中没有受到篡改或破坏。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;###手动导出和上传&lt;/p&gt;&#xA;&#xA;&lt;p&gt;既然你已经生成了加密密钥和公钥，那么人们如何找到可发送加密的电子邮件给你得公钥呢？你可以通过把加密密钥放在电子邮件里直接发送给某人。为了生成易于发送电子邮件的公钥的拷贝，你可以这么做：&#xA;gpg &amp;ndash;armor &amp;ndash;export your@email.address&#xA;这将生成适宜于发送电子邮件的你公钥的非常漂亮格式的&amp;rdquo;ASCII封装“版本。”ASCII封装“是一种把原始的二进制数据（如果你试图通过大多数电子邮件程序发送这样的密钥的话，可能使密钥损坏）转换为仅仅限制使用ASCII字符、换行、正确的文件头并适合于电子邮件的格式。（提示：这似乎看起来像这个页面最顶端的我的公钥。）&#xA;注意开始行&lt;br /&gt;&#xA;&amp;mdash;&amp;ndash;BEGIN PGP PUBLIC KEY BLOCK&amp;mdash;-&lt;br /&gt;&#xA;和结束行&lt;br /&gt;&#xA;&amp;mdash;&amp;ndash;END PGP PUBLIC KEY BLOCK&amp;mdash;-&lt;br /&gt;&#xA;是这样的信息必不可少的一部分。不要忘记把它们包含进来。&#xA;一旦你拥有了ASCII封装的公钥的话，你就可以手动的粘贴公钥到像pgp.mit.edu这样的公钥服务器的表格里。&#xA;再强调一遍，仅仅因为某些人好像给你已经发送他们的公钥，就没有理由信任公钥是来自于它所属于的哪个人的，除非你已经使用上面验证过程一节里的指令同他们进行了密钥验证。确定在信任他们之前验证了任一个密钥。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这些都很有利。你想要别人获得你的公钥。那么下面就是一些把你的公钥发布到你的密钥服务器的方法。异曲同工。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###使用GPG上传公钥&lt;/p&gt;&#xA;&#xA;&lt;p&gt;发布密钥到密钥服务器的一种方式是前一节的手动方式：导出ASCII封装的密钥，然后手工的把它粘贴到像pgp.mit.edu的表格里。&#xA;另一种方式是让pgp程序上传密钥。你通过指定电子邮件地址无法完成上传；你需要指定公钥的十六进制ID号码。那么你如何找到你打算上传的密钥的十六进制ID号码呢？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --list-keys your@email.address&#xA;pub 1024D/B05676B1 2002-06-26&#xA;uid Alan Eliasen (http://futureboy.homeip.net/) &amp;lt;eliasen@mindspring.com&amp;gt;&#xA;sub 1024g/70AC29FB 2002-06-26&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在上面的结果里公钥ID显示在pub所在的行并且包含了8个字符的十六进制码（上例子中的B05676B1）。你需要知道要上传到服务器的是这个码。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --send-keys keyID&#xA;gpg: sending key B05676B1 to hkp server subkey.pgp.net&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果及打算指定一个密钥服务器的话，你可能需要指定 &amp;ndash;keyserver pgp.mit.edu作为上面命令的选项。另外，大多数密钥服务器彼此互作镜像，不过要把这些密钥传送到所有服务器是要花时间的。&#xA;注意在你给别的某些人的公钥签了名后，就表明你已经验证了他们的密钥和身份，并且保证密钥是属于他们的。你可以使用同样的过程上传他们公钥的以签名版本到密钥服务器上，这样人们就能看到你提他们做了保证。更多有关这方面的习性你请参阅下面的 构建可信任网络一节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###通过Enigmail上传公钥&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在Enigmail中，任何与key相关的操作都是通过菜单项OpenPGP | Key Mangement来完成的。只需找到想要上传的key，然后右键单击就会弹出上传选项。这真是在简单不过了。但你仍需要仔细地负责任地签署他人的key。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###手动解密&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当收到一个加密的文件或消息时，如果没有一个好的插件来帮助解密的话，那么我们怎样才能手动解密呢？很简单，只要在命令行中运行gpg，就会提示我们输入密文：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg&#xA;gpg：Go ahead and type your message ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;从上可以看出，我们只需把密文复制黏贴进来，就可以解密了或者会导入key以及其他一些与密信相关的信息。黏贴完后，需要向系统发出“end-of-line&amp;rdquo;字符，类Unix系统是Ctrl+D，Windows系统是Ctrl+Z。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果加密的数据是在一个文件里，那么你只是把文件名传给命令行的gpg就可以自动的处理这个文件了。&#xA;gpg myfilename&#xA;gpg通常只是对这个文件作正确的事情，在需要的时候提示你输入密码，保存输出文件等等。&#xA;警告：当gpg加密或者解密文件的时候，它通常保持原文件原样不变！你自己必须记住要删除原始文件，可能的话请安全删除。在Linux里你可以使用 shred -u（shred默认情形下仅仅是覆盖；要覆盖之后再删除这个文件的话，-u就是必须的）或者wipe命令安全地删除。在Windows里， sdelete可以很好的删除原文件。（虽然由于固态硬盘或者优盘外加了级别算法，安全删除不能确保可它们之上正常运行。不过如果你使用了固态硬盘或者优盘，而且打算安全的删除，那么你必须使用类似于wipe或者sdelete这样的工具改写所有空闲空间）不过不要相信需要做很多次覆盖的大量的宣传。 这非常可能是都市传闻或者市场谎言。一次覆盖就可能足够了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###手动加密&lt;/p&gt;&#xA;&#xA;&lt;p&gt;####加密邮件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果手头上没有一个好的插件来帮助加密消息时，命令行也可以轻松地完成这个任务。你需要将消息保存到一个文件中并运行下列命令。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --encrypt --sign --armor -r recipient@email -r your@email.com filename&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;命令行中有几个比较重要的选项：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&amp;ndash;encrypt告诉gpg使用公钥加密消息&lt;/li&gt;&#xA;&lt;li&gt;&amp;ndash;sign用于添加数字签名，以保证这个消息确实是由你发出的，而且也能保证消息在传输过程中没有损坏或修改。理论上，这个选项是可选的，但是请查看下面的“签名消息”小节以了解此选项的重要性。&lt;/li&gt;&#xA;&lt;li&gt;&amp;ndash;armor选项会将结果以ASCII字符形式明文输出。ASCII封装(ASCII armor)会将原生二进制数据转换为仅包含ASCII字符、换行符和相应的头信息的适合在邮件中传输的格式。如果想把加密的消息黏贴到邮件body中或发表在论坛的帖子中，这个选项是必须的。&lt;/li&gt;&#xA;&lt;li&gt;-r recipient 选项用于指定消息的接收者，可以同时指定多个接收者但必须要导入接收人的公钥。若在命令中未指定接收者，那么会进入交互模式提示你输入，接收者可以用公钥ID来指代。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意，下面的东西很重要也很有趣！&lt;/strong&gt; 大家可能已经注意到上面的例子中，我们自己的邮件地址被指定为接收人之一。这是因为如果没有显示地将自己的地址添加到接收人列表中的话，自己也无法解密消息！ 即使此消息是由你亲自编写、加密的，你也无法解密。很酷吧。请阅读下面的“为什么公钥加密是很酷的”小节来了解其中的奥妙。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;filename选项指定要加密的文件。这个选项不是必须的，但如果没有指定文件名的话，GPG会继续等待输入内容，然后我们就可以直接键入消息了或者也可以将消息复制黏贴进来，但这种方法比较笨拙。当黏贴完消息后，我们需要向系统发出&amp;rdquo;end-of-line&amp;rdquo;字符，类Unix系统上是Ctrl+D，Windows系统是Ctrl+Z。&#xA;注意：我再重复一遍，使用gpg加密、解密文件时，会保留原文件！出于安全考虑，必须要记得删除原文件。请看上面的注意部分来了解如何操作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;####加密文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;GPG不只是用来加密邮件哦！还可以用来保护敏感文件。加密文件和加密邮件方法一样，只需执行下面的命令即可：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --encrypt filename&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行后会提示输入接收人的邮件地址(最好把自己的地址也添加进去以便自己可以解密)。&#xA;更完整的命令如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --encrypt --sign -r your@email.com filename&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这里需要注意的选项如下：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&amp;ndash;encrypt选项让gpg使用公钥来加密消息。(请看下面的&amp;rdquo;对称加密/解密&amp;rdquo;小节来了解使用密码而不是公钥加密文件)&lt;/li&gt;&#xA;&lt;li&gt;&amp;ndash;sign用于添加数字签名，以保证文件确实是由你创建的且在传输过程中没有被破坏或修改。理论上这个选项是可选的，但也非常重要。你想啊，要是某人用另一个加密文件将你的文件替换掉了怎么办？通过数字签名就可以极大地保证你就是加密文件的创建者并且文件在传输过程中没有被修改或破坏。请看下面的“签名消息”小节以了解更多关于数字签名的知识。&lt;/li&gt;&#xA;&lt;li&gt;&amp;ndash;armor选项(可选，非必须)将结果以ASCII字符进行明文输出。“ASCII封装(ASCII Armor)”是一种将原生二进制格式(在邮件中发送可能会被破坏)转换为只用ASCII字符、换行符以及相应的头信息表示的适合用邮件传播的格式。如果想把加密的消息黏贴到邮件body中或发表在论坛的帖子中，这个选项是必须的。注意，这个选项也会增加文件的大小。&lt;/li&gt;&#xA;&lt;li&gt;&amp;ndash;output filename(可选)用于指定输出文件名。&lt;/li&gt;&#xA;&lt;li&gt;-r recipient用于指定接收人，可以多个，但你必须已经导入了这些人的公钥。通过使用多个-r选项就可以指定多个接收人。若没有指定接收者，gpg会进入交互模式提示你输入。接收人可以用公钥ID来指代。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意!下面的内容很重要！&lt;/strong&gt;大家可能已经注意到上面的例子中，我们自己的邮件地址被指定为接收人之一。这是因为如果没有显示地将自己的地址添加到接收人列表中的话，自己也无法解密消息！ 即使此消息是由你亲自编写、加密的，你也无法解密。很酷吧。请阅读下面的“为什么公钥加密是很酷的”小节来了解其中的奥妙。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;filename选项指定要加密的文件。这个选项不是必须的，但如果没有指定文件名的话，GPG会继续等待输入内容，然后我们就可以直接键入消息了或者也可以将消息复制黏贴进来，但这种方法比较笨拙。当黏贴完消息 后，我们需要向系统发出&amp;rdquo;end-of-line&amp;rdquo;字符，类Unix系统上是Ctrl+D，Windows系统是Ctrl+Z。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt; 我再重复一遍，使用gpg加密、解密文件时，会保留原文件！出于安全考虑，必须要记得删除原文件。请看上面的注意部分来了解如何操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;####为消息签名&lt;/p&gt;&#xA;&#xA;&lt;p&gt;除了加密外，gpg还能用来对消息进行数字签名，有诸多好处：&#xA;* 能确保消息在传输过程中未被破坏或修改&#xA;* 允许他人验证消息是由你的私钥签署的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你应该总是为加密的消息进行签名。你想啊，每个人都能获取到你的公钥，都能用这个公钥加密消息发送给你，从而伪装成你认识的某个人(邮件地址很容易伪造，但这是另一个话题了)。因此只有当你(通过数字签名)验证了这个消息确实是由你认识的那个人签名的，你才能确信通信是安全的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此，你不应该信任任何未签名的加密通信。因为，任何想要冒充你朋友的人，都会故意“忘记”对消息进行签名。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一个经过签名的消息在数学理论上几乎可以完全确定消息就是由你签署的。&lt;br /&gt;&#xA;在邮件客户端中，要总是记得选择签署并加密消息。下面是手动签名消息的方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;####对明文进行签名&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有时我们仅仅想给一个不需加密的消息进行签名，只是让他人确信这个消息确实是出自你手，并且在传输过程中完整无损。其他适用的场景如下：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进行一个重要的表决&lt;/li&gt;&#xA;&lt;li&gt;商业间重要的通信&lt;/li&gt;&#xA;&lt;li&gt;如果发送的邮件中有可疑的URL，那接收人就会验证消息是否来自于你还是来自垃圾邮件&lt;/li&gt;&#xA;&lt;li&gt;来确认消息在传输过程中的完整性&lt;/li&gt;&#xA;&lt;li&gt;允许接收人验证消息确实来自于你并且未被修改。例如，学校会对成绩单进行签名以保证数据未经篡改(研究机构应该经常对消息签名！)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;使用&amp;ndash;clearsign选项可以将消息封装到ASCII格式的签名中，但不会修改消息的主体内容。此举可以让不会使用gpg的用户顺利读出消息的内容，也能让gpg用户验证消息确实是你写的并且没有被修改。命令如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --clearsign filename&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-----BEGIN PGP SIGNED MESSAGE-----&#xA;Hash: SHA1&#xA;&#xA;&#xA;I vote YES on this important measure.&#xA;&#xA;Alan Eliasen&#xA;-----BEGIN PGP SIGNATURE-----&#xA;Version: GnuPG v1.4.13 (GNU/Linux)&#xA;&#xA;iEYEARECAAYFAlHZCvgACgkQ5IGEtbBWdrF5HgCfc4xhT29ouAWdo1PMlyDKIfaq&#xA;pGoAoKig5sCXukrPPoKC1ZYB5CW7BzNL&#xA;=WPPL&#xA;-----END PGP SIGNATURE----- &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;验证过你的公钥的人可以通过将上面的输出传入gpg中就可以验明身份了：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --verify vote.txt.asc&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg: Signature made Sun 07 Jul 2013 12:30:16 AM MDT using DSA key ID B05676B1&#xA;gpg: Good signature from &amp;quot;Alan Eliasen (http://futureboy.homeip.net/) &amp;lt;eliasen@mindspring.com&amp;gt;&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果他们没有验证并签署你的公钥，那么gpg警告公钥是不受信任的。这只能保证消息在传输中未经破坏但无法确定消息是谁写的！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;####分离的签名&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有时我们想对一个文件进行签名但又不想使用&amp;ndash;clearsign选项来改变文件的内容，这是因为他人可能需要对文件进行再编辑或使用gpg才能读出内容，比较麻烦。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;例如，你要将某个可执行文件发送给某人，对其签名的话就会损坏文件，而且人们一看到可执行文件就会感到恐惧与危险。那怎样才能保证文件不被修改还能确保它确实是由你发出的呢？通过分离的签名就可以实现了，分离的签名就是一个单独的文件，只包含了对某个文件的签名，通过使用-detach-sign选项就可以完成这个工作：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --detach-sign filename&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;之后就可以将签名与原文件一起发送了。接收人可以通过&amp;ndash;verify选项验证文件没有被修改:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --verify filename.sig&#xA;gpg: Signature made Sun 07 Jul 2013 02:31:05 AM MDT using DSA key ID B05676B1&#xA;gpg: Good signature from &amp;quot;Alan Eliasen (http://futureboy.homeip.net/) &amp;lt;eliasen@mindspring.com&amp;gt;&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;####证明是你书写的，不过要临时保持匿名&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如说你发现一个大型公司（我们称它为Mapple）写了一个真正蹩脚的不称职不安全的Web站点，这个站点泄露了大量他们用户的信息，使得任何人在数字后加个1就可以随便访问这些信息。&#xA;现在，你不能确定是否是公司了不起而且诚实，并因你指出了他们的安全漏洞并且帮助他们保护客户信息而支付给你非常可观的漏洞奖金，还是他们是精神有病的匪徒，他们事后声明他们试图发布在没有任何权限控制的公共服务器上的你能访问的信息是“未经授权的”，并且控告你违反了编写的非常不称职的而且过时的计算机欺诈和滥用法（ CFAA）。&#xA;因此，你如何匿名地报告这个呢？ 好，一种非常强有力的方法是创建一个没有你名字的新的密钥对，发布你的公钥，接着使用对应的私钥对所有这些信息签名。这要求你要做以下几件事：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;你能够证明所有用同一个密钥签名的后续信息是来自于同一个人，甚至在你使用不同的电子邮件地址或者通信通道的情形下也如此。&lt;/li&gt;&#xA;&lt;li&gt;如果他们决定诚实并为你为他们的服务提供奖金的话，你可以在将来证明你就是签名这些信息所用的对应私钥的所有人，例如，通过 解密用你的公钥加密的发送给你的东西。没有其他人在没有验证他们拥有对应的私钥的情形下能够错误地宣布他们是提交人。&lt;/li&gt;&#xA;&lt;li&gt;如果他们对这件事就是作恶的话，那么你可以对他们保持匿名。如果你打算向其他人证明你揭露了这漏洞的话，那么你能通过使用同 一个公钥签名信息或者解密用你的私钥加密的发送给你的信息。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;（这是撕一张美元钞票为两半，并把一半送给某人的老技巧的数学化超强版本。如果他们打算验证你的身份，那么只要你拿出这张钞票的另一半就行。具有不同的撕裂模式并匹配序列号的一张美元钞票是很难伪造的。）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###更新密钥&lt;/p&gt;&#xA;&#xA;&lt;p&gt;人们由于多种原因经常更新密钥：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;密钥泄露或者丢失了，并且已经废止。&lt;/li&gt;&#xA;&lt;li&gt;为了构建一个可信的网络，密钥被太多的人用来签名.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;更新密钥需要发布到公共的密钥服务器上，包括发布新的签名。你可以使用下面命令定期地更新你的密钥&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpg --refresh-keys&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这可以让你确保你正在使用的密钥不会被取消。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;本文中的所有译文仅用于学习和交流目的，转载请务必注明文章译者、出处、和本文链接&#xA;我们的翻译工作遵照 &lt;a href=&#34;http://zh.wikipedia.org/wiki/Wikipedia:CC&#34;&gt;CC协议&lt;/a&gt;，如果我们的工作有侵犯到您的权益，请及时联系我们&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>TF-IDF概念</title>
      <link>http://prisoner.github.io/2012/08/25/TF-IDF%E6%A6%82%E5%BF%B5.html</link>
      <pubDate>2012-08-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;http://zh.wikipedia.org/wiki/TF-IDF&#34;&gt;TF-IDF&lt;/a&gt; (term frequency–inverse document frequency)也称为词汇频率/逆向文档频率.&#xA;是一种常用加权技术, 常用于评估一歌词对于一个文档集或一个语料库中的其中一份文档的重要程度.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;TF-IDF的主要思想是: 词的重要性随着它在文档中出现的次数成正比增加,但同时会随着它在语料库中出现的频率成反比下降.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;TF指的是某一个给定的词语在该文档中出现的频率.&lt;br /&gt;&#xA;IDF指的是逆向文档频率, 是一个词语普遍重要性的度量. 可以由总文档数目除以包含该词语之文件的数目获得.&lt;br /&gt;&#xA;TF-IDF由TF乘以IDF获得.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一篇文件的总词语数是100个，而词语“母牛”出现了3次，那么“母牛”一词在该文件中的词频就是 0.03 (&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;100&lt;/sub&gt;)。一个计算文件频率(DF) 的方法是测定有多少份文件出现过“母牛”一词，然后除以文件集里包含的文件总数。所以，如果“母牛”一词在1,000份文件出现过，而文件总数是 10,000,000份的话，其文件频率就是 0.0001 (&lt;sup&gt;1000&lt;/sup&gt;&amp;frasl;&lt;sub&gt;10&lt;/sub&gt;,000,000)。最后，TF-IDF分数就可以由计算词频除以文件频率而得到。以上面的例子来说，“母牛”一词在该文件集的TF- IDF分数会是 &lt;code&gt;(3/100) * (1000/10,000,000) = 300&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另一种形式是将文档频率取对数, 即 &lt;code&gt;(3/100) * log(10,000,000 / 1,000) = 0.12&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;详细见 &lt;a href=&#34;http://zh.wikipedia.org/wiki/TF-IDF&#34;&gt;http://zh.wikipedia.org/wiki/TF-IDF&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>linux 命令行下求文件的交集和差集</title>
      <link>http://prisoner.github.io/2012/07/30/linux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E6%B1%82%E6%96%87%E4%BB%B6%E7%9A%84%E4%BA%A4%E9%9B%86%E5%92%8C%E5%B7%AE%E9%9B%86.html</link>
      <pubDate>2012-07-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;linux 命令行下求文件的交集和差集.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;file1:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;a&#xA;b&#xA;c&#xA;d&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;file2&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;c&#xA;d&#xA;e&#xA;f&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;方法1&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;交集 &lt;code&gt;sort file1.txt file2.txt | uniq -d&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;差集 取在file1中但不在file2中的 &lt;code&gt;sort file2.txt file2.txt file1.txt | uniq -u&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;方法2&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;交集 &lt;code&gt;grep -F -v -f file1.txt file2.txt&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;差集 取在file1中但不在file2中的 &lt;code&gt;grep -F -v -f file2.txt file1.txt&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>oh-my-zsh下go命令自动完成</title>
      <link>http://prisoner.github.io/2012/07/24/oh-my-zsh%E4%B8%8Bgo%E5%91%BD%E4%BB%A4%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90.html</link>
      <pubDate>2012-07-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;新建文件$HOME/.oh-my-zsh/completions/_go, 内容如下:&lt;/p&gt;&#xA;&#xA;&lt;script src=&#34;https://gist.github.com/3168408.js&#34;&gt; &lt;/script&gt;&#xA;&#xA;&lt;p&gt;效果如下:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/images/post_images/2012-7-24-go_zsh_autocomplete.PNG&#34; alt=&#34;自动完成效果&#34; /&gt;&#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>甲骨文发布Java SE 7正式版</title>
      <link>http://prisoner.github.io/2011/07/29/%E7%94%B2%E9%AA%A8%E6%96%87%E5%8F%91%E5%B8%83Java-SE-7%E6%AD%A3%E5%BC%8F%E7%89%88.html</link>
      <pubDate>2011-07-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;7月29日, Java SE 7正式发布! 经过与世界范围内的Java社区,&#xA;Java平台历时将近五年的协作, 标准版本已经可以&#xA;&lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/downloads/index.html&#34;&gt;下载&lt;/a&gt;&#xA;了.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;新特性&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;改进动态语言支持&lt;/li&gt;&#xA;&lt;li&gt;改进的IO, 加强对NIO的支持 详见 &lt;a href=&#34;http://download.oracle.com/javase/7/docs/technotes/guides/io/enhancements.html#7&#34;&gt;Enhancements in Java&#xA;I/O&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;支持非Java语言: Java SE 7 引入一个新的 JVM&#xA;指令用于简化实现动态类型编程语言&lt;/li&gt;&#xA;&lt;li&gt;Garbage-First Collector 新的针对服务器的垃圾收集器用于替换CMS. &lt;a href=&#34;http://download.oracle.com/javase/7/docs/technotes/guides/vm/G1.html&#34;&gt;What&#xA;is the Garbage-First&#xA;Collector?&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;基于ForkJoinPool类的fork/join框架.&#xA;适合于多处理器环境下用来进行高效的运行大量任务. 详见 &lt;a href=&#34;http://download.oracle.com/javase/7/docs/technotes/guides/concurrency/changes7.html&#34;&gt;Concurrency&#xA;Utilities Enhancements in Java SE&#xA;7&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;增强国际化支持. &lt;a href=&#34;http://download.oracle.com/javase/7/docs/technotes/guides/intl/enhancements.7.html&#34;&gt;Internationalization Enhancements in Java SE&#xA;7&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;语言特性&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;二进制数字表达方式&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在java7中, 整形(byte, short, int, and long)可以用二进制表示, 加上前缀 0b&#xA;或者 0B 就可以了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;script src=&#34;https://gist.github.com/1113405.js&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;/script&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;switch支持字符串变量&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;这可是期盼多年的特性. 表达式比较使用 &lt;code&gt;String.equals&lt;/code&gt; 方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;script src=&#34;https://gist.github.com/1113411.js&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;/script&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;try-with-resources 语句&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在资源使用完后自动关闭. 资源是指实现了&#xA;&lt;a href=&#34;http://download.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html&#34;&gt;java.lang.AutoCloseable&lt;/a&gt;&#xA;或者&#xA;&lt;a href=&#34;http://download.oracle.com/javase/7/docs/api/java/io/Closeable.html&#34;&gt;Closeable&lt;/a&gt;&#xA;接口的类.\&#xA;注意在try-with-resources中依然可以使用 &lt;code&gt;catch&lt;/code&gt; 和 &lt;code&gt;finally&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt; 和&#xA;&lt;code&gt;finally&lt;/code&gt; 会在资源关闭之后运行.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;script src=&#34;https://gist.github.com/1113421.js&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;/script&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;同时捕获多个异常&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;catch (IOException|SQLException ex) { logger.log(ex); throw ex; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;数字表达中使用下划线&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;script src=&#34;https://gist.github.com/1113435.js&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;/script&gt;&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;泛型在创建实例时的类型引用&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;之前的代码&#xA;&lt;code&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;();&lt;/code&gt;&#xA;Java7的代码&#xA;&lt;code&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap&amp;lt;&amp;gt;();&lt;/code&gt;&#xA;编译器可以根据声明自动推断范型的类型.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Improved Compiler Warnings and Errors When Using Non-Reifiable Formal Parameters with Varargs Methods&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;详细:&#xA;&lt;a href=&#34;http://download.oracle.com/javase/7/docs/technotes/guides/language/non-reifiable-varargs.html&#34;&gt;链接&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;可惜那个很酷的集合声明语法没有实现&#xA;&lt;code&gt;List&amp;lt;String&amp;gt; people = {&amp;quot;Frank&amp;quot;, &amp;quot;Mary&amp;quot;, &amp;quot;Satan&amp;quot;};&lt;/code&gt;&#xA;&lt;code&gt;Map&amp;lt;String, Integer&amp;gt; map = {&amp;quot;key&amp;quot; : 1};&lt;/code&gt;&#xA;是不是有些动态语言的味道&lt;/p&gt;&#xA;&#xA;&lt;p&gt;闭包也没有, 可惜…&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Memcached的Consistent Hashing</title>
      <link>http://prisoner.github.io/2011/02/06/Memcached%E7%9A%84Consistent-Hashing.html</link>
      <pubDate>2011-02-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在有N台 &lt;a href=&#34;http://memcached.org/&#34;&gt;Memcached&lt;/a&gt; 的情况下,&#xA;如何有效的将数据分布到每台server上,&#xA;在添加或移除server时如何减少对已有数据的影响.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Memcached使用了Consistent Hashing算法来解决这些问题.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Consistent Hashing算法&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;详见 &lt;a href=&#34;http://portal.acm.org/citation.cfm?id=258660&#34;&gt;Consistent hashing and random&#xA;trees&lt;/a&gt; 和 &lt;a href=&#34;http://en.wikipedia.org/wiki/Consistent_hashing&#34;&gt;Consistent&#xA;Hashing&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Memcached的Consistent Hashing算法:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;生成一个0~2^32-1的环&lt;/li&gt;&#xA;&lt;li&gt;求出memcached server(node)的哈希值, 并将其配置到环上&lt;/li&gt;&#xA;&lt;li&gt;求出数据的哈希值, 并将其配置到环上&lt;/li&gt;&#xA;&lt;li&gt;将数据映射到node上. 从数据配置到的位置开始顺时针查找,将数据保存到找到的第一个node上, 如果超过2^32-1还找不到node，就保存到第0个节点&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2011-01-30_01.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;图片来源 &lt;a href=&#34;http://tech.idv2.com/2008/07/24/memcached-004/&#34;&gt;http://tech.idv2.com/2008/07/24/memcached-004/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意,Memcached的Consistent Hashing算法是在客户端实现的. 另外,&#xA;有些Consistent&#xA;Hashing算法的实现还使用了虚拟节点的方法来最大抑制数据的分布不均匀,&#xA;来减小服务器增减时的缓存重新分布.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.javaeye.com/topic/346682&#34;&gt;memcached分布测试报告&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/superfeedr/consistent_hashr/blob/master/lib/consistent_hashr.rb&#34;&gt;ruby实现&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;script src=&#34;https://gist.github.com/1112126.js&#34;&gt;&lt;/script&gt;&#xA;</description>
    </item>
    <item>
      <title>Redis的数据类型</title>
      <link>http://prisoner.github.io/2011/01/30/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</link>
      <pubDate>2011-01-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;http://redis.io/&#34;&gt;Redis&lt;/a&gt; 是一个开源的高级key-value数据库. 由 &lt;a href=&#34;http://twitter.com/antirez&#34;&gt;Salvatore&#xA;Sanfilippo&lt;/a&gt; (就算是老外,名字也够奇怪) 和&#xA;&lt;a href=&#34;http://twitter.com/pnoordhuis&#34;&gt;Pieter Noordhuis&lt;/a&gt; 使用C开发.&#xA;如果你使用过 &lt;a href=&#34;http://memcached.org/&#34;&gt;memcached&lt;/a&gt; ,就会发现两者十分相似,&#xA;但是 &lt;a href=&#34;http://redis.io/&#34;&gt;Redis&lt;/a&gt; 并非memcached的++,&#xA;Redis不仅支持更丰富的数据结构,并且数据&#xA;&lt;a href=&#34;http://redis.io/topics/persistence&#34;&gt;可持久化&lt;/a&gt; .&#xA;Redis的两个最大优点:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;超级快:&lt;/strong&gt; 使用Redis自带的redis-benchmark工具测试, 在Linux 2.6,Xeon&#xA;X3320 2.5G的机器上可以达到每秒110000次SET 81000次GET. 见 &lt;a href=&#34;http://redis.io/topics/benchmarks&#34;&gt;How fast is&#xA;Redis?&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;丰富的数据类型&lt;/strong&gt; Redis目前支持的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://redis.io/topics/data-types&#34;&gt;数据类型&lt;/a&gt; ,&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Binary-safe&#34;&gt;Binary-safe&lt;/a&gt; String&lt;/li&gt;&#xA;&lt;li&gt;List&lt;/li&gt;&#xA;&lt;li&gt;Set&lt;/li&gt;&#xA;&lt;li&gt;Sorted set&lt;/li&gt;&#xA;&lt;li&gt;Hashe&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Redis会在启动后将所有的数据加载到内存,这也是为什么Redis会如此快的原因之一.&#xA;但是有时候我们并不需要用到所有数据,&#xA;这样加载所有数据对内存是种巨大的浪费. Redis 2.0引进了 &lt;a href=&#34;http://redis.io/topics/virtual-memory&#34;&gt;Virtual&#xA;Memory&lt;/a&gt; 技术来避免这种情况.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;闲话休提, 回归正传. String就不用说它了, 说说其它四种类型&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;List:&lt;/strong&gt; Redis中的list是使用 &lt;a href=&#34;http://en.wikipedia.org/wiki/Linked_list&#34;&gt;Linkedlist&lt;/a&gt; 实现的,&#xA;也就是说向list中添加新的数据复杂度为O(1).&#xA;list主要 &lt;a href=&#34;http://redis.io/commands#list&#34;&gt;操作&lt;/a&gt; :&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/lpush&#34;&gt;LPUSH&lt;/a&gt; 向list的左侧(头部)插入数据.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/rpush&#34;&gt;RPUSH&lt;/a&gt; 向list的右侧(尾部)插入数据.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/lrange&#34;&gt;LRANGE&lt;/a&gt; 取得范围内的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;5.times do |i|&#xA;  redis.lpush(&#39;list1&#39;, &amp;quot;lpush-#{i}&amp;quot;)&#xA;end&#xA;&#xA;5.times do |i|&#xA;  redis.rpush(&#39;list1&#39;, &amp;quot;rpush-#{i}&amp;quot;)&#xA;end&#xA;&#xA;puts redis.lrange(&#39;list1&#39;, 0, -1)&#xA;&#xA;#lpush-4&#xA;#lpush-3&#xA;#lpush-2&#xA;#lpush-1&#xA;#lpush-0&#xA;#rpush-0&#xA;#rpush-1&#xA;#rpush-2&#xA;#rpush-3&#xA;#rpush-4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Set:&lt;/strong&gt; Set是未排序的集合.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;set的主要 &lt;a href=&#34;http://redis.io/commands#set&#34;&gt;操作&lt;/a&gt; :&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/sadd&#34;&gt;SADD&lt;/a&gt; 向集合中添加数据.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/sismember&#34;&gt;SISMEMBER&lt;/a&gt;&#xA;判断数据是否是集合的元素.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/sinter&#34;&gt;SINTER&lt;/a&gt; 对多个集合取交集.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/smembers&#34;&gt;SMEMBERS&lt;/a&gt; 取得集合的所有元素.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;5.times do |i|&#xA;  redis.sadd(&#39;set1&#39;, &amp;quot;set-#{i}&amp;quot;)&#xA;end&#xA;&#xA;puts redis.sismember(&#39;set1&#39;, &#39;set-2&#39;)&#xA;#true&#xA;&#xA;puts redis.smembers(&#39;set1&#39;)&#xA;#set-2&#xA;#set-3&#xA;#set-4&#xA;#set-0&#xA;#set-1&#xA;&#xA;5.times do |i|&#xA;  redis.sadd(&#39;set2&#39;, &amp;quot;set-#{i + 3}&amp;quot;)&#xA;end&#xA;&#xA;puts redis.sinter(&#39;set1&#39;, &#39;set2&#39;)&#xA;#set-3&#xA;#set-4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Sorted set&lt;/strong&gt; 与Set十分相似, 但是它是排序的集合.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;sorted set的主要 &lt;a href=&#34;http://redis.io/commands#sorted_set&#34;&gt;操作&lt;/a&gt; :&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/zadd&#34;&gt;ZDD&lt;/a&gt; 类似SADD, 但是有个score参数用作排序.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/zrange&#34;&gt;ZRANGE&lt;/a&gt; 取得范围内的数据, 注意结果已按照score排序&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/zrevrange&#34;&gt;ZREVRANGE&lt;/a&gt; 与ZRANGE一样, 但是结果顺序与ZRANGE相反&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/zrangebyscore&#34;&gt;ZRANGEBYSCORE&lt;/a&gt; 用score取得范围内的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#5.times do |i|&#xA;#  redis.zadd(&#39;sortedset1&#39;, rand(100), &amp;quot;sortedset-#{i}&amp;quot;)&#xA;#end&#xA;&#xA;puts redis.zrange(&#39;sortedset1&#39;, 0, -1)&#xA;#sortedset-1&#xA;#sortedset-3&#xA;#sortedset-0&#xA;#sortedset-2&#xA;#sortedset-4&#xA;puts redis.zrevrange(&#39;sortedset1&#39;, 0, -1, {:with_scores =&amp;gt; true})&#xA;#sortedset-4&#xA;#79&#xA;#sortedset-2&#xA;#62&#xA;#sortedset-0&#xA;#38&#xA;#sortedset-3&#xA;#11&#xA;#sortedset-1&#xA;#4&#xA;puts redis.zrangebyscore(&#39;sortedset1&#39;, 10, 90, :limit =&amp;gt; [0, 2], :with_scores =&amp;gt; true)&#xA;#sortedset-3&#xA;#11&#xA;#sortedset-0&#xA;#38&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Hashe&lt;/strong&gt; hash表结构&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hashe的主要 &lt;a href=&#34;http://redis.io/commands#hash&#34;&gt;操作&lt;/a&gt; :&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/hset&#34;&gt;HSET&lt;/a&gt; 对hash的field设置值&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/hget&#34;&gt;HGET&lt;/a&gt; 取得hash的field的值&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/hdel&#34;&gt;HDEL&lt;/a&gt; 删除field的值&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/hkeys&#34;&gt;HKEYS&lt;/a&gt; 取得hash的所有field&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/hvals&#34;&gt;HVALS&lt;/a&gt; 取得hash的所有的值&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://redis.io/commands/hmget&#34;&gt;HMGET&lt;/a&gt; 一次取得多个field的值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;5.times do |i|&#xA;  redis.hset(&amp;quot;hash1&amp;quot;, &amp;quot;field#{i}&amp;quot;, &amp;quot;hash-value#{i}&amp;quot;)&#xA;end&#xA;&#xA;puts redis.hkeys(&amp;quot;hash1&amp;quot;)&#xA;puts &#39;*&#39; * 10&#xA;redis.hdel(&amp;quot;hash1&amp;quot;, &amp;quot;field1&amp;quot;)&#xA;puts &#39;*&#39; * 10&#xA;puts redis.hvals(&amp;quot;hash1&amp;quot;)&#xA;puts &#39;*&#39; * 10&#xA;puts redis.hgetall(&amp;quot;hash1&amp;quot;)&#xA;puts &#39;*&#39; * 10&#xA;puts redis.hget(&amp;quot;hash1&amp;quot;, &amp;quot;field2&amp;quot;)&#xA;puts &#39;*&#39; * 10&#xA;puts redis.hmget(&amp;quot;hash1&amp;quot;, &amp;quot;field0&amp;quot;, &amp;quot;field1&amp;quot;, &amp;quot;field3&amp;quot;, &amp;quot;field4&amp;quot;)&#xA;#field0&#xA;#field1&#xA;#field2&#xA;#field3&#xA;#field4&#xA;#**********&#xA;#**********&#xA;#hash-value0&#xA;#hash-value2&#xA;#hash-value3&#xA;#hash-value4&#xA;#**********&#xA;#{&amp;quot;field0&amp;quot;=&amp;gt;&amp;quot;hash-value0&amp;quot;, &amp;quot;field2&amp;quot;=&amp;gt;&amp;quot;hash-value2&amp;quot;, &amp;quot;field3&amp;quot;=&amp;gt;&amp;quot;hash-value3&amp;quot;, &amp;quot;field4&amp;quot;=&amp;gt;&amp;quot;hash-value4&amp;quot;}&#xA;#**********&#xA;#hash-value2&#xA;#**********&#xA;#hash-value0&#xA;#&#xA;#hash-value3&#xA;#hash-value4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
  </channel>
</rss>