<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <title>首页</title>
  
    <meta name="author" content="Rojazz1999">
    <link type="application/rss+xml" rel="alternate" title="CODE4FUN posts" href="/rss.xml">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="/assets/simple/stylesheets/style.css" type="text/css" rel="stylesheet" media="all">
<link href="/assets/simple/widgets/google_prettify/stylesheets/twitter-bootstrap.css" type="text/css" rel="stylesheet" media="all">


  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>
    <header class="header">
      CODE4FUN
    </header>
    <nav>
      
        
  <a href="/" class="active">首页</a>




      
        


  <a href="/archive">文章</a>


      
    </nav>
    <article class="main">
        

<div class="post">
  <h3 class="title">
    <a href="/2014/09/19/%E4%BA%91%E4%B8%BB%E6%9C%BA%E4%BB%B7%E6%A0%BC%E6%AF%94%E8%BE%83.html">云主机价格比较</a>
    <span class="date">2014-09-19</span>
  </h3>
  <h1><a style="display: block;" name="云主机价格" href="#云主机价格"></a>云主机价格</h1>

<p>计费单位为元每月, 使用各服务商官方提供的计算器计算</p>

<p>价格基于以下配置</p>

<table><thead><tr><th align="left">CPU</th><th align="left">内存</th><th>系统盘</th><th>数据盘</th><th>线路</th><th>带宽</th></tr></thead><tbody><tr><td align="left">1核</td><td align="left">2G</td><td>20G</td><td>100G</td><td>双线</td><td>2Mbps</td></tr></tbody></table>

<h2><a style="display: block;" name="[ucloud](http://www.ucloud.cn/)" href="#[ucloud](http://www.ucloud.cn/)"></a><a href="http://www.ucloud.cn/">UCloud</a></h2>

<table><thead><tr><th align="left">CPU</th><th align="left">内存</th><th>系统盘</th><th>数据盘</th><th>线路</th><th>带宽</th></tr></thead><tbody><tr><td align="left">1核</td><td align="left">2G</td><td>20G</td><td>100G</td><td>双线</td><td>2Mbps</td></tr></tbody></table>

<p>价格: 162元</p>

<h2><a style="display: block;" name="[青云](https://www.qingcloud.com/)" href="#[青云](https://www.qingcloud.com/)"></a><a href="https://www.qingcloud.com/">青云</a></h2>

<table><thead><tr><th align="left">CPU</th><th align="left">内存</th><th>系统盘</th><th>数据盘</th><th>线路</th><th>带宽</th></tr></thead><tbody><tr><td align="left">1核</td><td align="left">2G</td><td>20G</td><td>100G</td><td>未知</td><td>2Mbps</td></tr></tbody></table>

<p>价格: 251.28元</p>

  <div class="more">
    <a href="/2014/09/19/%E4%BA%91%E4%B8%BB%E6%9C%BA%E4%BB%B7%E6%A0%BC%E6%AF%94%E8%BE%83.html" class="btn">阅读更多...</a>
  </div>
</div>

<div class="post">
  <h3 class="title">
    <a href="/2014/07/23/%E4%BD%BF%E7%94%A8Python%E7%9A%8410%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF.html">使用Python的10个常见错误</a>
    <span class="date">2014-07-23</span>
  </h3>
  <p>从<a href="http://www.toptal.com/python/top-10-mistakes-that-python-programmers-make">10 Most Common Python Mistakes</a>抄来的.</p>

<p>使用 <a href="http://ipython.org/">iPython</a> 生成.</p>

<h2><a style="display: block;" name="#1:-错误的使用表达式做为函数默认值" href="##1:-错误的使用表达式做为函数默认值"></a>#1: 错误的使用表达式做为函数默认值</h2>

<pre><code>def foo(a = []):
    a.append('bar')
    return a

foo()
foo()
foo()
foo()
</code></pre>

  <div class="more">
    <a href="/2014/07/23/%E4%BD%BF%E7%94%A8Python%E7%9A%8410%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF.html" class="btn">阅读更多...</a>
  </div>
</div>

<div class="post">
  <h3 class="title">
    <a href="/2014/06/24/Go-1.3-Release-Notes.html">Go 1.3 Release Notes</a>
    <span class="date">2014-06-24</span>
  </h3>
  <p>6月18日，在Go 1.2发布六个月之后，Go官方宣布正式发布Go 1.3。Go 1.3并没有引入新的语言功能，只是进行了功能改进，并修复了一些bug以及用户的反馈。新的版本开始支持DragonFly BSD、Solaris、Plan 9和Google的NaCl（ Native Client），且显著改进了链接器和编译器。低版本的Go语言用户无需更改任何代码即可升级到Go 1.3。</p>

<p>主要改进包括：</p>

<ul>
<li>改进了内存模型。在缓冲的channel发送和接收数据时增加了一条规则，使缓冲的channel可以被用作一个简单的信号灯（Semaphore）。</li>
<li>不再支持Windows 2000。微软在2010年时就不再支持Windows 2000，现在Go 1.3也放弃对它的支持。</li>
<li>支持BSD和Solaris系统。Go 1.3开始支持DragonFly BSD、FreeBSD、NetBSD、OpenBSD、Plan 9、Solaris，但对这些系统的支持都有一些其他特殊要求，比如对FreeBSD的支持必须要求内核编译时配置COMPAT_FREEBSD32参数。</li>
<li>支持 Native Client 虚拟机架构。Go 1.3既可以在32位Inter架构处理器上( GOARCH=386 )运行，也能在64位Intel架构上运行，但是在64位架构上使用的是32位pointer，对于ARM架构暂不支持。关于Native Client的介绍可以阅读其官方介绍。</li>
<li>改进了栈的实现方式。将栈实现方式从分段（segmented）模型改为连续（contiguous）模型。当一个goroutine（ Go 语言提供的一种用户态线程）需要更多的栈空间且超过了可用大小时，栈会被转移到一个单独的更大的内存块。</li>
<li>改进了垃圾回收机制。Go已经在堆上实现了精准的垃圾回收，Go 1.3增加了栈上的垃圾回收。另外，GC的速度也得到了提升，现在采用的是并发清除算法，可以缩短50-70%的GC中断时间。</li>
<li>重构了链接器。对链接器和编译器进行了重构，链接器仍然是使用C语言编写，但是指令选择阶段被移入到编译器中并创建了一个新的包liblink。指令选择只会在程序包被编译时执行一次，所以这这样可以加快大幅度提升大工程的编译速度。</li>
<li>其它的一些改进。比如实现了新的正则表达式引擎、更快的race detector、默认栈的大小从8K变为4K 字节、资源竞争的检测快了40%、增加了很多新参数等。</li>
</ul>

<p>读者可以在<a href="http://golang.org/dl/">这里</a>下载Go 1.3。详细的改进说明可以阅读<a href="http://tip.golang.org/doc/go1.3">官方文档</a>。不能翻墙的用户可以使用社区提供的镜像来<a href="http://golangtc.com/download">下载</a>。</p>

  <div class="more">
    <a href="/2014/06/24/Go-1.3-Release-Notes.html" class="btn">阅读更多...</a>
  </div>
</div>

<div class="post">
  <h3 class="title">
    <a href="/2014/05/12/ElasticSearch%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E9%80%9F%E6%9F%A5.html">ElasticSearch索引优化速查</a>
    <span class="date">2014-05-12</span>
  </h3>
  <p>最近做ElasticSearch索引的优化, 发现一篇好文. 转载于此, 有空再翻译.</p>

<p>原文地址: <a href="https://blog.codecentric.de/en/2014/05/elasticsearch-indexing-performance-cheatsheet/">Elasticsearch Indexing Performance Cheatsheet</a></p>

<hr />

<p>You plan to index large amounts of data in Elasticsearch? Or you are already trying to do so but it turns out that throughput is too low? Here is a collection of tips and ideas to increase indexing throughput with Elasticsearch. Some of them I have successfully tried myself, others I have only read about and found them reasonable. In any case, I hope you will find them useful.</p>

<p>In order to fit all this into a single article, I have kept the suggestions rather brief. For some of them, you may feel that you need to learn more before putting them into practice. To ease your task a little, I have included links to the relevant sections of the Elasticsearch documentation which you may use as a starting point for further research.</p>

<h3>General Performance</h3>

<p>Before doing anything more specific, it makes sense to follow the advice given in the Elasticsearch documentation on <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/setup-configuration.html">configuration</a>. In a nutshell:</p>

<ul>
<li>Set the maximum number of open file descriptors for the user running Elasticsearch to at least 32k or 64k.</li>
<li>If possible, consider disabling swapping for the Elasticsearch process memory. Note, however, that in a virtualized environment this may not behave as expected.</li>
<li>Set -Xms to the same value as -Xmx (the same result can be achieved by setting the ES_HEAP_SIZE environment variable).</li>
<li>Leave some amount of physical memory unassigned so that the OS file system cache is free to use it for Lucene’s benefit. A rule of thumb is to have the Elasticsearch JVM use no more than half of the available memory.</li>
</ul>

  <div class="more">
    <a href="/2014/05/12/ElasticSearch%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E9%80%9F%E6%9F%A5.html" class="btn">阅读更多...</a>
  </div>
</div>

<div class="post">
  <h3 class="title">
    <a href="/2014/04/22/Docker%E4%B8%AD%E9%81%97%E5%A4%B1%E7%9A%84%E5%8C%85.html">Docker中遗失的包</a>
    <span class="date">2014-04-22</span>
  </h3>
  <p><a href="http://crosbymichael.com/the-lost-packages-of-docker.html">原文</a>   <a href="http://www.oschina.net/translate/the-lost-packages-of-docker">翻译</a></p>

<h2><a style="display: block;" name="netlink" href="#netlink"></a>netlink</h2>

<p>我们有一个Netlink的纯Go实现，你可以用在你的项目中。你可以使用这个包来创建veth 接口，桥，设置IP，mtu，和网络接口的其他设置，移动网络接口到不同的Linux命名空间中，等等一堆事情。创建veth pairs和对你的每个docker容器分配一个IP的代码是相同的。</p>

<p>让我们用这个包创建一个桥并设置一个IP：</p>

<pre><code>package main

import (
        &quot;github.com/dotcloud/docker/pkg/netlink&quot;
        &quot;log&quot;
        &quot;net&quot;
)

func main() {
        // create a new bridge
        if err := netlink.CreateBridge(&quot;mydocker0&quot;, false); err != nil {
                log.Fatal(err)
        }
        // get the bridge
        bridge, err := net.InterfaceByName(&quot;mydocker0&quot;)
        if err != nil {
                log.Fatal(err)
        }

        ip, ipNet, err := net.ParseCIDR(&quot;10.0.41.1/16&quot;)
        if err != nil {
                log.Fatal(err)
        }

        // add an ip to the bridge
        if err := netlink.NetworkLinkAddIp(bridge, ip, ipNet); err != nil {
                log.Fatal(err)
        }
        // bring the interface up
        if err := netlink.NetworkLinkUp(bridge); err != nil {
                log.Fatal(err)
        }
}
</code></pre>

  <div class="more">
    <a href="/2014/04/22/Docker%E4%B8%AD%E9%81%97%E5%A4%B1%E7%9A%84%E5%8C%85.html" class="btn">阅读更多...</a>
  </div>
</div>

<div class="post">
  <h3 class="title">
    <a href="/2014/04/18/%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%83%E9%87%8C%E7%9A%84%E7%97%9B%E5%8F%AA%E6%9C%89%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%89%8D%E4%BC%9A%E6%87%82.html">工程师心里的痛只有工程师才会懂</a>
    <span class="date">2014-04-18</span>
  </h3>
  <p>工程师心里的痛只有工程师才会懂</p>

<p><embed src="http://player.youku.com/player.php/sid/XNjk3NTQ5ODE2/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p>

  <div class="more">
    <a href="/2014/04/18/%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%83%E9%87%8C%E7%9A%84%E7%97%9B%E5%8F%AA%E6%9C%89%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%89%8D%E4%BC%9A%E6%87%82.html" class="btn">阅读更多...</a>
  </div>
</div>

<div class="post">
  <h3 class="title">
    <a href="/2014/04/04/ElasticSearch%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A.html">ElasticSearch名词解释</a>
    <span class="date">2014-04-04</span>
  </h3>
  <ul>
<li>cluster</li>
</ul>

<p>每个cluster由一个或多个节点组成,它们共享同一个集群名.每个cluster有一个被自动选出的master节点,当该master节点挂掉的时候会被自动替换.</p>

<ul>
<li>node</li>
</ul>

<p>node是elasticsearch的运行实例.为了测试,多个node可以在同一台服务器上启动,但是通常一个服务器只放一个node.
系统启动时,node会使用广播(或指定的多播)来发现一个现有的cluster,并且试图加入该cluster.</p>

<ul>
<li>index</li>
</ul>

<p>index有点像关系型数据库中的“database”,包含不同的type的schema映射.
一个index是一个逻辑上的命名空间,具有一个或多个primary shards,可以拥有零个或多个replia shards.</p>

<ul>
<li>shard</li>
</ul>

<p>一个shard是一个单独的lucene实例,是被elasticsearch自动管理的底层工作单元.一个索引是包含primary或replia切片的逻辑命名空间.
除了需要定义primary shards和replia shards的数量以外,你不需要直接指定使用的shards,你的代码中只关心index就好.
Elasticsearch在集群中分布所有的shards,并且在添加删除节点时,自动重新分配.</p>

  <div class="more">
    <a href="/2014/04/04/ElasticSearch%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A.html" class="btn">阅读更多...</a>
  </div>
</div>

<div class="post">
  <h3 class="title">
    <a href="/2014/03/31/Golang%E8%B0%83%E7%94%A8C.html">Golang调用C</a>
    <span class="date">2014-03-31</span>
  </h3>
  <p>有时候我们需要在go中调用一些使用C或者C++编写的代码. 而这些代码大多数会被编译成动态链接库的形式存在.</p>

<p>本文就以Mac OS下的Go开发为例, 来测试在GO中调用C.</p>

<p>首先做一个简单的动态链接库.</p>

<p>hello.h</p>

<pre><code class="c">#ifndef HELLO_H
#define HELLO_H

void hello(const char *name);

#endif
</code></pre>

<p>hello.c</p>

<pre><code class="c">#include &lt;stdio.h&gt;

void hello(const char *name) {
  printf(&quot;Hello %s!\n&quot;, name);
}
</code></pre>

  <div class="more">
    <a href="/2014/03/31/Golang%E8%B0%83%E7%94%A8C.html" class="btn">阅读更多...</a>
  </div>
</div>

<div class="post">
  <h3 class="title">
    <a href="/2014/03/30/Go%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%96%E6%B6%88.html">Go并发模式：管道和取消</a>
    <span class="date">2014-03-30</span>
  </h3>
  <p>由<a href="http://air.googol.im/2014/03/15/go-concurrency-patterns-pipelines-and-cancellation.html">Air on G</a>翻译.</p>

<p>译自[](http://blog.golang.org/pipelines)<a href="http://blog.golang.org/pipelines">http://blog.golang.org/pipelines</a>。</p>

<p>这是 Go 官方 blog 的一篇文章，介绍了如何使用 Go 来编写并发程序，并按照程序的演化顺序，介绍了不同模式遇到的问题以及解决的问题。主要解释了用管道模式链接不同的线程，以及如何在某个线程取消工作时，保证所有线程以及管道资源的正常回收。</p>

<p>Go 并发模式：管道和取消</p>

<p>作者：Sameer Ajmani，<a href="http://blog.golang.org">blog.golang.org</a>，写于 2014 年 3 月 13 日。</p>

<h3>介绍</h3>

<p>Go 本身提供的并发特性，可以轻松构建用于处理流数据的管道，从而高效利用 I/O 和多核 CPU。这篇文章就展示了这种管道的例子，并关注当操作失败时要处理的一些细节，并介绍了如何干净的处理错误的技巧。</p>

<h3>什么是管道？</h3>

<p>Go 语言里没有明确定义管道，而只是把管道当作一类并发程序。简单来说，管道是一系列由 channel 联通的状态（stage），而每个状态是一组运行相同函数的 Goroutine。每个状态上，Goroutine</p>

<ul>
<li>通过流入（inbound）channel 接收上游的数值</li>
<li>运行一些函数来处理接收的数据，一般会产生新的数值</li>
<li>通过流出（outbound）channel 将数值发给下游</li>
</ul>

  <div class="more">
    <a href="/2014/03/30/Go%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%96%E6%B6%88.html" class="btn">阅读更多...</a>
  </div>
</div>

<div class="post">
  <h3 class="title">
    <a href="/2014/03/13/Linux-%E6%96%87%E4%BB%B6-Loop%E8%AE%BE%E5%A4%87-LVM.html">Linux 文件 Loop设备 LVM</a>
    <span class="date">2014-03-13</span>
  </h3>
  <p>不知道标题该怎么取. 本文主要介绍在Linux下怎样将文件挂载成磁盘并且用LVM进行分区管理.</p>

<h2><a style="display: block;" name="什么是loop设备" href="#什么是loop设备"></a>什么是loop设备</h2>

<p>loop设备是一种伪设备. 是使用文件来模拟块设备的一种技术. 文件模拟成块设备后, 就像一个磁盘或光盘一样使用. 回环可以理解成回复重用, 在已有设备上建立文件来模拟物理块设备.</p>

<h2><a style="display: block;" name="关联loop设备" href="#关联loop设备"></a>关联loop设备</h2>

<p>一般在linux中会有8个loop设备. 我们可以将文件关联到这些设备上.
查看所有的loop设备: <code>losetup -a</code>, 输出:
<code>
/dev/loop0: [0806]:5373954 (/mnt/var/disk/disk0.img)
/dev/loop1: [0806]:5373955 (/mnt/var/disk/disk1.img)
/dev/loop2: [0806]:5373956 (/mnt/var/disk/disk2.img)
/dev/loop3: [0806]:5373957 (/mnt/var/disk/disk3.img)
</code></p>

<p>查看下一个未使用的loop设备: <code>losetup -f</code>, 输出:
</p>

  <div class="more">
    <a href="/2014/03/13/Linux-%E6%96%87%E4%BB%B6-Loop%E8%AE%BE%E5%A4%87-LVM.html" class="btn">阅读更多...</a>
  </div>
</div>


    </article>
    <footer>
      Copyright &copy; 2014 Rojazz1999 &#8226; <a href='https://plus.google.com/u/0/101202661005324839860?rel=author' rel='me'>Google+</a> &#8226; Hosted by <a href='http://github.com/prisoner/prisoner.github.com/' target='_blank'>GitHub</a> &#8226; powered by <a href='https://github.com/wendal/gor'>gor</a>
    </footer>
    
<script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>
<script>
  var pres = document.getElementsByTagName("pre");
  for (var i=0; i < pres.length; ++i) {
    pres[i].className = "prettyprint linenums";
  }
  prettyPrint();
</script>

  </body>
</html>
